<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="printfHashFormatSpecifierIllegal" xml:space="preserve">
    <value># 書式修飾子は F# では無効です</value>
  </data>
  <data name="invalidTupleTypeConstructorNotDefined" xml:space="preserve">
    <value>タプル型 '{0}' は無効です。必要なコンストラクターが定義されていません。</value>
  </data>
  <data name="syncContextNull" xml:space="preserve">
    <value>呼び出しスレッドの System.Threading.SynchronizationContext.Current が null です。</value>
  </data>
  <data name="QtupleAccessOutOfRange" xml:space="preserve">
    <value>タプルのアクセスが範囲外です</value>
  </data>
  <data name="unsupportedQueryCall" xml:space="preserve">
    <value>これは有効なクエリ式ではありません。クエリでメソッド '{0}' が使用されていますが、F# から LINQ へのクエリ トランスレーターに認識されません。許可されたクエリの仕様を確認し、一部の操作をクエリ式の外に移動することを検討してください</value>
  </data>
  <data name="QfailedToBindTypeInAssembly" xml:space="preserve">
    <value>アセンブリ '{1}' の型 '{0}' をバインドできませんでした</value>
  </data>
  <data name="badFormatString" xml:space="preserve">
    <value>文字列の形式が正しくありません。</value>
  </data>
  <data name="QincorrectInstanceType" xml:space="preserve">
    <value>インスタンス型が正しくありません</value>
  </data>
  <data name="QcannotBindFunction" xml:space="preserve">
    <value>型 {1} で関数 {0} をバインドできませんでした</value>
  </data>
  <data name="QfailedToBindField" xml:space="preserve">
    <value>フィールド '{0}' をバインドできませんでした</value>
  </data>
  <data name="printfPrecisonSpecifierIllegal" xml:space="preserve">
    <value>書式指定子 (精度) が正しくありません</value>
  </data>
  <data name="nullsNotAllowedInArray" xml:space="preserve">
    <value>配列の要素の 1 つが null です。</value>
  </data>
  <data name="firstClassUsesOfSplice" xml:space="preserve">
    <value>'%' または '%%' のファースト クラスの使用は許可されていません</value>
  </data>
  <data name="QtmmCondMustBeBool" xml:space="preserve">
    <value>'{0}' を構築するときの型の不一致: 条件式は bool 型である必要があります。'{1}' が必要でしたが、型 '{2}' を受け取りました。</value>
  </data>
  <data name="unsupportedQueryProperty" xml:space="preserve">
    <value>これは有効なクエリ式ではありません。クエリでプロパティ '{0}' が使用されていますが、F# から LINQ へのクエリ トランスレーターに認識されません。許可されたクエリの仕様を確認し、一部の操作をクエリ式の外に移動することを検討してください。</value>
  </data>
  <data name="QtmmVarTypeNotMatchRHS" xml:space="preserve">
    <value>'{0}' を構築するときの型の不一致: 変数型が let 束縛の右側の型と一致しません。'{1}' が必要でしたが、型 '{2}' を受け取りました。</value>
  </data>
  <data name="QcannotBindProperty" xml:space="preserve">
    <value>型 {1} でプロパティ {0} をバインドできませんでした</value>
  </data>
  <data name="inputMustBeNonNegative" xml:space="preserve">
    <value>入力は負以外である必要があります。</value>
  </data>
  <data name="objIsNotARecord" xml:space="preserve">
    <value>オブジェクトは F# レコード値ではありません。</value>
  </data>
  <data name="QparentCannotBeNull" xml:space="preserve">
    <value>親の型を null にすることはできません</value>
  </data>
  <data name="keyNotFoundAlt" xml:space="preserve">
    <value>述語を満たすインデックスがコレクションに見つかりませんでした。</value>
  </data>
  <data name="keyNotFound" xml:space="preserve">
    <value>項目、キー、またはインデックスがコレクションに見つかりませんでした。</value>
  </data>
  <data name="mailboxReceiveTimedOut" xml:space="preserve">
    <value>Mailbox.Receive がタイムアウトしました。</value>
  </data>
  <data name="startCannotBeNaN" xml:space="preserve">
    <value>範囲の開始を NaN にすることはできません。</value>
  </data>
  <data name="QincompatibleRecordLength" xml:space="preserve">
    <value>互換性のないレコード長</value>
  </data>
  <data name="QtmmExprTypeMismatch" xml:space="preserve">
    <value>'{0}' を構築するときの型の不一致: 式の型が一致しません。'{1}' が必要でしたが、型 '{2}' を受け取りました。</value>
  </data>
  <data name="checkStaticInit" xml:space="preserve">
    <value>ファイルまたは型の静的な初期化の結果、静的データが、完全に初期化される前に再帰的にアクセスされました。</value>
  </data>
  <data name="notEnoughElements" xml:space="preserve">
    <value>入力シーケンスには十分な数の要素がありません。</value>
  </data>
  <data name="moveNextNotCalledOrFinished" xml:space="preserve">
    <value>MoveNext は呼び出されていないか、終了しました</value>
  </data>
  <data name="QtmmFunctionArgTypeMismatch" xml:space="preserve">
    <value>'{0}' を構築するときの型の不一致: 関数引数型が一致しません。'{1}' が必要でしたが、型 '{2}' を受け取りました。</value>
  </data>
  <data name="QmissingUnionCase" xml:space="preserve">
    <value>型 '{0}' には '{1}' という名前の F# 共用体ケースがありませんでした。</value>
  </data>
  <data name="QtmmRaw" xml:space="preserve">
    <value>式を引用リテラルにスプライスするときの型が一致していません。挿入されている式ツリーの型が、スプライス操作に必要な型と一致しません。'{0}' が必要でしたが、型 '{1}' を受け取りました。(%% x : {0}) や (%x : {0}) など必要な式の型での型注釈付けを検討してください。</value>
  </data>
  <data name="privateRecordType" xml:space="preserve">
    <value>型 '{0}' は F# レコード型ですが、その表現はプライベートです。プライベート型表現にアクセスするには BindingFlags.NonPublic を指定する必要があります。</value>
  </data>
  <data name="unsupportedQueryConstructKind" xml:space="preserve">
    <value>これは有効なクエリ式ではありません。クエリで構造 '{0}' が使用されていますが、F# から LINQ へのクエリ トランスレーターに認識されません。許可されたクエリの仕様を確認し、一部の操作をクエリ式の外に移動することを検討してください。</value>
  </data>
  <data name="enumerationPastIntMaxValue" xml:space="preserve">
    <value>System.Int32 に基づく列挙型が System.Int32.MaxValue を超えました。</value>
  </data>
  <data name="QfailedToBindProperty" xml:space="preserve">
    <value>プロパティ '{0}' をバインドできませんでした</value>
  </data>
  <data name="stepCannotBeZero" xml:space="preserve">
    <value>範囲のステップをゼロにすることはできません。</value>
  </data>
  <data name="addressOpNotFirstClass" xml:space="preserve">
    <value>アドレス演算子のファースト クラスの使用は許可されていません。</value>
  </data>
  <data name="notARecordType" xml:space="preserve">
    <value>型 '{0}' は F# レコード型ではありません。</value>
  </data>
  <data name="dyInvDivByIntCoerce" xml:space="preserve">
    <value>強制型変換に関連する DivideByInt の動的な呼び出しはサポートされていません。</value>
  </data>
  <data name="arraysHadDifferentLengths" xml:space="preserve">
    <value>配列の長さが異なります。</value>
  </data>
  <data name="QtmmInitArray" xml:space="preserve">
    <value>'{0}' を構築するときの型の不一致: 初期化子が配列型と一致しません。'{1}' が必要でしたが、型 '{2}' を受け取りました。</value>
  </data>
  <data name="delegateExpected" xml:space="preserve">
    <value>デリゲート型を必要としています。</value>
  </data>
  <data name="QtmmTrueAndFalseMustMatch" xml:space="preserve">
    <value>'{0}' を構築するときの型の不一致: true と false の分岐の型が異なります。'{1}' が必要でしたが、型 '{2}' を受け取りました。</value>
  </data>
  <data name="genericCompareFail1" xml:space="preserve">
    <value>汎用的な比較中にエラーが発生しました: 型 '{0}' は System.IComparable インターフェイスを実装しません。このエラーは、'compare'、'max'、'min' などの関数、またはこの型のインスタンスを含むキーを持つ 'Set' や 'Map' などのデータ構造を使用した場合に発生することがあります。</value>
  </data>
  <data name="QunexpectedHole" xml:space="preserve">
    <value>式に予期しない引用のホールがあります。</value>
  </data>
  <data name="outOfRange" xml:space="preserve">
    <value>インデックスは有効範囲外です。</value>
  </data>
  <data name="printfExpectedPrecision" xml:space="preserve">
    <value>精度引数が必要でした</value>
  </data>
  <data name="stepCannotBeNaN" xml:space="preserve">
    <value>範囲のステップを NaN にすることはできません。</value>
  </data>
  <data name="arrayWasEmpty" xml:space="preserve">
    <value>入力配列が空でした。</value>
  </data>
  <data name="QstaticWithReceiverObject" xml:space="preserve">
    <value>メンバーは静的であるため、レシーバー オブジェクトは予期されていませんでした</value>
  </data>
  <data name="inputSequenceTooLong" xml:space="preserve">
    <value>入力シーケンスに複数の要素が含まれています。</value>
  </data>
  <data name="setContainsNoElements" xml:space="preserve">
    <value>セットに要素がありません。</value>
  </data>
  <data name="QtmmExprHasWrongType" xml:space="preserve">
    <value>'{0}' を構築するときの型の不一致: 式に間違った型があります。'{1}' が必要でしたが、型 '{2}' を受け取りました。</value>
  </data>
  <data name="QexpectedTwoTypes" xml:space="preserve">
    <value>型引数が 2 つだけ必要でした。</value>
  </data>
  <data name="QtmmBadFieldType" xml:space="preserve">
    <value>'{0}' を構築するときの型の不一致: フィールドの型が正しくありませんでした。'{1}' が必要でしたが、型 '{2}' を受け取りました。</value>
  </data>
  <data name="checkInit" xml:space="preserve">
    <value>オブジェクトまたは値の初期化の結果、そのオブジェクトまたは値が、完全に初期化される前に再帰的にアクセスされました。</value>
  </data>
  <data name="invalidRecordTypeConstructorNotDefined" xml:space="preserve">
    <value>レコード型 '{0}' は無効です。必要なコンストラクターが定義されていません。</value>
  </data>
  <data name="mailboxProcessorPostAndAsyncReplyTimedOut" xml:space="preserve">
    <value>MailboxProcessor.PostAndAsyncReply がタイムアウトしました。</value>
  </data>
  <data name="QfailedToBindAssembly" xml:space="preserve">
    <value>引用データの処理中にアセンブリ '{0}' をバインドできませんでした</value>
  </data>
  <data name="printfWidthSpecifierIllegal" xml:space="preserve">
    <value>書式指定子 (幅) が正しくありません</value>
  </data>
  <data name="dyInvOpMultCoerce" xml:space="preserve">
    <value>強制型変換に関連する op_Multiply の動的な呼び出しはサポートされていません。</value>
  </data>
  <data name="QincorrectNumArgs" xml:space="preserve">
    <value>引数の数が正しくありません</value>
  </data>
  <data name="matchCasesIncomplete" xml:space="preserve">
    <value>一致条件が不完全でした</value>
  </data>
  <data name="mismatchIAREnd" xml:space="preserve">
    <value>提供された IAsyncResult オブジェクトはこの '終了' 操作と一致しません。</value>
  </data>
  <data name="inputSequenceEmpty" xml:space="preserve">
    <value>入力シーケンスが空でした。</value>
  </data>
  <data name="QinvalidFuncType" xml:space="preserve">
    <value>無効な関数型</value>
  </data>
  <data name="mismatchIARCancel" xml:space="preserve">
    <value>提供された IAsyncResult オブジェクトはこの '取り消し' 操作と一致しません。</value>
  </data>
  <data name="invalidTupleTypes" xml:space="preserve">
    <value>これは F# リフレクション ライブラリに対して有効なタプル型ではありません。</value>
  </data>
  <data name="thenByError" xml:space="preserve">
    <value>'thenBy' および 'thenByDescending' は、順序付けされた入力だけで使用できます</value>
  </data>
  <data name="notUsedForHashing" xml:space="preserve">
    <value>このオブジェクトは再帰的な等値呼び出し用であり、ハッシュには使用できません。</value>
  </data>
  <data name="resetNotSupported" xml:space="preserve">
    <value>この列挙子ではリセットがサポートされていません。</value>
  </data>
  <data name="QwritingGetOnly" xml:space="preserve">
    <value>取得専用のプロパティを書き込んでいます</value>
  </data>
  <data name="enumerationAlreadyFinished" xml:space="preserve">
    <value>列挙は既に終了しています。</value>
  </data>
  <data name="QcannotTakeAddress" xml:space="preserve">
    <value>この引用のアドレスを取得できません</value>
  </data>
  <data name="QexpectedOneType" xml:space="preserve">
    <value>型引数が 1 つだけ必要でした。</value>
  </data>
  <data name="dyInvOpAddCoerce" xml:space="preserve">
    <value>強制型変換に関連する op_Addition の動的な呼び出しはサポートされていません。</value>
  </data>
  <data name="tupleIndexOutOfRange" xml:space="preserve">
    <value>タプル インデックス '{1}' はタプル型 '{0}' の範囲外でした。</value>
  </data>
  <data name="printfExpectedWidth" xml:space="preserve">
    <value>幅引数が必要でした</value>
  </data>
  <data name="notAUnionType" xml:space="preserve">
    <value>型 '{0}' は F# 共用体型ではありません。</value>
  </data>
  <data name="QfailedToBindConstructor" xml:space="preserve">
    <value>コンストラクターをバインドできませんでした</value>
  </data>
  <data name="QtmmLoopBodyMustBeLambdaTakingInteger" xml:space="preserve">
    <value>'{0}' を構築するときの型の不一致: for loop の本体は整数を引数として受け取るラムダである必要があります。'{1}' が必要でしたが、型 '{2}' を受け取りました。</value>
  </data>
  <data name="QincorrectType" xml:space="preserve">
    <value>型が正しくありません</value>
  </data>
  <data name="controlContinuationInvokedMultipleTimes" xml:space="preserve">
    <value>Async.FromContinuations で提供される継続が複数回呼び出されました</value>
  </data>
  <data name="QtmmFunTypeNotMatchDelegate" xml:space="preserve">
    <value>'{0}' を構築するときの型の不一致: 関数型がデリゲート型と一致しません。'{1}' が必要でしたが、型 '{2}' を受け取りました。</value>
  </data>
  <data name="notAPermutation" xml:space="preserve">
    <value>関数は順列を計算しませんでした。</value>
  </data>
  <data name="printfMissingFormatSpecifier" xml:space="preserve">
    <value>書式指定子がありません</value>
  </data>
  <data name="notATupleType" xml:space="preserve">
    <value>型 '{0}' はタプル型ではありません。</value>
  </data>
  <data name="QtmmExprNotMatchTuple" xml:space="preserve">
    <value>'{0}' を構築するときの型の不一致: 式がタプル型と一致しません。'{1}' が必要でしたが、型 '{2}' を受け取りました。</value>
  </data>
  <data name="QtmmBodyMustBeUnit" xml:space="preserve">
    <value>'{0}' を構築するときの型の不一致: 本体はユニットを返す必要があります。'{1}' が必要でしたが、型 '{2}' を受け取りました。</value>
  </data>
  <data name="notComparable" xml:space="preserve">
    <value>2 つのオブジェクトの型が異なり、比較できません。</value>
  </data>
  <data name="ThisValueCannotBeMutated" xml:space="preserve">
    <value>この値は変換できません</value>
  </data>
  <data name="unsupportedQueryConstruct" xml:space="preserve">
    <value>これは有効なクエリ式ではありません。クエリで次の構造が使用されていますが、F# から LINQ へのクエリ トランスレーターに認識されません:\n{0}\n許可されたクエリの仕様を確認し、一部の操作をクエリ式の外に移動することを検討してください。</value>
  </data>
  <data name="multipleCompilationMappings" xml:space="preserve">
    <value>複数の CompilationMappingAttribute がありますが、必要なのは最大 1 つです</value>
  </data>
  <data name="indexOutOfBounds" xml:space="preserve">
    <value>インデックスはリストの要素の範囲外にありました。</value>
  </data>
  <data name="printfSpecifierAfterIllegal" xml:space="preserve">
    <value>書式指定子 ({0} の後) が正しくありません</value>
  </data>
  <data name="QnonStaticNoReceiverObject" xml:space="preserve">
    <value>メンバーは非静的 (インスタンス) ですが、レシーバー オブジェクトが指定されませんでした</value>
  </data>
  <data name="QtmmIncorrectArgForUnion" xml:space="preserve">
    <value>'{0}' を構築するときの型の不一致: F# 共用体の引数型が正しくありません。'{1}' が必要でしたが、型 '{2}' を受け取りました。</value>
  </data>
  <data name="QtupleLengthsDiffer" xml:space="preserve">
    <value>タプルの長さが異なります</value>
  </data>
  <data name="notAFunctionType" xml:space="preserve">
    <value>型 '{0}' は関数型ではありません。</value>
  </data>
  <data name="printfNotAFunType" xml:space="preserve">
    <value>関数型ではありません</value>
  </data>
  <data name="QwrongNumOfTypeArgs" xml:space="preserve">
    <value>メソッド '{0}' には {1} 個の型引数が必要ですが、{2} 個が指定されました</value>
  </data>
  <data name="mailboxProcessorAlreadyStarted" xml:space="preserve">
    <value>MailboxProcessor は既に開始されています。</value>
  </data>
  <data name="dyInvOpAddOverload" xml:space="preserve">
    <value>オーバーロードに関連する op_Addition の動的な呼び出しはサポートされていません。</value>
  </data>
  <data name="privateExceptionType" xml:space="preserve">
    <value>型 '{0}' は F# 例外宣言の表現ですが、その表現はプライベートです。プライベート型表現にアクセスするには BindingFlags.NonPublic を指定する必要があります。</value>
  </data>
  <data name="privateUnionType" xml:space="preserve">
    <value>型 '{0}' は F# 共用体型ですが、その表現はプライベートです。プライベート型表現にアクセスするには BindingFlags.NonPublic を指定する必要があります。</value>
  </data>
  <data name="QtmmInvalidParam" xml:space="preserve">
    <value>'{0}' を構築するときの型の不一致:メソッドまたはインデクサー プロパティのパラメーターが無効です。'{1}' が必要でしたが、型 '{2}' を受け取りました。</value>
  </data>
  <data name="mailboxProcessorPostAndReplyTimedOut" xml:space="preserve">
    <value>MailboxProcessor.PostAndReply がタイムアウトしました。</value>
  </data>
  <data name="printfBadFloatValue" xml:space="preserve">
    <value>浮動小数値が正しくありません</value>
  </data>
  <data name="inputListWasEmpty" xml:space="preserve">
    <value>入力リストが空でした。</value>
  </data>
  <data name="QtmmExpectedFunction" xml:space="preserve">
    <value>'{0}' を構築するときの型の不一致: 関数アプリケーションまたは let 束縛では関数型が必要でした。'{1}' が必要でしたが、型 '{2}' を受け取りました。</value>
  </data>
  <data name="failDueToUnsupportedInputTypeInSumByOrAverageBy" xml:space="preserve">
    <value>クエリ内で 'sumBy' または 'averageBy' 演算子が認識されない使われ方をしています。元のデータがスタティック型 IQueryable であるクエリでは、これらの演算子は結果の型が int32、int64、single、double、または decimal である場合にだけ使用できます。</value>
  </data>
  <data name="dyInvOpMultOverload" xml:space="preserve">
    <value>オーバーロードに関連する op_Multiply の動的な呼び出しはサポートされていません。</value>
  </data>
  <data name="QunrecognizedMethodCall" xml:space="preserve">
    <value>パラメーターは認識されているメソッド名ではありません。</value>
  </data>
  <data name="objIsNullAndNoType" xml:space="preserve">
    <value>オブジェクトは null であり、型が指定されていません。null 以外のオブジェクトまたは null 以外の型パラメーターを渡してください。</value>
  </data>
  <data name="QreadingSetOnly" xml:space="preserve">
    <value>設定専用のプロパティを読み取っています</value>
  </data>
  <data name="QtmmLowerUpperBoundMustBeInt" xml:space="preserve">
    <value>'{0}' を構築するときの型の不一致: 下限と上限は整数である必要があります。'{1}' が必要でしたが、型 '{2}' を受け取りました。</value>
  </data>
  <data name="QunionNeedsDiffNumArgs" xml:space="preserve">
    <value>F# 共用体型には異なる数の引数が必要です</value>
  </data>
  <data name="constructorForUnionCaseNotFound" xml:space="preserve">
    <value>共用体ケースのコンストラクター メソッド '{0}' が見つかりませんでした</value>
  </data>
  <data name="enumerationNotStarted" xml:space="preserve">
    <value>列挙は開始していません。MoveNext を呼び出してください。</value>
  </data>
  <data name="optionValueWasNone" xml:space="preserve">
    <value>オプション値は None でした</value>
  </data>
  <data name="printfBadIntegerForDynamicFomatter" xml:space="preserve">
    <value>動的フォーマッタに対して指定された整数が正しくありません</value>
  </data>
  <data name="QtmmTuple" xml:space="preserve">
    <value>'{0}' を構築するときの型の不一致: 引数とタプル要素の型が一致しませんでした。'{1}' が必要でしたが、型 '{2}' を受け取りました。</value>
  </data>
  <data name="QinvalidCaseIndex" xml:space="preserve">
    <value>有効な F# 共用体ケース インデックスではありません。</value>
  </data>
  <data name="inputMustBePositive" xml:space="preserve">
    <value>入力は正である必要があります。</value>
  </data>
  <data name="mapCannotBeMutated" xml:space="preserve">
    <value>マップ値は変換できません。</value>
  </data>
  <data name="QtmmIncorrectArgForRecord" xml:space="preserve">
    <value>'{0}' を構築するときの型の不一致: F# レコードの引数型が正しくありません。'{1}' が必要でしたが、型 '{2}' を受け取りました。</value>
  </data>
  <data name="failedReadEnoughBytes" xml:space="preserve">
    <value>ストリームから十分なバイト数を読み取ることができませんでした。</value>
  </data>
  <data name="endCannotBeNaN" xml:space="preserve">
    <value>範囲の最後を NaN にすることはできません。</value>
  </data>
  <data name="QtmmGuardMustBeBool" xml:space="preserve">
    <value>'{0}' を構築するときの型の不一致: ガードはブール型を返す必要があります。'{1}' が必要でしたが、型 '{2}' を受け取りました。</value>
  </data>
  <data name="noNegateMinValue" xml:space="preserve">
    <value>2 の補数の最小値を無効にすることはできません。</value>
  </data>
  <data name="QtypeArgumentOutOfRange" xml:space="preserve">
    <value>型引数が範囲外です</value>
  </data>
  <data name="mailboxScanTimedOut" xml:space="preserve">
    <value>Mailbox.Scan がタイムアウトしました。</value>
  </data>
  <data name="QillFormedAppOrLet" xml:space="preserve">
    <value>正しくない形式の式: AppOp または LetOp</value>
  </data>
  <data name="QmissingRecordField" xml:space="preserve">
    <value>型 '{0}' には '{1}' という名前の F# レコード フィールドがありませんでした。</value>
  </data>
  <data name="listsHadDifferentLengths" xml:space="preserve">
    <value>リストの長さが異なります。</value>
  </data>
  <data name="QcannotBindToMethod" xml:space="preserve">
    <value>メソッドにバインドできませんでした</value>
  </data>
  <data name="printfBadFormatSpecifier" xml:space="preserve">
    <value>書式指定子が正しくありません: {0}</value>
  </data>
  <data name="notAnExceptionType" xml:space="preserve">
    <value>型 '{0}' は F# 例外宣言の表現ではありません。</value>
  </data>
  <data name="nonZeroBasedDisallowed" xml:space="preserve">
    <value>このプラットフォームでは、ゼロ以外を基数とする配列を作成できません。</value>
  </data>
  <data name="unsupportedIfThenElse" xml:space="preserve">
    <value>if/then/else 条件節、または分岐のあるパターン一致式は、クエリで使用できません。if/then/else 条件節が使用されている可能性があります。</value>
  </data>
</root>