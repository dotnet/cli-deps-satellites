<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ERR_OutputNeedsName" xml:space="preserve">
    <value>Saídas sem origem devem ter a opção /out especificada</value>
  </data>
  <data name="ERR_IntDivByZero" xml:space="preserve">
    <value>Divisão por zero constante</value>
  </data>
  <data name="ERR_BadNamedAttributeArgumentType" xml:space="preserve">
    <value>"{0}" não é um argumento de atributo nomeado válido porque não é um tipo de parâmetro de atributo válido</value>
  </data>
  <data name="WRN_XMLParseError_Title" xml:space="preserve">
    <value>O comentário XML tem XML possui formato incorreto</value>
  </data>
  <data name="INF_UnableToLoadSomeTypesInAnalyzer" xml:space="preserve">
    <value>Ignorando a alguns tipos de assembly de analisador {0} devido a uma ReflectionTypeLoadException: {1}.</value>
  </data>
  <data name="WRN_UnreferencedFieldAssg_Title" xml:space="preserve">
    <value>O campo é atribuído, mas seu valor nunca é usado</value>
  </data>
  <data name="ERR_ExpressionTreeContainsAssignment" xml:space="preserve">
    <value>Uma árvore de expressões não pode conter um operador de atribuição</value>
  </data>
  <data name="ERR_DynamicRequiredTypesMissing" xml:space="preserve">
    <value>Não é possível encontrar um ou mais tipos necessários para compilar uma expressão dinâmica. Está precisando de uma referência?</value>
  </data>
  <data name="ERR_DeprecatedSymbolStr" xml:space="preserve">
    <value>"{0}" é obsoleto: "{1}"</value>
  </data>
  <data name="ERR_ConditionalOnSpecialMethod" xml:space="preserve">
    <value>O atributo Conditional não é válido em "{0}" porque é um construtor, destruidor, operador ou implementação de interface implícita</value>
  </data>
  <data name="ERR_BadModuleName" xml:space="preserve">
    <value>Nome de módulo inválido: {0}</value>
  </data>
  <data name="ERR_ConversionWithBase" xml:space="preserve">
    <value>"{0}": conversões definidas pelo usuário para ou de uma classe básica não são permitidas</value>
  </data>
  <data name="ERR_BadTypeReference" xml:space="preserve">
    <value>"{0}": não é possível fazer referência a um tipo por meio de uma expressão; ao invés disso, tente "{1}"</value>
  </data>
  <data name="ERR_CompilerAndLanguageVersion" xml:space="preserve">
    <value>Versão do compilador: '{0}'. Versão de linguagem: {1}.</value>
  </data>
  <data name="IDS_FeatureIterators" xml:space="preserve">
    <value>iteradores</value>
  </data>
  <data name="WRN_CantHaveManifestForModule" xml:space="preserve">
    <value>Ignore /win32manifest do módulo porque ele só se aplica aos assemblies</value>
  </data>
  <data name="FTL_BadCodepage" xml:space="preserve">
    <value>Página de código "{0}" é inválida ou não está instalada</value>
  </data>
  <data name="WRN_ObsoleteOverridingNonObsolete" xml:space="preserve">
    <value>O membro obsoleto "{0}" substitui o membro não obsoleto "{1}"</value>
  </data>
  <data name="XML_StringLiteralNoEndQuote" xml:space="preserve">
    <value>Aspa de fechamento ausente para o literal da cadeia de caracteres.</value>
  </data>
  <data name="ERR_CompileCancelled" xml:space="preserve">
    <value>Compilação cancelada pelo usuário</value>
  </data>
  <data name="ERR_MetadataReferencesNotSupported" xml:space="preserve">
    <value>Não há suporte a referências de metadados.</value>
  </data>
  <data name="ERR_ExpectedSelectOrGroup" xml:space="preserve">
    <value>O corpo de uma consulta deve terminar com uma cláusula select ou group</value>
  </data>
  <data name="ERR_DuplicateCaseLabel" xml:space="preserve">
    <value>A instrução switch contém vários casos com o valor de rótulo "{0}"</value>
  </data>
  <data name="ERR_IdentifierExpectedKW" xml:space="preserve">
    <value>Identificador esperado; "{1}" é uma palavra-chave</value>
  </data>
  <data name="ERR_BadCompilationOptionValue" xml:space="preserve">
    <value>Valor "{0}" inválido: "{1}".</value>
  </data>
  <data name="ERR_ExpressionTreeContainsPointerOp" xml:space="preserve">
    <value>Uma árvore de expressão não pode conter uma operação de ponteiro inseguro</value>
  </data>
  <data name="XML_InvalidCharEntity" xml:space="preserve">
    <value>Um caractere inválido foi encontrado dentro de uma referência de entidade.</value>
  </data>
  <data name="ERR_VarArgsInExpressionTree" xml:space="preserve">
    <value>Uma árvore de expressão da expressão lambda não pode conter um método com argumentos variáveis</value>
  </data>
  <data name="WRN_UnimplementedCommandLineSwitch_Title" xml:space="preserve">
    <value>Opção de linha de comando ainda não implementada</value>
  </data>
  <data name="WRN_BitwiseOrSignExtend_Description" xml:space="preserve">
    <value>O compilador ampliou e estendeu a assinatura de uma variável implicitamente, usando posteriormente o valor resultante em uma operação ou bit a bit. Isso pode resultar em um comportamento inesperado.</value>
  </data>
  <data name="ERR_PtrExpected" xml:space="preserve">
    <value>O operador * ou -&gt; deve ser aplicado a um ponteiro</value>
  </data>
  <data name="WRN_DefineIdentifierRequired" xml:space="preserve">
    <value>Nome inválido para um símbolo de pré-processamento. '{0}' não é um identificador válido</value>
  </data>
  <data name="ERR_BadBinaryOps" xml:space="preserve">
    <value>O operador "{0}" não pode ser aplicado a operandos dos tipos "{1}" e "{2}"</value>
  </data>
  <data name="WRN_CLS_IllegalTrueInFalse_Title" xml:space="preserve">
    <value>O tipo não pode ser marcado como em conformidade com CLS por ser membro de um tipo sem conformidade com CLS</value>
  </data>
  <data name="WRN_CallerLineNumberPreferredOverCallerMemberName_Title" xml:space="preserve">
    <value>O CallerMemberNameAttribute não terá nenhum efeito; ele é substituído pelo CallerLineNumberAttribute</value>
  </data>
  <data name="ERR_AbstractHasBody" xml:space="preserve">
    <value>"{0}" não pode declarar um corpo porque não está marcado como abstract</value>
  </data>
  <data name="ERR_BadVisEventType" xml:space="preserve">
    <value>Acessibilidade inconsistente: tipo de evento "{1}" é menos acessível do que o evento "{0}"</value>
  </data>
  <data name="WRN_NonObsoleteOverridingObsolete" xml:space="preserve">
    <value>Membro "{0}" substitui o membro obsoleto "{1}". Adicione o atributo Obsolete a "{0}".</value>
  </data>
  <data name="WRN_UnreachableCode" xml:space="preserve">
    <value>Código inacessível detectado</value>
  </data>
  <data name="WRN_CLS_AssemblyNotCLS2_Title" xml:space="preserve">
    <value>O tipo ou membro não precisa de um atributo CLSCompliant porque o assembly não possui um atributo CLSCompliant</value>
  </data>
  <data name="ERR_QueryNoProviderCastable" xml:space="preserve">
    <value>Não foi possível encontrar uma implementação do padrão de consulta para o tipo de origem "{0}". "{1}" não encontrado. Considere especificar explicitamente o tipo da variável de intervalo "{2}".</value>
  </data>
  <data name="WRN_BadWarningNumber" xml:space="preserve">
    <value>"{0}" não é um número de aviso válido</value>
  </data>
  <data name="ERR_GenericConstraintNotSatisfiedRefType" xml:space="preserve">
    <value>O tipo "{3}" não pode ser usado como parâmetro de tipo "{2}" no tipo ou método genérico "{0}". Não há conversão de referência implícita de "{3}" em "{1}".</value>
  </data>
  <data name="WRN_ExternMethodNoImplementation_Title" xml:space="preserve">
    <value>O método, operador ou assessor está marcado como externo e sem atributos</value>
  </data>
  <data name="ERR_BadDestructorName" xml:space="preserve">
    <value>O nome do destruidor deve corresponder ao nome da classe</value>
  </data>
  <data name="ERR_QueryOutRefRangeVariable" xml:space="preserve">
    <value>Não é possível passar a variável de intervalo "{0}" como um parâmetro out ou ref</value>
  </data>
  <data name="ERR_MustDeclareForeachIteration" xml:space="preserve">
    <value>Um Loop ForEach deve declarar suas variáveis de iteração.</value>
  </data>
  <data name="ERR_DllImportOnInvalidMethod" xml:space="preserve">
    <value>O atributo DllImport deve ser especificado em um método marcado como 'static' e 'extern'</value>
  </data>
  <data name="IDS_FeaturePartialMethod" xml:space="preserve">
    <value>método parcial</value>
  </data>
  <data name="WRN_UnreferencedFieldAssg" xml:space="preserve">
    <value>O campo "{0}" é atribuído, mas seu valor nunca é usado</value>
  </data>
  <data name="ERR_BadYieldInFinally" xml:space="preserve">
    <value>Não é possível usar a instrução yield no corpo de uma cláusula finally</value>
  </data>
  <data name="IDS_Namespace1" xml:space="preserve">
    <value>&lt;namespace&gt;</value>
  </data>
  <data name="ERR_BadAwaitInQuery" xml:space="preserve">
    <value>O operador 'await' só pode ser usado em uma expressão de consulta na primeira expressão de coleção da cláusula 'from' inicial ou na expressão de coleção de uma cláusula 'join'</value>
  </data>
  <data name="WRN_DefaultValueForUnconsumedLocation" xml:space="preserve">
    <value>O valor padrão especificado para o parâmetro "{0}" não terá efeito porque ele se aplica a um membro que é usado em contextos que não permitem argumentos opcionais</value>
  </data>
  <data name="ERR_ExplicitInterfaceImplementationInNonClassOrStruct" xml:space="preserve">
    <value>"{0}": declaração de interface explícita pode somente ser declarada em uma classe ou estrutura</value>
  </data>
  <data name="ERR_GlobalExternAlias" xml:space="preserve">
    <value>Você não pode redefinir o alias externo global</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnParam" xml:space="preserve">
    <value>O atributo CLSCompliant não tem sentido quando aplicado a parâmetros. Tente colocá-lo no método.</value>
  </data>
  <data name="WRN_UnreachableGeneralCatch_Description" xml:space="preserve">
    <value>Este aviso ocorre quando um bloco catch() não tem nenhuma exceção de tipo especificada após um bloco catch (System.Exception e). O aviso indica que o bloco de catch() não capturará exceções.

Um bloco catch() depois de um bloco catch (System.Exception e) poderá capturar exceções não CLS se o RuntimeCompatibilityAttribute estiver definido como false no arquivo AssemblyInfo.cs: [assembly: RuntimeCompatibilityAttribute(WrapNonExceptionThrows = false)]. Se esse atributo não for definido explicitamente como false, todas as exceções geradas não-CLS são encapsuladas como exceções e o bloco catch (System.Exception e) as captura.</value>
  </data>
  <data name="ERR_BadAwaitInCatch" xml:space="preserve">
    <value>Não é possível aguardar em uma cláusula catch</value>
  </data>
  <data name="ERR_CannotDeconstructDynamic" xml:space="preserve">
    <value>Não é possível desconstruir objetos dinâmicos.</value>
  </data>
  <data name="ERR_RefReturnLvalueExpected" xml:space="preserve">
    <value>Uma expressão não pode ser usada nesse contexto pois ela pode não ser retornada por referência</value>
  </data>
  <data name="ERR_OneAliasPerReference" xml:space="preserve">
    <value>Uma opção /reference que declara um alias externo só pode ter um nome de arquivo. Para especificar vários aliases ou nomes de arquivo, use várias opções /reference.</value>
  </data>
  <data name="ERR_UnclosedExpressionHole" xml:space="preserve">
    <value>Delimitador de fechamento ausente '}' para expressão interpolada iniciada com '{'.</value>
  </data>
  <data name="WRN_CLS_NotOnModules" xml:space="preserve">
    <value>Especifique o atributo CLSCompliant no assembly, não no módulo, para habilitar a verificação de conformidade com CLS</value>
  </data>
  <data name="ERR_ForEachMissingMember" xml:space="preserve">
    <value>Instrução foreach não pode operar em variáveis do tipo "{0}" porque "{0}" não contém uma definição pública para "{1}"</value>
  </data>
  <data name="ERR_CantReadRulesetFile" xml:space="preserve">
    <value>Erro ao ler arquivo de conjunto de regras {0} - {1}</value>
  </data>
  <data name="ERR_CallingBaseFinalizeDeprecated" xml:space="preserve">
    <value>Não chame diretamente o método Finalize de classe base. Ele é chamado automaticamente do destruidor.</value>
  </data>
  <data name="ERR_EnumeratorOverflow" xml:space="preserve">
    <value>"{0}": o valor do enumerador é muito grande para se ajustar ao seu tipo</value>
  </data>
  <data name="WRN_FileNameTooLong" xml:space="preserve">
    <value>Nome de arquivo inválido especificado para a diretiva de pré-processamento. O nome de arquivo é muito longo ou não é um nome válido.</value>
  </data>
  <data name="WRN_DeprecatedSymbol_Title" xml:space="preserve">
    <value>O tipo ou membro é obsoleto</value>
  </data>
  <data name="ERR_CantInferMethTypeArgs" xml:space="preserve">
    <value>Os argumentos de tipo do método "{0}" não podem ser inferidos com base no uso. Tente especificar explicitamente os argumentos de tipo.</value>
  </data>
  <data name="IDS_XMLMISSINGINCLUDEFILE" xml:space="preserve">
    <value>Atributo de arquivo ausente</value>
  </data>
  <data name="IDS_XMLMISSINGINCLUDEPATH" xml:space="preserve">
    <value>Atributo de caminho ausente</value>
  </data>
  <data name="ERR_MarshalUnmanagedTypeNotValidForFields" xml:space="preserve">
    <value>Tipo não gerenciado "{0}" não é válido para campos.</value>
  </data>
  <data name="ERR_PublicKeyContainerFailure" xml:space="preserve">
    <value>Erro ao assinar a saída com a chave pública do recipiente "{0}" -- {1}</value>
  </data>
  <data name="ERR_OperatorNeedsMatch" xml:space="preserve">
    <value>O operador "{0}" requer que um operador correspondente "{1}" também seja definido</value>
  </data>
  <data name="ERR_FieldInitRefNonstatic" xml:space="preserve">
    <value>Um inicializador de campo não pode referenciar o campo, o método ou a propriedade não estática "{0}"</value>
  </data>
  <data name="IDS_FeatureReadonlyAutoImplementedProperties" xml:space="preserve">
    <value>propriedades somente leitura implementadas automaticamente</value>
  </data>
  <data name="ERR_RefReadonlyStatic2" xml:space="preserve">
    <value>Os campos do campo somente leitura estático '{0}' não podem ser usados como um valor ref ou out (exceto em um construtor estático)</value>
  </data>
  <data name="IDS_FeaturePropertyAccessorMods" xml:space="preserve">
    <value>modificadores de acesso nas propriedades</value>
  </data>
  <data name="ERR_InvalidMemberDecl" xml:space="preserve">
    <value>Token inválido "{0}" na classe, estrutura ou declaração de membro de interface</value>
  </data>
  <data name="ERR_NoMetadataFile" xml:space="preserve">
    <value>Arquivo de origem "{0}" não pode ser encontrado</value>
  </data>
  <data name="ERR_SizeofUnsafe" xml:space="preserve">
    <value>"{0}" não tem um tamanho pré-definido; portanto, sizeof só pode ser usado em um contexto desprotegido (considere o uso de System.Runtime.InteropServices.Marshal.SizeOf)</value>
  </data>
  <data name="WRN_InvalidSearchPathDir" xml:space="preserve">
    <value>Caminho de pesquisa inválido "{0}" especificado em "{1}" -- "{2}"</value>
  </data>
  <data name="ERR_RefReturnReadonlyLocal2Cause" xml:space="preserve">
    <value>Não é possível retornar campos de '{0}' por referência, porque ele é um '{1}'</value>
  </data>
  <data name="ERR_CantConvAnonMethParams" xml:space="preserve">
    <value>Não é possível converter {0} para tipo delegate "{1}" porque os tipos de parâmetro não correspondem aos tipos de parâmetro delegate</value>
  </data>
  <data name="WRN_CLS_NoAbstractMembers_Title" xml:space="preserve">
    <value>Somente membros em conformidade com CLS podem ser abstratos</value>
  </data>
  <data name="ERR_ConflictingMachineModule" xml:space="preserve">
    <value>Assembly e módulo "{0}" não podem diferentes processadores como destino.</value>
  </data>
  <data name="ERR_BadAwaitInLock" xml:space="preserve">
    <value>Não é possível aguardar no corpo de uma instrução lock</value>
  </data>
  <data name="ERR_RefReadonlyStatic" xml:space="preserve">
    <value>Um campo somente leitura estático não pode ser usado como um valor ref ou out (exceto em um construtor estático)</value>
  </data>
  <data name="ERR_AttributeNotOnAccessor" xml:space="preserve">
    <value>Atributo "{0}" não é válido em acessadores de propriedade ou evento. Ele é válido somente em declarações "{1}".</value>
  </data>
  <data name="WRN_CLS_ArrayArgumentToAttribute" xml:space="preserve">
    <value>Matrizes como argumentos de atributo não tem conformidade com CLS</value>
  </data>
  <data name="HDN_UnusedExternAlias_Title" xml:space="preserve">
    <value>Alias externo não usado</value>
  </data>
  <data name="WRN_InvalidNumber_Title" xml:space="preserve">
    <value>Número inválido</value>
  </data>
  <data name="IDS_FeatureTypeVariance" xml:space="preserve">
    <value>variação de tipo</value>
  </data>
  <data name="IDS_DirectoryDoesNotExist" xml:space="preserve">
    <value>diretório não existe</value>
  </data>
  <data name="ERR_MustHaveOpTF" xml:space="preserve">
    <value>Para que "{0}" seja aplicável como um operador de circuito pequeno, seu tipo declarativo "{1}" deve definir o operador verdadeiro e operador falso</value>
  </data>
  <data name="ERR_ArrayInitializerExpected" xml:space="preserve">
    <value>Esperava-se um inicializador de matriz aninhada</value>
  </data>
  <data name="ERR_OnlyClassesCanContainDestructors" xml:space="preserve">
    <value>Somente tipos de classe podem conter destruidores</value>
  </data>
  <data name="WRN_UnifyReferenceBldRev_Title" xml:space="preserve">
    <value>Presume-se que a referência do assembly coincide com a identidade</value>
  </data>
  <data name="WRN_InvalidAssemblyName" xml:space="preserve">
    <value>Referência do assembly "{0}" é inválida e não pode ser resolvida</value>
  </data>
  <data name="ERR_BadOutWithThis" xml:space="preserve">
    <value> O modificador de parâmetro 'out' não pode ser usado com 'this' </value>
  </data>
  <data name="ERR_DeconstructRequiresExpression" xml:space="preserve">
    <value>Desconstruir uma atribuição requer uma expressão com um tipo no lado direito.</value>
  </data>
  <data name="ERR_InvalidFileAlignment" xml:space="preserve">
    <value>Alinhamento de seção de arquivo inválido '{0}'</value>
  </data>
  <data name="ERR_ThisStructNotInAnonMeth" xml:space="preserve">
    <value>Métodos anônimos, expressões lambda e expressões de consulta dentro de structs não podem acessar membros de instância de 'this'. Copie 'this' para uma variável local fora do método anônimo, da expressão lambda ou da expressão de consulta e use a local em seu lugar.</value>
  </data>
  <data name="ERR_InterfaceImplementedByConditional" xml:space="preserve">
    <value>Membro condicional "{0}" não pode implementar membro de interface "{1}" no tipo "{2}"</value>
  </data>
  <data name="ERR_StaticDerivedFromNonObject" xml:space="preserve">
    <value>Classe static "{0}" não pode derivar do tipo "{1}". Classes static devem derivar do objeto.</value>
  </data>
  <data name="ERR_RefReturnReadonlyStatic2" xml:space="preserve">
    <value>Os campos do campo somente leitura estático '{0}' não podem ser retornados por referência</value>
  </data>
  <data name="ERR_ForwardedTypeInThisAssembly" xml:space="preserve">
    <value>Tipo "{0}" está definido neste assembly, mas um encaminhador de tipo está especificado para ele</value>
  </data>
  <data name="ERR_InsufficientStack" xml:space="preserve">
    <value>Uma expressão é muito longa ou complexa para ser compilada</value>
  </data>
  <data name="WRN_EndOfPPLineExpected_Title" xml:space="preserve">
    <value>Comentário de linha única ou final de linha esperado após a diretiva #pragma</value>
  </data>
  <data name="ERR_EventNeedsBothAccessors" xml:space="preserve">
    <value>"{0}": propriedade de evento deve ter acessadores adicionar e remover</value>
  </data>
  <data name="ERR_SemiOrLBraceOrArrowExpected" xml:space="preserve">
    <value>{ ou ; ou =&gt; esperado</value>
  </data>
  <data name="WRN_ConflictingMachineAssembly_Title" xml:space="preserve">
    <value>O assembly referenciado está direcionado a um processador diferente</value>
  </data>
  <data name="ERR_MissingCoClass" xml:space="preserve">
    <value>A classe coclass wrapper gerenciada "{0}" para a interface "{1}" não pode ser encontrada (está faltando uma referência de assembly?)</value>
  </data>
  <data name="WRN_PatternIsAmbiguous" xml:space="preserve">
    <value>"{0}" não implementa o padrão "{1}". "{2}" é ambíguo com "{3}".</value>
  </data>
  <data name="ERR_BadCompatMode" xml:space="preserve">
    <value>Opção '{0}' inválida para /langversion; deve ser ISO-1, ISO-2, Padrão, Mais Recente ou uma versão válida no intervalo de 1 a 7.1.</value>
  </data>
  <data name="ERR_AliasQualifiedNameNotAnExpression" xml:space="preserve">
    <value>Um nome qualificado para alias não é uma expressão.</value>
  </data>
  <data name="XML_ExpectedIdentifier" xml:space="preserve">
    <value>Um identificador era esperado.</value>
  </data>
  <data name="WRN_GotoCaseShouldConvert" xml:space="preserve">
    <value>O valor "goto case" não é implicitamente conversível para o tipo "{0}"</value>
  </data>
  <data name="WRN_IncorrectBooleanAssg_Title" xml:space="preserve">
    <value>A atribuição em expressão condicional é sempre constante</value>
  </data>
  <data name="ERR_ConditionalWithOutParam" xml:space="preserve">
    <value>Membro condicional "{0}" não pode ter um parâmetro out</value>
  </data>
  <data name="ERR_AwaitInUnsafeContext" xml:space="preserve">
    <value>Não é possível esperar em um contexto sem segurança</value>
  </data>
  <data name="ERR_BadEmbeddedStmt" xml:space="preserve">
    <value>A instrução inserida não pode ser uma declaração ou uma instrução rotulada</value>
  </data>
  <data name="WRN_ExternCtorNoImplementation_Title" xml:space="preserve">
    <value>O construtor está marcado como externo</value>
  </data>
  <data name="IDS_FeatureCollectionInitializer" xml:space="preserve">
    <value>inicializador de coleção</value>
  </data>
  <data name="ERR_PredefinedTypeNotFound" xml:space="preserve">
    <value>O tipo pré-definido "{0}" não foi definido ou importado</value>
  </data>
  <data name="IDS_FeatureAutoImplementedProperties" xml:space="preserve">
    <value>propriedades implementadas automaticamente</value>
  </data>
  <data name="WRN_DynamicDispatchToConditionalMethod" xml:space="preserve">
    <value>A chamada dinamicamente despachada para o método "{0}" pode falhar em tempo de execução porque um ou mais sobrecargas aplicáveis são métodos condicionais.</value>
  </data>
  <data name="WRN_DeprecatedSymbolStr_Title" xml:space="preserve">
    <value>O tipo ou membro é obsoleto</value>
  </data>
  <data name="WRN_ExternCtorNoImplementation" xml:space="preserve">
    <value>Construtor "{0}" está marcado como externo</value>
  </data>
  <data name="ERR_StaticClassInterfaceImpl" xml:space="preserve">
    <value>"{0}": classes static não podem implementar interfaces</value>
  </data>
  <data name="ERR_InteropStructContainsMethods" xml:space="preserve">
    <value>Estrutura de interoperabilidade inserida "{0}" pode conter apenas campos de instância pública.</value>
  </data>
  <data name="ERR_DerivingFromATyVar" xml:space="preserve">
    <value>Não é possível derivar de "{0}" porque ele é um parâmetro de tipo</value>
  </data>
  <data name="ERR_BadFixedInitType" xml:space="preserve">
    <value>O tipo de um local declarado em uma instrução fixed deve ser um tipo de ponteiro</value>
  </data>
  <data name="IDS_FeatureExternAlias" xml:space="preserve">
    <value>alias externo</value>
  </data>
  <data name="WRN_BadXMLRefReturnType_Title" xml:space="preserve">
    <value>Tipo de retorno inválido no atributo cref do comentário XML</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnParam_Title" xml:space="preserve">
    <value>O atributo CLSCompliant não tem sentido quando aplicado a parâmetros</value>
  </data>
  <data name="ERR_TypelessTupleInAs" xml:space="preserve">
    <value>O primeiro operando de um operador 'as' não pode ser uma literal de tupla sem nenhum tipo natural.</value>
  </data>
  <data name="ERR_InvalidInstrumentationKind" xml:space="preserve">
    <value>Variante de instrumentação inválida: {0}</value>
  </data>
  <data name="ERR_NamespaceNotAllowedInScript" xml:space="preserve">
    <value>Você não pode declarar o namespace no código de script</value>
  </data>
  <data name="WRN_CLS_BadFieldPropType_Description" xml:space="preserve">
    <value>Uma variável pública, protegida ou protegida internamente deve ser de um tipo em conformidade com a Common Language Specification (CLS).</value>
  </data>
  <data name="ERR_PartialModifierConflict" xml:space="preserve">
    <value>Declarações parciais de "{0}" têm modificadores de acessibilidade conflitantes</value>
  </data>
  <data name="ERR_GenericConstraintNotSatisfiedNullableEnum" xml:space="preserve">
    <value>O tipo "{3}" não pode ser usado como parâmetro de tipo "{2}" no tipo ou método genérico "{0}". O tipo "{3}" que permite valores nulos não satisfaz a restrição de "{1}".</value>
  </data>
  <data name="WRN_BadRefCompareRight_Title" xml:space="preserve">
    <value>Possível comparação de referência inesperada; o lado direito precisa de conversão</value>
  </data>
  <data name="ERR_OutputWriteFailed" xml:space="preserve">
    <value>Não foi possível gravar no arquivo de saída "{0}" -- "{1}"</value>
  </data>
  <data name="ERR_ThisOrBaseExpected" xml:space="preserve">
    <value>Palavra-chave 'this' ou 'base' esperada</value>
  </data>
  <data name="WRN_NubExprIsConstBool2_Title" xml:space="preserve">
    <value>O resultado da expressão é sempre o mesmo, pois um valor deste tipo nunca é 'null' </value>
  </data>
  <data name="ERR_YieldNotAllowedInScript" xml:space="preserve">
    <value>Não é possível usar 'yield' no código de script de nível superior</value>
  </data>
  <data name="WRN_AsyncLacksAwaits_Title" xml:space="preserve">
    <value>O método assíncrono não possui operadores 'await' e será executado de forma síncrona</value>
  </data>
  <data name="WRN_MultiplePredefTypes_Title" xml:space="preserve">
    <value>O tipo predefinido está definido em vários assemblies no alias global</value>
  </data>
  <data name="ERR_AttrArgWithTypeVars" xml:space="preserve">
    <value>"{0}": um argumento de atributo não pode usar parâmetros de tipo</value>
  </data>
  <data name="ERR_OvlOperatorExpected" xml:space="preserve">
    <value>Operador que pode ser sobrecarregado é esperado</value>
  </data>
  <data name="ERR_AssgReadonlyStatic2" xml:space="preserve">
    <value>Campos do campo estático somente leitura "{0}" não podem ser atribuídos (exceto em um construtor estático ou inicializador de variável)</value>
  </data>
  <data name="WRN_NoSources" xml:space="preserve">
    <value>Nenhum arquivo de origem especificado.</value>
  </data>
  <data name="WRN_InvalidMainSig" xml:space="preserve">
    <value>"{0}" tem a assinatura incorreta para ser um ponto de entrada</value>
  </data>
  <data name="ERR_TooManyCatches" xml:space="preserve">
    <value>As cláusulas catch não podem seguir a cláusula catch geral de uma instrução try</value>
  </data>
  <data name="ERR_MissingArgument" xml:space="preserve">
    <value>Argumento ausente</value>
  </data>
  <data name="ERR_ExpressionTreeMustHaveDelegate" xml:space="preserve">
    <value>Não é possível converter lambda em uma árvore de expressões cujo argumento de tipo "{0}" não é um tipo delegado</value>
  </data>
  <data name="ERR_VoidError" xml:space="preserve">
    <value>A operação em questão não está definida nos ponteiros void</value>
  </data>
  <data name="ERR_InvalidDelegateType" xml:space="preserve">
    <value>Delegado "{0}" não tem método invoke ou um método invoke com um tipo de retorno ou tipos de parâmetros que não são suportados.</value>
  </data>
  <data name="IDS_FeatureNameof" xml:space="preserve">
    <value>nome do operador</value>
  </data>
  <data name="ERR_ManagedAddr" xml:space="preserve">
    <value>Não é possível obter o endereço, obter o tamanho ou declarar um ponteiro para um tipo gerenciado ("{0}")</value>
  </data>
  <data name="WRN_NonECMAFeature" xml:space="preserve">
    <value>Recurso "{0}" não é parte da especificação de idioma ISO C# padronizada e não pode ser aceito por outros compiladores</value>
  </data>
  <data name="ERR_CmdOptionConflictsSource" xml:space="preserve">
    <value>Atributo "{0}" fornecido em um arquivo de origem com a opção "{1}".</value>
  </data>
  <data name="WRN_CLS_NotOnModules2_Title" xml:space="preserve">
    <value>Você não pode especificar o atributo CLSCompliant em um módulo diferente do atributo CLSCompliant no assembly</value>
  </data>
  <data name="ERR_BadParamExtraRef" xml:space="preserve">
    <value>Parâmetro {0} não deve ser declarado com a palavra-chave "{1}"</value>
  </data>
  <data name="ERR_BadAwaitInFinally" xml:space="preserve">
    <value>Não é possível esperar no corpo de uma cláusula finally</value>
  </data>
  <data name="ERR_ClassTypeExpected" xml:space="preserve">
    <value>Um objeto, cadeia de caracteres ou tipo de classe esperado</value>
  </data>
  <data name="ERR_LinkedNetmoduleMetadataMustProvideFullPEImage" xml:space="preserve">
    <value>Metadados netmodule vinculados devem fornecer uma imagem completa de PE: "{0}".</value>
  </data>
  <data name="WRN_GlobalAliasDefn_Title" xml:space="preserve">
    <value>Não é recomendável definir um alias denominado 'global'</value>
  </data>
  <data name="ERR_ExpressionVariableInConstructorOrFieldInitializer" xml:space="preserve">
    <value>As declarações de variável out ou padrão não são permitidas em inicializadores de construtor, inicializadores de campo ou inicializadores de propriedade.</value>
  </data>
  <data name="ERR_BadPrefer32OnLib" xml:space="preserve">
    <value>/platform:anycpu32bitpreferred pode apenas ser usado com /t:exe, /t:winexe e /t:appcontainerexe</value>
  </data>
  <data name="ERR_ComImportWithBase" xml:space="preserve">
    <value>"{0}": uma classe com o atributo ComImport não pode especificar uma classe básica</value>
  </data>
  <data name="ERR_ComImportWithImpl" xml:space="preserve">
    <value>Como "{1}" tem o atributo ComImport, "{0}" deve ser extern ou abstract</value>
  </data>
  <data name="IDS_FIXEDLOCAL" xml:space="preserve">
    <value>variável fixed</value>
  </data>
  <data name="NameConflictForName" xml:space="preserve">
    <value>Conflito de nome para o nome {0}</value>
  </data>
  <data name="ERR_UnreachableCatch" xml:space="preserve">
    <value>Cláusula catch anterior já captura todas as exceções desta ou de um super tipo ("{0}")</value>
  </data>
  <data name="ERR_UseDefViolationField" xml:space="preserve">
    <value>Uso de campo possivelmente não atribuído "{0}"</value>
  </data>
  <data name="ERR_BlockBodyAndExpressionBody" xml:space="preserve">
    <value>Corpos de bloco e de expressão não podem ser ambos fornecidos.</value>
  </data>
  <data name="ERR_SystemVoid" xml:space="preserve">
    <value>System.Void não pode ser usado no C# -- use typeof(void) para obter o objeto de tipo void</value>
  </data>
  <data name="ERR_BadDocumentationMode" xml:space="preserve">
    <value>O modo de documentação fornecido não tem suporte ou é inválido: '{0}'.</value>
  </data>
  <data name="ERR_AmbigUnaryOp" xml:space="preserve">
    <value>O operador "{0}" é ambíguo em um operando do tipo "{1}"</value>
  </data>
  <data name="WRN_TupleLiteralNameMismatch_Title" xml:space="preserve">
    <value>O nome do elemento de tupla é ignorado porque um nome diferente ou nenhum nome foi especificado pelo destino de atribuição.</value>
  </data>
  <data name="WRN_ReferencedAssemblyDoesNotHaveStrongName_Title" xml:space="preserve">
    <value>Assembly referenciado sem um nome forte</value>
  </data>
  <data name="ERR_PartialMethodNotExplicit" xml:space="preserve">
    <value>Um método parcial não pode implementar explicitamente um método de interface</value>
  </data>
  <data name="IDS_FeatureLambda" xml:space="preserve">
    <value>expressão lambda</value>
  </data>
  <data name="ERR_MainClassIsImport" xml:space="preserve">
    <value>Não é possível usar "{0}" para o método Main porque ele é importado</value>
  </data>
  <data name="ERR_BadUnaryOperatorSignature" xml:space="preserve">
    <value>O parâmetro de um operador unário deve ser do tipo recipiente</value>
  </data>
  <data name="ERR_StructsCantContainDefaultConstructor" xml:space="preserve">
    <value>Structs não podem conter construtores explícitos sem parâmetro</value>
  </data>
  <data name="WRN_DeprecatedCollectionInitAddStr" xml:space="preserve">
    <value>O melhor método Adicionar sobrecarregado "{0}" para o elemento do inicializador de coleção está obsoleto. {1}</value>
  </data>
  <data name="ERR_ConstantStringTooLong" xml:space="preserve">
    <value>O comprimento da constante de cadeia de caracteres excede o limite de memória atual.  Tente dividir a cadeia de caracteres em várias constantes.</value>
  </data>
  <data name="ERR_UnassignedThis" xml:space="preserve">
    <value>Campo "{0}" deve ser totalmente atribuído antes que o controle seja retornado ao chamador</value>
  </data>
  <data name="WRN_CLS_NotOnModules_Title" xml:space="preserve">
    <value>Especifique o atributo CLSCompliant no assembly, não no módulo, para habilitar a verificação de conformidade com CLS</value>
  </data>
  <data name="WRN_ReferencedAssemblyDoesNotHaveStrongName" xml:space="preserve">
    <value>Assembly referenciado "{0}" não tem um nome forte.</value>
  </data>
  <data name="IDS_SK_NAMESPACE" xml:space="preserve">
    <value>namespace</value>
  </data>
  <data name="ERR_AmbigCall" xml:space="preserve">
    <value>A chamada é ambígua entre os seguintes métodos ou propriedades: "{0}" e "{1}"</value>
  </data>
  <data name="ERR_FloatOverflow" xml:space="preserve">
    <value>Constante de ponto flutuante está fora do intervalo do tipo "{0}"</value>
  </data>
  <data name="ERR_EncodinglessSyntaxTree" xml:space="preserve">
    <value>Não é possível emitir informações de depuração para um texto de origem sem codificação.</value>
  </data>
  <data name="ERR_BadResourceVis" xml:space="preserve">
    <value>Opção inválida "{0}"; Visibilidade de recursos deve ser "public" ou "private"</value>
  </data>
  <data name="WRN_BadRestoreNumber_Title" xml:space="preserve">
    <value>Não é possível restaurar o aviso porque ele foi desabilitado globalmente</value>
  </data>
  <data name="ERR_VarargsIterator" xml:space="preserve">
    <value>__arglist não é permitido na lista de parâmetros dos iteradores</value>
  </data>
  <data name="ERR_CantConvAsyncAnonFuncReturns" xml:space="preserve">
    <value>Não é possível converter async {0} para tipo delegate "{1}". Um async {0} podem retornar void, Task ou Task&lt;T&gt;, nenhum dos quais são conversíveis para "{1}".</value>
  </data>
  <data name="XML_DuplicateAttribute" xml:space="preserve">
    <value>Duplicar atributo "{0}"</value>
  </data>
  <data name="XML_EndTagExpected" xml:space="preserve">
    <value>Espera-se uma marca de fim para o elemento "{0}".</value>
  </data>
  <data name="ERR_UnexpectedBoundGenericName" xml:space="preserve">
    <value>Os argumentos de tipo não são permitidos no nome do operador.</value>
  </data>
  <data name="ERR_DottedTypeNameNotFoundInNS" xml:space="preserve">
    <value>O nome de tipo ou namespace "{0}" não existe no namespace "{1}" (você está sem uma referência de assembly?)</value>
  </data>
  <data name="ERR_NewTyvarWithArgs" xml:space="preserve">
    <value>"{0}": não é possível fornecer argumentos ao criar uma instância de um tipo de variável</value>
  </data>
  <data name="ERR_BadWin32Res" xml:space="preserve">
    <value>Erro ao ler recursos do Win32 -- {0}</value>
  </data>
  <data name="ERR_GlobalSingleTypeNameNotFoundFwd" xml:space="preserve">
    <value>O nome do tipo "{0}" não pode ser encontrado no namespace global. Este tipo foi encaminhado para o assembly "{1}" Considere adicionar uma referência a esse assembly.</value>
  </data>
  <data name="ERR_CantReturnVoid" xml:space="preserve">
    <value>Não é possível retornar uma expressão do tipo 'void'</value>
  </data>
  <data name="ERR_RefOutDefaultValue" xml:space="preserve">
    <value>Um parâmetro ref ou out não pode ter um valor padrão</value>
  </data>
  <data name="ERR_SingleTypeNameNotFoundFwd" xml:space="preserve">
    <value>O nome do tipo "{0}" não pode ser encontrado. Esse tipo foi encaminhado para o assembly "{1}". Considere adicionar uma referência a esse assembly.</value>
  </data>
  <data name="ERR_BadIteratorLocalType" xml:space="preserve">
    <value>Os iteradores não podem ter locais por referência</value>
  </data>
  <data name="ERR_DefaultValueForExtensionParameter" xml:space="preserve">
    <value>Não é possível especificar um valor padrão para o parâmetro 'this'</value>
  </data>
  <data name="WRN_IsAlwaysFalse" xml:space="preserve">
    <value>A expressão fornecida nunca é do ("{0}") tipo fornecido</value>
  </data>
  <data name="WRN_UnmatchedTypeParamTag_Title" xml:space="preserve">
    <value>O comentário XML tem uma marca typeparam, mas não há nenhum parâmetro com esse nome</value>
  </data>
  <data name="ERR_PartialMethodUnsafeDifference" xml:space="preserve">
    <value>As duas declarações de métodos parciais devem ser inseguras ou nenhuma delas deve ser desse tipo</value>
  </data>
  <data name="ERR_StaticInAsOrIs" xml:space="preserve">
    <value>O segundo operando de um operador "is" ou "as" não pode ser do tipo estático "{0}"</value>
  </data>
  <data name="WRN_CLS_BadBase_Description" xml:space="preserve">
    <value>Um tipo base foi marcado como sem necessidade de estar em conformidade com a Common Language Specification (CLS) em um assembly que foi marcado como em conformidade com CLS. Remova o atributo que especifica que o assembly está em conformidade com CLS ou aquele que indica que o tipo não tem conformidade com CLS.</value>
  </data>
  <data name="ERR_BadVarargs" xml:space="preserve">
    <value>Um método com vararg não pode ser genérico, estar em um tipo genérico ou ter um parâmetro params</value>
  </data>
  <data name="ERR_BadAwaitArg_NeedSystem" xml:space="preserve">
    <value>"await" requer que o tipo "{0}" tenha um método GetAwaiter adequado. Está faltando uma diretiva using para "System"?</value>
  </data>
  <data name="ERR_BadVarDecl" xml:space="preserve">
    <value>; ou = esperado. (Não é possível especificar argumentos de construtor na declaração)</value>
  </data>
  <data name="ERR_OpTFRetType" xml:space="preserve">
    <value>O tipo de retorno do operador True ou False deve ser bool</value>
  </data>
  <data name="ERR_SpecialTypeAsBound" xml:space="preserve">
    <value>Restrição não pode ser classe especial "{0}"</value>
  </data>
  <data name="ERR_ForwardedTypesConflict" xml:space="preserve">
    <value>Tipo "{0}" encaminhado para o assembly "{1}" está em conflito com tipo "{2}" encaminhado para o módulo "{3}".</value>
  </data>
  <data name="ERR_DefaultValueNotAllowed" xml:space="preserve">
    <value>Valores padrão não são válidos neste contexto.</value>
  </data>
  <data name="ERR_BadNamedArgumentForDelegateInvoke" xml:space="preserve">
    <value>O representante "{0}" não tem um parâmetro chamado "{1}"</value>
  </data>
  <data name="WRN_CLS_BadInterface" xml:space="preserve">
    <value>"{0}" não tem conformidade com CLS porque a interface base "{1}" não tem conformidade com CLS</value>
  </data>
  <data name="ERR_MissingMethodOnSourceInterface" xml:space="preserve">
    <value>Interface de origem "{0}" está sem o método "{1}" que é necessário para incorporar o evento "{2}".</value>
  </data>
  <data name="ERR_BadAttributeParamDefaultArgument" xml:space="preserve">
    <value>Parâmetro de construtor de atributo "{0}" é opcional, mas nenhum valor de parâmetro padrão foi especificado.</value>
  </data>
  <data name="ERR_NullPropagatingOpInExpressionTree" xml:space="preserve">
    <value>Uma árvore de expressão da expressão lambda não pode conter um operador nulo em propagação.</value>
  </data>
  <data name="ERR_AliasNotFound" xml:space="preserve">
    <value>Alias "{0}" não encontrado</value>
  </data>
  <data name="ERR_MemberAlreadyInitialized" xml:space="preserve">
    <value>Duplicar inicialização do membro "{0}"</value>
  </data>
  <data name="ERR_BadDebugType" xml:space="preserve">
    <value>Opção '{0}' inválida para /debug; deve ser 'portable', 'embedded', 'full' ou 'pdbonly'</value>
  </data>
  <data name="ERR_FixedNeeded" xml:space="preserve">
    <value>Só é possível obter o endereço de uma expressão unfixed dentro de um inicializador de instrução fixed</value>
  </data>
  <data name="ERR_ComImportWithInitializers" xml:space="preserve">
    <value>"{0}": uma classe com o atributo ComImport não pode especificar inicializadores de campo.</value>
  </data>
  <data name="ERR_IndexerInStaticClass" xml:space="preserve">
    <value>"{0}": não pode declarar indexadores em uma classe estática</value>
  </data>
  <data name="ERR_DuplicateInterfaceInBaseList" xml:space="preserve">
    <value>"{0}" já está listado na lista de interfaces</value>
  </data>
  <data name="ERR_UseDefViolationThis" xml:space="preserve">
    <value>O objeto 'this' não pode ser usado antes que todos os seus campos sejam atribuídos a</value>
  </data>
  <data name="ERR_PropertyWithNoAccessors" xml:space="preserve">
    <value>"{0}": propriedade ou indexador deve ter no mínimo um acessador</value>
  </data>
  <data name="ERR_ImplicitlyTypedVariableCannotBeConst" xml:space="preserve">
    <value>Variáveis de tipo implícito não podem ser constantes</value>
  </data>
  <data name="WRN_NewRequired_Description" xml:space="preserve">
    <value>Uma variável foi declarada com o mesmo nome de uma variável na classe base. No entanto, a nova palavra-chave não foi usada. Este aviso informa que você deve usar um novo; a variável é declarada como se novo tivesse sido usada na declaração.</value>
  </data>
  <data name="ERR_BadVisReturnType" xml:space="preserve">
    <value>Acessibilidade inconsistente: tipo de retorno "{1}" é menos acessível do que o método "{0}"</value>
  </data>
  <data name="UseLiteralForTokens" xml:space="preserve">
    <value>Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal para criar tokens literais de caracteres.</value>
  </data>
  <data name="WRN_CLS_ArrayArgumentToAttribute_Title" xml:space="preserve">
    <value>Matrizes como argumentos de atributo não tem conformidade com CLS</value>
  </data>
  <data name="WRN_AlignmentMagnitude" xml:space="preserve">
    <value>O valor do alinhamento {0} possui uma magnitude maior que {1}, podendo resultar em uma grande cadeia de caracteres formatada.</value>
  </data>
  <data name="IDS_FeatureOutVar" xml:space="preserve">
    <value>declaração de variável externa</value>
  </data>
  <data name="WRN_VacuousIntegralComp" xml:space="preserve">
    <value>Comparação com constante integral é inútil; a constante está fora do intervalo do tipo "{0}"</value>
  </data>
  <data name="IDS_VersionExperimental" xml:space="preserve">
    <value>'experimental'</value>
  </data>
  <data name="ERR_GenericsUsedAcrossAssemblies" xml:space="preserve">
    <value>O tipo "{0}" do assembly '{1}' não pode ser usado em limites de assembly porque ele tem um argumento de tipo genérico que é um tipo de interoperabilidade inserido.</value>
  </data>
  <data name="ERR_AsMustHaveReferenceType" xml:space="preserve">
    <value>O operador as deve ser usado com um tipo de referência ou tipo anulável ("{0}" é um tipo de valor não-anulável)</value>
  </data>
  <data name="ERR_AbstractNotVirtual" xml:space="preserve">
    <value>O método abstract "{0}" não pode ser marcado como virtual</value>
  </data>
  <data name="ERR_OperatorInStaticClass" xml:space="preserve">
    <value>"{0}": classes static não podem conter operadores definidos pelo usuário</value>
  </data>
  <data name="ERR_LabelShadow" xml:space="preserve">
    <value>O rótulo "{0}" é sombra de outro rótulo com o mesmo nome em um escopo contido</value>
  </data>
  <data name="WRN_MultipleRuntimeOverrideMatches" xml:space="preserve">
    <value>Membro "{1}" substitui "{0}". Há vários candidatos de substituição em tempo de execução. Ele é dependente de implementação cujo método que será chamado.</value>
  </data>
  <data name="ERR_GetOrSetExpected" xml:space="preserve">
    <value>Acessador get ou set esperado</value>
  </data>
  <data name="ERR_ExplicitParamArray" xml:space="preserve">
    <value>Não use 'System.ParamArrayAttribute'. Use a palavra-chave 'params'.</value>
  </data>
  <data name="WRN_ProtectedInSealed_Title" xml:space="preserve">
    <value>Novo membro protegido declarado na classe bloqueada</value>
  </data>
  <data name="ERR_ForwardedTypeConflictsWithDeclaration" xml:space="preserve">
    <value>Tipo encaminhado "{0}" está em conflito com o tipo declarado no módulo primário deste assembly.</value>
  </data>
  <data name="WRN_UnifyReferenceBldRev_Description" xml:space="preserve">
    <value>Dois assemblies diferem no número de versão. Para que a união ocorra, você deve especificar as diretivas no arquivo .config do aplicativo e fornecer o nome forte correto de um assembly.</value>
  </data>
  <data name="ERR_IndirectRecursiveConstructorCall" xml:space="preserve">
    <value>O construtor '{0}' não pode chamar a si mesmo por meio de outro construtor</value>
  </data>
  <data name="ERR_ImportNonAssembly" xml:space="preserve">
    <value>O arquivo referenciado "{0}" não é um assembly</value>
  </data>
  <data name="ERR_BadBinOpArgs" xml:space="preserve">
    <value>Operador binário sobrecarregado "{0}" obtém dois parâmetros</value>
  </data>
  <data name="ERR_ConditionalOnOverride" xml:space="preserve">
    <value>O atributo Conditional não é válido em "{0}" porque é um método override</value>
  </data>
  <data name="ERR_LocalCantBeFixedAndHoisted" xml:space="preserve">
    <value>Local "{0}" ou seus membros não podem ter seu endereço obtido nem serem usados dentro de uma método anônimo ou expressão lambda</value>
  </data>
  <data name="NoNoneSearchCriteria" xml:space="preserve">
    <value>SearchCriteria é esperado.</value>
  </data>
  <data name="ERR_InterfacesCantContainConstructors" xml:space="preserve">
    <value>Interfaces não podem conter construtores</value>
  </data>
  <data name="ERR_RetNoObjectRequired" xml:space="preserve">
    <value>Como "{0}" retorna void, uma palavra-chave return não deve ser seguida por uma expressão de objeto</value>
  </data>
  <data name="ERR_IdentityConversion" xml:space="preserve">
    <value>O operador definido pelo usuário não pode obter um objeto do tipo delimitador e se converter em um objeto do tipo delimitador</value>
  </data>
  <data name="ERR_EncNoPIAReference" xml:space="preserve">
    <value>Não é possível continuar pois a edição inclui uma referência a um tipo incorporado: '{0}'.</value>
  </data>
  <data name="WRN_UnobservedAwaitableExpression" xml:space="preserve">
    <value>Como esta chamada não é aguardada, a execução do método atual continua antes da conclusão da chamada. Considere aplicar o operador 'await' ao resultado da chamada.</value>
  </data>
  <data name="WRN_PatternStaticOrInaccessible" xml:space="preserve">
    <value>"{0}" não implementa o padrão "{1}". "{2}" é estático ou não público.</value>
  </data>
  <data name="WRN_CA2000_DisposeObjectsBeforeLosingScope1" xml:space="preserve">
    <value>Chamar System.IDisposable.Dispose() na instância alocada de {0} antes que todas as referências a ele fiquem fora do escopo.</value>
  </data>
  <data name="WRN_CA2000_DisposeObjectsBeforeLosingScope2" xml:space="preserve">
    <value>Instância alocada de {0} não é descartada ao longo de todos os caminhos de exceção. Chamar System.IDisposable.Dispose() antes que todas as referências a ela estejam fora do escopo.</value>
  </data>
  <data name="SpeculatedSyntaxNodeCannotBelongToCurrentCompilation" xml:space="preserve">
    <value>Nó de sintaxe a ser especulado não pode pertencer a uma árvore de sintaxe da compilação atual.</value>
  </data>
  <data name="ERR_SecurityAttributeInvalidAction" xml:space="preserve">
    <value>Atributo de segurança "{0}" tem um valor SecurityAction inválido "{1}"</value>
  </data>
  <data name="ERR_PossibleBadNegCast" xml:space="preserve">
    <value>Para converter um valor negativo, é necessário delimitá-lo com parêntesis.</value>
  </data>
  <data name="WRN_PdbLocalNameTooLong" xml:space="preserve">
    <value>Nome local "{0}" é muito longo para PDB. Considere reduzir ou compilar sem /debug.</value>
  </data>
  <data name="ERR_GlobalDefinitionOrStatementExpected" xml:space="preserve">
    <value>Definição de membro, instrução ou final do arquivo esperado</value>
  </data>
  <data name="WRN_UnobservedAwaitableExpression_Title" xml:space="preserve">
    <value>Como esta chamada não é esperada, a execução do método atual continua antes de a chamada ser concluída</value>
  </data>
  <data name="ERR_UsingAfterElements" xml:space="preserve">
    <value>Uma cláusula using deve preceder todos os outros elementos definidos no namespace, exceto as declarações de alias externas</value>
  </data>
  <data name="ERR_BadAwaitWithoutAsyncMethod" xml:space="preserve">
    <value>O operador "await" pode somente ser usado em um método assíncrono. Considere a possibilidade de marcar este método com o modificador "async" e alterar seu tipo de retorno para "Task&lt;{0}&gt;".</value>
  </data>
  <data name="ERR_FixedBufferTooManyDimensions" xml:space="preserve">
    <value>Um buffer fixo pode ter somente uma dimensão.</value>
  </data>
  <data name="WRN_NubExprIsConstBool" xml:space="preserve">
    <value>O resultado da expressão é sempre '{0}', pois um valor do tipo '{1}' nunca é igual a "null" do tipo '{2}'</value>
  </data>
  <data name="IDS_SK_VARIABLE" xml:space="preserve">
    <value>variável</value>
  </data>
  <data name="ERR_ColColWithTypeAlias" xml:space="preserve">
    <value>Não é possível usar o alias "{0}" com "::" porque o alias faz referência a um tipo. Ao invés disso, use ".".</value>
  </data>
  <data name="ERR_Merge_conflict_marker_encountered" xml:space="preserve">
    <value>Marcador de conflito de mesclagem encontrado</value>
  </data>
  <data name="ERR_FriendAssemblyBadArgs" xml:space="preserve">
    <value>Referência do assembly Friend "{0}" é inválido. Declarações InternalsVisibleTo não podem ter uma versão, cultura, token de chave pública ou arquitetura de processador especificada.</value>
  </data>
  <data name="ERR_EmptyCharConst" xml:space="preserve">
    <value>Literal de caractere vazio</value>
  </data>
  <data name="ERR_AddModuleAssembly" xml:space="preserve">
    <value>"{0}" não pode ser adicionado a este assembly porque já é um assembly</value>
  </data>
  <data name="ERR_PublicSignNetModule" xml:space="preserve">
    <value>Não há suporte para autenticação pública dos netmodules.</value>
  </data>
  <data name="ERR_FieldCantBeRefAny" xml:space="preserve">
    <value>Campo ou propriedade não pode ser do tipo "{0}"</value>
  </data>
  <data name="ERR_TupleElementNamesInDeconstruction" xml:space="preserve">
    <value>Os nomes de elemento de tupla não são permitidos à esquerda de uma desconstrução.</value>
  </data>
  <data name="ERR_MemGroupInExpressionTree" xml:space="preserve">
    <value>Uma árvore de expressão da expressão lambda não pode conter um grupo de métodos</value>
  </data>
  <data name="ERR_DelegateOnNullable" xml:space="preserve">
    <value>Não é possível associar o representante a "{0}" porque ele é membro de "System.Nullable&lt;T&gt;"</value>
  </data>
  <data name="IDS_SK_METHOD" xml:space="preserve">
    <value>método</value>
  </data>
  <data name="ERR_PartialWrongTypeParams" xml:space="preserve">
    <value>Declarações parciais de "{0}" devem ter os mesmos nomes de parâmetro de tipo na mesma ordem</value>
  </data>
  <data name="XML_InvalidToken" xml:space="preserve">
    <value>O(s) caractere(s) "{0}" não pode(m) ser usado(s) neste local.</value>
  </data>
  <data name="ERR_BadAwaitWithoutAsyncLambda" xml:space="preserve">
    <value>O operador "await" pode somente ser usado em async {0}. Considere a possibilidade de marcar este {0} com o modificador "async".</value>
  </data>
  <data name="ChainingSpeculativeModelIsNotSupported" xml:space="preserve">
    <value>Não há suporte ao encadeamento do modelo semântico especulativo. Você deve criar um modelo especulativo com base no ParentModel não especulativo.</value>
  </data>
  <data name="ERR_MultipleEntryPoints" xml:space="preserve">
    <value>Programa tem mais de um ponto de entrada definido. Compilar com /main para especificar o tipo que contém o ponto de entrada.</value>
  </data>
  <data name="WRN_FilterIsConstant" xml:space="preserve">
    <value>Expressão de filtro é uma constante, considere remover o filtro</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion7_1" xml:space="preserve">
    <value>O recurso '{0}' não está disponível em C# 7.1. Use a versão de linguagem {1} ou superior.</value>
  </data>
  <data name="WRN_FailedInclude" xml:space="preserve">
    <value>Não é possível incluir fragmento XML "{1}" do arquivo "{0}" -- {2}</value>
  </data>
  <data name="ERR_ExportedTypesConflict" xml:space="preserve">
    <value>Tipo "{0}" exportado do módulo "{1}" está em conflito com tipo "{2}" exportado do módulo "{3}".</value>
  </data>
  <data name="WRN_MainCantBeGeneric_Title" xml:space="preserve">
    <value>Um ponto de entrada não pode ser genérico ou estar em um tipo genérico</value>
  </data>
  <data name="ERR_NoMainInClass" xml:space="preserve">
    <value>"{0}" não tem um método Main estático adequado</value>
  </data>
  <data name="WRN_DebugFullNameTooLong" xml:space="preserve">
    <value>O nome totalmente qualificado para "{0}" é muito longo para informações de depuração. Compile sem a opção "/debug".</value>
  </data>
  <data name="ERR_DefaultValueBeforeRequiredValue" xml:space="preserve">
    <value>Os parâmetros opcionais devem aparecer após todos os parâmetros necessários</value>
  </data>
  <data name="WRN_ErrorOverride_Title" xml:space="preserve">
    <value>O aviso está substituindo um erro</value>
  </data>
  <data name="WRN_UnreferencedLabel_Title" xml:space="preserve">
    <value>Este rótulo não foi usado como referência</value>
  </data>
  <data name="WRN_UnreferencedVar" xml:space="preserve">
    <value>A variável "{0}" está declarada, mas nunca é usada</value>
  </data>
  <data name="ERR_BadArity" xml:space="preserve">
    <value>Usar o genérico {1} "{0}" requer {2} argumentos de tipo</value>
  </data>
  <data name="ERR_EndifDirectiveExpected" xml:space="preserve">
    <value>Diretiva #endif esperada</value>
  </data>
  <data name="WRN_UnobservedAwaitableExpression_Description" xml:space="preserve">
    <value>O método atual chama um método assíncrono que retorna uma Tarefa ou uma Tarefa&lt;TResult&gt; e não aplica o operador "await" ao resultado. A chamada ao método assíncrono inicia uma tarefa assíncrona. No entanto, como o operador "await" está aplicado, o programa continua sem aguardar a conclusão da tarefa. Na maioria dos casos, você não deseja esse comportamento. Geralmente, outros aspectos do método da chamada dependem dos resultados da chamada ou, no mínimo, espera-se que o método chamado seja concluído antes que você volte do método que contém a chamada.

Outra questão importante é o que acontece com as exceções que são acionadas no método assíncrono chamado. As exceções acionadas em métodos que retornam uma Task ou Task&lt;TResult&gt; são armazenadas na tarefa retornada. Se você não aguardar a tarefa ou verificar explicitamente se há exceções, a exceção se perde. Se você aguardar a tarefa, a exceção é gerada novamente.

Como melhor prática, recomendamos que você sempre aguarde a chamada.

Você pode suprimir o aviso se tiver certeza de que não vai querer aguardar a conclusão da chamada assíncrona e de que o método da chamada não gerará exceções. Nesse caso, você pode atribuir o resultado de uma tarefa da chamada a uma variável para suprimir o aviso.</value>
  </data>
  <data name="IDS_FeatureQueryExpression" xml:space="preserve">
    <value>expressão de consulta</value>
  </data>
  <data name="ERR_InvalidAttributeArgument" xml:space="preserve">
    <value>Valor inválido para o argumento ao atributo "{0}"</value>
  </data>
  <data name="ERR_AgnosticToMachineModule" xml:space="preserve">
    <value>Assembly desconhecido não pode ter um módulo específico de processador "{0}".</value>
  </data>
  <data name="ERR_TrailingWhitespaceInFormatSpecifier" xml:space="preserve">
    <value>Um especificador de formato não pode conter espaço em branco à direita.</value>
  </data>
  <data name="WRN_UnreferencedVarAssg_Title" xml:space="preserve">
    <value>A variável é atribuída, mas seu valor nunca é usado</value>
  </data>
  <data name="ERR_AddRemoveMustHaveBody" xml:space="preserve">
    <value>Um acessador add ou remove deve ter corpo</value>
  </data>
  <data name="ERR_ExplicitMethodImplAccessor" xml:space="preserve">
    <value>A implementação de método explícito "{0}" não pode implementar "{1}" porque é um acessador</value>
  </data>
  <data name="WRN_MultipleRuntimeImplementationMatches_Title" xml:space="preserve">
    <value>O membro implementa o membro de interface com várias correspondências no tempo de execução</value>
  </data>
  <data name="WRN_DuplicateParamTag" xml:space="preserve">
    <value>O comentário XML tem uma marca param duplicada para "{0}"</value>
  </data>
  <data name="ERR_ReservedEnumerator" xml:space="preserve">
    <value>O nome de enumerador "{0}" é reservado e não pode ser usado</value>
  </data>
  <data name="ERR_DictionaryInitializerInExpressionTree" xml:space="preserve">
    <value>Uma árvore de expressão da expressão lambda não pode conter um inicializador de dicionário.</value>
  </data>
  <data name="WRN_NewNotRequired" xml:space="preserve">
    <value>O membro "{0}" não oculta um membro acessível. A palavra-chave new não é necessária.</value>
  </data>
  <data name="WRN_BadWarningNumber_Description" xml:space="preserve">
    <value>Um número que foi passado para a diretiva de pré-processador de aviso #pragma não era um número de aviso válido. Verifique se o número representa um aviso, não um erro.</value>
  </data>
  <data name="IDS_AwaitInCatchAndFinally" xml:space="preserve">
    <value>aguardar em blocos variáveis e blocos finais</value>
  </data>
  <data name="WRN_MainCantBeGeneric" xml:space="preserve">
    <value>"{0}": um ponto de entrada não pode ser genérico ou estar em um tipo genérico</value>
  </data>
  <data name="ERR_UnimplementedInterfaceMember" xml:space="preserve">
    <value>"{0}" não implementa membro de interface "{1}"</value>
  </data>
  <data name="ERR_BadInstanceArgType" xml:space="preserve">
    <value>"{0}" não contém uma definição para "{1}" e a melhor sobrecarga do método de extensão "{2}" requer um receptor do tipo "{3}"</value>
  </data>
  <data name="ERR_ReferenceDirectiveOnlyAllowedInScripts" xml:space="preserve">
    <value>#r somente é permitido em scripts</value>
  </data>
  <data name="SyntaxTreeAlreadyPresent" xml:space="preserve">
    <value>Árvore de sintaxe já está presente</value>
  </data>
  <data name="ERR_BadRefWithThis" xml:space="preserve">
    <value> O modificador de parâmetro 'ref' não pode ser usado com 'this' </value>
  </data>
  <data name="ERR_InvalidOutputName" xml:space="preserve">
    <value>Nome de saída inválido: {0}</value>
  </data>
  <data name="ERR_ComImportWithUserCtor" xml:space="preserve">
    <value>A classe com o atributo ComImport não pode ter um construtor definido pelo usuário</value>
  </data>
  <data name="ERR_RefReturnMustHaveIdentityConversion" xml:space="preserve">
    <value>A expressão de retorno deve ser do tipo '{0}' porque esse método é retornado por referência</value>
  </data>
  <data name="ERR_AutoPropertyMustHaveGetAccessor" xml:space="preserve">
    <value>Propriedades autoimplementadas devem ter acessadores get.</value>
  </data>
  <data name="WRN_CLS_BadIdentifier" xml:space="preserve">
    <value>Identificador "{0}" não tem conformidade com CLS</value>
  </data>
  <data name="ERR_BadPdbData" xml:space="preserve">
    <value>Erro ao ler as informações de depuração para '{0}'</value>
  </data>
  <data name="ERR_DestructorInStaticClass" xml:space="preserve">
    <value>Classes static não podem conter destruidores</value>
  </data>
  <data name="WRN_IsAlwaysTrue" xml:space="preserve">
    <value>A expressão fornecida sempre é do tipo ("{0}") fornecido</value>
  </data>
  <data name="ERR_SourceFileReferencesNotSupported" xml:space="preserve">
    <value>Não há suporte às referências do arquivo de origem.</value>
  </data>
  <data name="WRN_SequentialOnPartialClass" xml:space="preserve">
    <value>Não há ordenação definida entre os campos em várias declarações de estrutura partial "{0}". Para especificar uma ordenação, todos os campos de instância devem estar na mesma declaração.</value>
  </data>
  <data name="ERR_BadVisIndexerReturn" xml:space="preserve">
    <value>Acessibilidade inconsistente: tipo de retorno do indexador "{1}" é menos acessível do que o indexador "{0}"</value>
  </data>
  <data name="WRN_CLS_VolatileField_Title" xml:space="preserve">
    <value>Campo em conformidade com CLS não pode ser volátil</value>
  </data>
  <data name="ERR_BadVisParamType" xml:space="preserve">
    <value>Acessibilidade inconsistente: tipo de parâmetro "{1}" é menos acessível do que o método "{0}"</value>
  </data>
  <data name="TreeMustHaveARootNodeWith" xml:space="preserve">
    <value>árvores devem ter um nó raiz com SyntaxKind.CompilationUnit</value>
  </data>
  <data name="ERR_IllegalStatement" xml:space="preserve">
    <value>Somente expressões de atribuição, chamada, incremento, diminuição e novo objeto podem ser usadas como uma instrução</value>
  </data>
  <data name="WRN_CallerFilePathParamForUnconsumedLocation" xml:space="preserve">
    <value>O atributo CallerFilePathAttribute aplicado ao parâmetro "{0}" não terá efeito porque ele se aplica a um membro que é usado em contextos que não permitem o uso de argumentos opcionais</value>
  </data>
  <data name="ERR_IllegalParams" xml:space="preserve">
    <value>params não é válido neste contexto</value>
  </data>
  <data name="ERR_ByRefParameterInExpressionTree" xml:space="preserve">
    <value>Uma árvore de expressão da expressão lambda não pode conter um parâmetro out ou ref</value>
  </data>
  <data name="ERR_CollectionInitRequiresIEnumerable" xml:space="preserve">
    <value>Não é possível inicializar o tipo "{0}" com um inicializador de coleta porque ele não implementa "System.Collections.IEnumerable"</value>
  </data>
  <data name="ERR_BadShiftOperatorSignature" xml:space="preserve">
    <value>O primeiro operando de um operador de deslocamento sobrecarregado deve ser do tipo recipiente, enquanto o do segundo deve ser int</value>
  </data>
  <data name="IDS_FeatureAutoPropertyInitializer" xml:space="preserve">
    <value>inicializador de autopropriedade</value>
  </data>
  <data name="ERR_CantReadResource" xml:space="preserve">
    <value>Erro ao ler o recurso "{0}" -- "{1}"</value>
  </data>
  <data name="ERR_PPDirectiveExpected" xml:space="preserve">
    <value>Diretiva de pré-processamento esperada</value>
  </data>
  <data name="ERR_ByRefTypeAndAwait" xml:space="preserve">
    <value>'aguardar' não pode ser usado em uma expressão que contém o tipo '{0}'</value>
  </data>
  <data name="ERR_DuplicatePropertyAccessMods" xml:space="preserve">
    <value>Não é possível especificar modificadores de acessibilidade para os acessores da propriedade ou indexador "{0}"</value>
  </data>
  <data name="ERR_TupleDuplicateElementName" xml:space="preserve">
    <value>Os nomes de elemento de tupla devem ser exclusivos.</value>
  </data>
  <data name="WRN_BadUILang_Title" xml:space="preserve">
    <value>O nome do idioma é inválido</value>
  </data>
  <data name="ERR_CantCallSpecialMethod" xml:space="preserve">
    <value>"{0}": não é possível chamar explicitamente o operador ou acessador</value>
  </data>
  <data name="ERR_ExternHasConstructorInitializer" xml:space="preserve">
    <value>'{0}' não pode ser externo e possui um inicializador de construtor</value>
  </data>
  <data name="ERR_AutoPropertyCannotBeRefReturning" xml:space="preserve">
    <value>As propriedades autoimplementadas não podem retornar por referência</value>
  </data>
  <data name="XML_WhitespaceMissing" xml:space="preserve">
    <value>Espaço em branco necessário estava ausente.</value>
  </data>
  <data name="ERR_MissingNetModuleReference" xml:space="preserve">
    <value>Referência a "{0}" netmodule ausente.</value>
  </data>
  <data name="IDS_OperationCausedStackOverflow" xml:space="preserve">
    <value>A operação causou um estouro de pilha.</value>
  </data>
  <data name="IDS_FOREACHLOCAL" xml:space="preserve">
    <value>variável de iteração foreach</value>
  </data>
  <data name="ERR_CantOverrideNonEvent" xml:space="preserve">
    <value>"{0}": não é possível substituir; "{1}" não é um evento</value>
  </data>
  <data name="ERR_DuplicateTypeForwarder" xml:space="preserve">
    <value>"{0}" duplicar TypeForwardedToAttribute</value>
  </data>
  <data name="ERR_InvalidFixedArraySize" xml:space="preserve">
    <value>O tamanho dos buffers de tamanho fixo deve ser maior que zero</value>
  </data>
  <data name="ERR_BadAwaitAsIdentifier" xml:space="preserve">
    <value>await' não pode ser usado como um identificador em um método assíncrono ou em uma expressão lambda</value>
  </data>
  <data name="ERR_ConstOutOfRangeChecked" xml:space="preserve">
    <value>O valor de constante "{0}" não pode ser convertido em "{1}" (use a sintaxe "unchecked" para substituir)</value>
  </data>
  <data name="WRN_CLS_BadIdentifier_Title" xml:space="preserve">
    <value>Identificador não tem conformidade com CLS</value>
  </data>
  <data name="IDS_FeatureDictionaryInitializer" xml:space="preserve">
    <value>inicializador de dicionário</value>
  </data>
  <data name="IDS_FeatureInterpolatedStrings" xml:space="preserve">
    <value>cadeias de caracteres interpoladas</value>
  </data>
  <data name="ERR_AnonymousReturnExpected" xml:space="preserve">
    <value>Nem todos os caminhos de código retornam um valor em {0} do tipo "{1}"</value>
  </data>
  <data name="WRN_BadRefCompareLeft_Title" xml:space="preserve">
    <value>Possível comparação de referência inesperada; o lado esquerdo precisa de conversão</value>
  </data>
  <data name="ERR_PermissionSetAttributeInvalidFile" xml:space="preserve">
    <value>Não é possível resolver o caminho de arquivo "{0}" especificado para o argumento nomeado "{1}" para o atributo PermissionSet</value>
  </data>
  <data name="ERR_InvalidNumber" xml:space="preserve">
    <value>Número inválido</value>
  </data>
  <data name="WRN_RefCultureMismatch" xml:space="preserve">
    <value>Assembly referenciado "{0}" tem a configuração de cultura diferente de "{1}".</value>
  </data>
  <data name="WRN_AmbiguousXMLReference_Title" xml:space="preserve">
    <value>Referência ambígua no atributo cref</value>
  </data>
  <data name="ERR_BadTypeforThis" xml:space="preserve">
    <value>O primeiro parâmetro de um método de extensão não pode ser do tipo "{0}"</value>
  </data>
  <data name="ERR_BadSKunknown" xml:space="preserve">
    <value>"{0}" é um {1}, que não é válido no contexto fornecido</value>
  </data>
  <data name="WRN_CLS_OverloadRefOut" xml:space="preserve">
    <value>Metódo sobrecarregado "{0}" diferindo somente em ref ou out, ou em classificação de matriz não tem conformidade com CLS</value>
  </data>
  <data name="ERR_NoVoidParameter" xml:space="preserve">
    <value>Tipo de parâmetro 'void' inválido</value>
  </data>
  <data name="ERR_ConstraintOnlyAllowedOnGenericDecl" xml:space="preserve">
    <value>Não são permitidas restrições em declarações não genéricas</value>
  </data>
  <data name="WRN_BadXMLRefSyntax_Title" xml:space="preserve">
    <value>O comentário XML possui um atributo cref sintaticamente incorreto</value>
  </data>
  <data name="IDS_FeatureAnonDelegates" xml:space="preserve">
    <value>métodos anônimos</value>
  </data>
  <data name="ERR_ExpressionTreeContainsThrowExpression" xml:space="preserve">
    <value>Uma árvore de expressão não pode conter uma expressão throw.</value>
  </data>
  <data name="ERR_NoExplicitConv" xml:space="preserve">
    <value>Não é possível converter tipo "{0}" em "{1}"</value>
  </data>
  <data name="ERR_DuplicateNamedArgument" xml:space="preserve">
    <value>O argumento nomeado "{0}" não pode ser especificado várias vezes</value>
  </data>
  <data name="ERR_BadArraySyntax" xml:space="preserve">
    <value>O especificador de tipo de matriz, [], deve aparecer antes do nome de parâmetro</value>
  </data>
  <data name="ERR_ValueCantBeNull" xml:space="preserve">
    <value>Não é possível converter o valor nulo em '{0}' porque ele não é um tipo de valor não nulo</value>
  </data>
  <data name="ERR_PartialMisplaced" xml:space="preserve">
    <value>O modificador 'partial' só pode aparecer imediatamente antes de 'class', 'struct', 'interface' ou 'void'</value>
  </data>
  <data name="ERR_DefaultValueTypeMustMatch" xml:space="preserve">
    <value>O tipo do argumento para o atributo DefaultParameterValue deve corresponder ao tipo de parâmetro</value>
  </data>
  <data name="ERR_AliasMissingFile" xml:space="preserve">
    <value>Opção de alias de referência inválida: "{0}=" -- nome de arquivo ausente</value>
  </data>
  <data name="ERR_RefReturnReadonly2" xml:space="preserve">
    <value>Membros do campo somente leitura '{0}' não podem ser retornados por referência</value>
  </data>
  <data name="ERR_BadDynamicMethodArg" xml:space="preserve">
    <value>Não é possível usar uma expressão do tipo "{0}" como um argumento para uma operação dinamicamente despachada.</value>
  </data>
  <data name="ERR_BadDynamicQuery" xml:space="preserve">
    <value>Não são permitidas expressões de consulta no tipo de origem "dynamic" ou com uma sequência de união do tipo "dynamic"</value>
  </data>
  <data name="WRN_CmdOptionConflictsSource" xml:space="preserve">
    <value>Opção "{0}" substitui o atributo "{1}" fornecido em um arquivo de origem ou módulo adicionado</value>
  </data>
  <data name="ERR_MemberNameSameAsType" xml:space="preserve">
    <value>"{0}": nomes de membro não podem ser os mesmos do seu tipo delimitador</value>
  </data>
  <data name="ERR_TypeVarNotFound" xml:space="preserve">
    <value>A palavra-chave contextual "var" pode somente aparecer dentro de uma declaração de variável local ou no código de script</value>
  </data>
  <data name="ERR_BadBaseNumber" xml:space="preserve">
    <value>Número base de imagem inválido "{0}"</value>
  </data>
  <data name="ERR_WinRtEventPassedByRef" xml:space="preserve">
    <value>Um evento de Tempo de Execução do Windows não pode ser passado como parâmetro out ou ref.</value>
  </data>
  <data name="ERR_SpecialByRefInLambda" xml:space="preserve">
    <value>Instância do tipo "{0}" não pode ser usado dentro de uma função anônima, expressão de consulta, bloco de iteradores ou método assíncrono</value>
  </data>
  <data name="ERR_CloseUnimplementedInterfaceMemberWrongReturnType" xml:space="preserve">
    <value>"{0}" não implementa membro de interface "{1}". "{2}" não pode implementar "{1}" porqu não tem o tipo de retorno correspondente de "{3}".</value>
  </data>
  <data name="ERR_QueryTypeInferenceFailedMulti" xml:space="preserve">
    <value>O tipo de uma das expressões na cláusula {0} está incorreto. Inferência de tipos falhou na chamada para "{1}".</value>
  </data>
  <data name="WRN_BadXMLRefTypeVar_Title" xml:space="preserve">
    <value>O comentário XML tem um atributo cref que faz referência a um parâmetro de tipo</value>
  </data>
  <data name="ERR_MethodNameExpected" xml:space="preserve">
    <value>Nome de método esperado</value>
  </data>
  <data name="ERR_FixedLocalInLambda" xml:space="preserve">
    <value>Não é possível usar o local fixo "{0}" dentro de um método anônimo, expressão lambda ou expressão de consulta</value>
  </data>
  <data name="ERR_IllegalVarArgs" xml:space="preserve">
    <value>__arglist não é válido neste contexto</value>
  </data>
  <data name="ElementsCannotBeNull" xml:space="preserve">
    <value>Elementos não podem ser nulos.</value>
  </data>
  <data name="NotACSharpSymbol" xml:space="preserve">
    <value>Não é um símbolo C#.</value>
  </data>
  <data name="ERR_ParameterIsStaticClass" xml:space="preserve">
    <value>"{0}": classes static não podem ser utilizadas como parâmetros</value>
  </data>
  <data name="ERR_ExportedTypeConflictsWithDeclaration" xml:space="preserve">
    <value>Tipo "{0}" exportado do módulo "{1}" está em conflito com tipo declarado no módulo primário deste assembly.</value>
  </data>
  <data name="ERR_InvalidVersionFormat" xml:space="preserve">
    <value>A cadeia de caracteres de versão especificada não está de acordo com o formato necessário - major[.minor [.build[.revision]]]</value>
  </data>
  <data name="ERR_MultipleIEnumOfT" xml:space="preserve">
    <value>A instrução foreach não pode operar em variáveis do tipo "{0}" porque implementa várias instanciações de "{1}"; tente transmitir para uma instanciação de interface específica</value>
  </data>
  <data name="WRN_UnmatchedParamTag_Title" xml:space="preserve">
    <value>O comentário XML tem uma marca param, mas não há nenhum parâmetro com esse nome</value>
  </data>
  <data name="ERR_ByRefReturnUnsupported" xml:space="preserve">
    <value>Tipo de retorno por referência "ref {0}" não tem suporte.</value>
  </data>
  <data name="ERR_IdentifierExpected" xml:space="preserve">
    <value>Identificador esperado</value>
  </data>
  <data name="IDS_FeaturePatternMatching" xml:space="preserve">
    <value>correspondência de padrões</value>
  </data>
  <data name="WRN_CallerFilePathPreferredOverCallerMemberName_Title" xml:space="preserve">
    <value>O CallerMemberNameAttribute não terá nenhum efeito; ele é substituído pelo CallerFilePathAttribute</value>
  </data>
  <data name="ERR_ExpressionTreeContainsBaseAccess" xml:space="preserve">
    <value>Uma árvore de expressões não pode conter um acesso de base</value>
  </data>
  <data name="ERR_DupParamMod" xml:space="preserve">
    <value>Um parâmetro pode somente ter um modificador "{0}"</value>
  </data>
  <data name="ERR_LabelNotFound" xml:space="preserve">
    <value>Nenhum rótulo "{0}" dentro do escopo da instrução goto</value>
  </data>
  <data name="ERR_IllegalUnsafe" xml:space="preserve">
    <value>Um código sem segurança só pode aparecer se a compilação for com /unsafe</value>
  </data>
  <data name="ERR_RefReturningCallAndAwait" xml:space="preserve">
    <value>'await' não pode ser usado em uma expressão contendo uma chamada para '{0}', pois ele é retornado por referência</value>
  </data>
  <data name="ERR_VirtualPrivate" xml:space="preserve">
    <value>"{0}": membros virtuais ou abstratos não podem ser privados</value>
  </data>
  <data name="WRN_RefCultureMismatch_Title" xml:space="preserve">
    <value>O assembly referenciado possui uma configuração de cultura diferente</value>
  </data>
  <data name="ERR_NoConversionForNubDefaultParam" xml:space="preserve">
    <value>Um valor do tipo "{0}" não pode ser usado como parâmetro padrão para parâmetro anulável "{1}" porque "{0}" não é um tipo simples</value>
  </data>
  <data name="ERR_NoConversionForDefaultParam" xml:space="preserve">
    <value>Um valor de tipo "{0}" não pode ser usado como um parâmetro padrão porque não há conversões padrões para o tipo "{1}"</value>
  </data>
  <data name="ERR_AbstractInConcreteClass" xml:space="preserve">
    <value>"{0}" é abstract, mas está contido na classe non-abstract "{1}"</value>
  </data>
  <data name="ERR_TypeForwardedToMultipleAssemblies" xml:space="preserve">
    <value>O módulo '{0}' no assembly '{1}' está encaminhando o tipo '{2}' para vários assemblies: '{3}' e '{4}'.</value>
  </data>
  <data name="WRN_IllegalPPWarning_Title" xml:space="preserve">
    <value>Desabilitação ou restauração esperada após o aviso de #pragma</value>
  </data>
  <data name="ERR_SecurityAttributeInvalidActionTypeOrMethod" xml:space="preserve">
    <value>Valor SecurityAction "{0}" é inválido para atributos de segurança aplicados a um tipo ou um método</value>
  </data>
  <data name="ERR_BadSKknown" xml:space="preserve">
    <value>"{0}" é um {1}, mas é usado como um {2}</value>
  </data>
  <data name="ERR_BadDirectivePlacement" xml:space="preserve">
    <value>As diretivas de pré-processamento devem aparecer como o primeiro caractere que não seja espaço em branco em uma linha</value>
  </data>
  <data name="IDS_SK_FIELD" xml:space="preserve">
    <value>campo</value>
  </data>
  <data name="IDS_SK_ALIAS" xml:space="preserve">
    <value>alias using</value>
  </data>
  <data name="WRN_PatternStaticOrInaccessible_Title" xml:space="preserve">
    <value>O tipo não implementa o padrão de coleção; o membro é estático ou não é público</value>
  </data>
  <data name="IDS_FeatureDigitSeparator" xml:space="preserve">
    <value>separadores de dígito</value>
  </data>
  <data name="IDS_SK_EVENT" xml:space="preserve">
    <value>evento</value>
  </data>
  <data name="ERR_BadMemberFlag" xml:space="preserve">
    <value>O modificador "{0}" não é válido para este item</value>
  </data>
  <data name="ERR_SignButNoPrivateKey" xml:space="preserve">
    <value>Arquivo de chave "{0}" está sem a chave portátil necessária para assinatura</value>
  </data>
  <data name="IDS_SK_LABEL" xml:space="preserve">
    <value>rótulo</value>
  </data>
  <data name="ERR_IllegalArglist" xml:space="preserve">
    <value>A expressão __arglist só pode aparecer dentro de uma expressão de chamada ou expressão new</value>
  </data>
  <data name="FTL_BadChecksumAlgorithm" xml:space="preserve">
    <value>Algoritmo '{0}' sem suporte</value>
  </data>
  <data name="ERR_MemberNeedsType" xml:space="preserve">
    <value>O método deve ter um tipo de retorno</value>
  </data>
  <data name="IDS_SK_TYVAR" xml:space="preserve">
    <value>parâmetro de tipo</value>
  </data>
  <data name="ERR_EnumsCantContainDefaultConstructor" xml:space="preserve">
    <value>Enums não podem conter construtores explícitos sem parâmetros</value>
  </data>
  <data name="WRN_AttributeLocationOnBadDeclaration_Title" xml:space="preserve">
    <value>Este não é um local de atributo para esta declaração</value>
  </data>
  <data name="ERR_CryptoHashFailed" xml:space="preserve">
    <value>Falha na criptografia ao criar valores hashes.</value>
  </data>
  <data name="ThisMethodCanOnlyBeUsedToCreateTokens" xml:space="preserve">
    <value>Este método pode somente ser usado para criar tokens - {0} não é um tipo de token.</value>
  </data>
  <data name="ERR_NameNotInContextPossibleMissingReference" xml:space="preserve">
    <value>O nome "{0}" não existe no contexto atual (está sem uma referência para o assembly "{1}"?)</value>
  </data>
  <data name="ERR_BaseInBadContext" xml:space="preserve">
    <value>A palavra-chave 'base' não está disponível no contexto atual</value>
  </data>
  <data name="ERR_VariableUsedBeforeDeclaration" xml:space="preserve">
    <value>Não é possível usar a variável local "{0}" antes de declará-la</value>
  </data>
  <data name="XML_CDataEndTagNotAllowed" xml:space="preserve">
    <value>A cadeia de caracteres literal "]]&gt;" não é permitida no conteúdo do elemento.</value>
  </data>
  <data name="ERR_DeriveFromConstructedDynamic" xml:space="preserve">
    <value>"{0}": não é possível implementar uma interface dinâmica "{1}"</value>
  </data>
  <data name="ERR_ParameterNotValidForType" xml:space="preserve">
    <value>Parâmetro não é válido para o tipo não gerenciado especificado.</value>
  </data>
  <data name="IDS_REFERENCEPATH_OPTION" xml:space="preserve">
    <value>Opção /REFERENCEPATH</value>
  </data>
  <data name="ERR_ExpressionTreeContainsLocalFunction" xml:space="preserve">
    <value>Uma árvore de expressão não pode conter uma referência a uma função local</value>
  </data>
  <data name="ERR_FieldHasMultipleDistinctConstantValues" xml:space="preserve">
    <value>O campo tem vários valores constantes distintos.</value>
  </data>
  <data name="IDS_LogoLine1" xml:space="preserve">
    <value>{0} versão {1}</value>
  </data>
  <data name="IDS_LogoLine2" xml:space="preserve">
    <value>Copyright (C) Microsoft Corporation. Todos os direitos reservados.</value>
  </data>
  <data name="ERR_SecurityAttributeInvalidTarget" xml:space="preserve">
    <value>Atributo de segurança "{0}" não é válido neste tipo de declaração. Atributos de segurança são somente válidos em declarações de assembly, tipo e método.</value>
  </data>
  <data name="IDS_FeatureUsingStatic" xml:space="preserve">
    <value>usando estático</value>
  </data>
  <data name="ERR_EncReferenceToAddedMember" xml:space="preserve">
    <value>Membro '{0}' adicionado durante a sessão de depuração atual pode ser acessado somente neste assembly de declaração '{1}'.</value>
  </data>
  <data name="ERR_PPLoadFollowsToken" xml:space="preserve">
    <value>Não é permitido usar #load após o primeiro token do arquivo</value>
  </data>
  <data name="ERR_ExpressionTreeContainsOutVariable" xml:space="preserve">
    <value>Uma árvore de expressão não pode conter uma declaração de variável de argumento out.</value>
  </data>
  <data name="WRN_BadXMLRefParamType" xml:space="preserve">
    <value>Tipo inválido para parâmetro {0} no atributo de cref de comentário XML: "{1}"</value>
  </data>
  <data name="ERR_BadVisBound" xml:space="preserve">
    <value>Acessibilidade inconsistente: tipo de restrição "{1}" é menos acessível do que "{0}"</value>
  </data>
  <data name="ERR_AbstractAndSealed" xml:space="preserve">
    <value>"{0}" não pode ser ambos abstract e sealed</value>
  </data>
  <data name="ERR_UnexpectedCharacter" xml:space="preserve">
    <value>Caractere inesperado '{0}'</value>
  </data>
  <data name="ERR_BadNamedAttributeArgument" xml:space="preserve">
    <value>"{0}" é não um argumento de atributo nomeado válido. Argumentos de atributo nomeado devem ser campos que não são propriedades readonly, static ou const ou read-write que são públicas e não estáticas.</value>
  </data>
  <data name="WRN_IllegalPragma_Title" xml:space="preserve">
    <value>Diretiva #pragma não reconhecida</value>
  </data>
  <data name="ERR_VarDeclIsStaticClass" xml:space="preserve">
    <value>Não é possível declarar uma variável de tipo static "{0}"</value>
  </data>
  <data name="WRN_ReferencedAssemblyReferencesLinkedPIA_Description" xml:space="preserve">
    <value>Você adicionou uma referência a um assembly usando /link (propriedade Incorporar Tipos de Interoperabilidade definida como Verdadeiro). Isso instrui o compilador a incorporar as informações de tipo de interoperabilidade desse assembly. No entanto, o compilador não pode incorporar informações de tipo de interoperabilidade desse assembly porque outro conjunto que você referenciou também faz referência a esse assembly usando /reference (propriedade Incorporar Tipos de Interoperabilidade definida como Falso).

Para incorporar informações de tipo de interoperabilidade para os dois assemblies, use /link para fazer referência a cada assembly (defina a propriedade Incorporar Tipos de Interoperabilidade para Verdadeiro).

 Para remover o aviso, você pode usar o /reference em vez disso (defina a propriedade Incorporar Tipos de Interoperabilidade como Falso). Nesse caso, um assembly de interoperabilidade primária (PIA) fornece informações de tipo de interoperabilidade.</value>
  </data>
  <data name="IDS_FeatureExpressionBodiedAccessor" xml:space="preserve">
    <value>acessador da propriedade do corpo da expressão</value>
  </data>
  <data name="WRN_EqualityOpWithoutEquals" xml:space="preserve">
    <value>"{0}" define o operador = = ou operador !=, mas não substitui Object.Equals(object o)</value>
  </data>
  <data name="WrongNumberOfTypeArguments" xml:space="preserve">
    <value>Número errado de argumentos de tipo</value>
  </data>
  <data name="WRN_PatternBadSignature" xml:space="preserve">
    <value>"{0}" não implementa o padrão "{1}". "{2}" tem a assinatura errada.</value>
  </data>
  <data name="ERR_BadModifiersOnNamespace" xml:space="preserve">
    <value>Uma declaração de namespace não pode ter modificadores nem atributos</value>
  </data>
  <data name="ERR_MissingStructOffset" xml:space="preserve">
    <value>"{0}": tipos de campo de instância marcados com StructLayout(LayoutKind.Explicit) devem ter um atributo FieldOffset</value>
  </data>
  <data name="ERR_NoNewAbstract" xml:space="preserve">
    <value>Não é possível criar uma instância da classe abstract ou interface "{0}"</value>
  </data>
  <data name="ERR_ExplicitEventFieldImpl" xml:space="preserve">
    <value>Uma implementação de interface explícita de um evento deve usar a sintaxe de acessador do evento</value>
  </data>
  <data name="ERR_CircConstValue" xml:space="preserve">
    <value>A avaliação do valor de constante para "{0}" envolve uma definição circular</value>
  </data>
  <data name="WRN_AttributeLocationOnBadDeclaration" xml:space="preserve">
    <value>"{0}" não é um local de atributo válido para esta declaração. Locais de atributo válidos para esta declaração são "{1}". Todos os atributos neste bloco serão ignorados.</value>
  </data>
  <data name="ERR_AmbiguousAttribute" xml:space="preserve">
    <value>{0} é ambíguo entre '{1}' e '{2}'; use '@{0}' ou '{0}Attribute'</value>
  </data>
  <data name="ERR_SemicolonExpected" xml:space="preserve">
    <value>; esperado</value>
  </data>
  <data name="WRN_DynamicDispatchToConditionalMethod_Title" xml:space="preserve">
    <value>Uma chamada despachada dinamicamente pode falhar no tempo de execução porque uma ou mais sobrecargas aplicáveis são métodos condicionais</value>
  </data>
  <data name="WRN_SameFullNameThisNsAgg_Title" xml:space="preserve">
    <value>Conflitos de namespace com o tipo importado</value>
  </data>
  <data name="ERR_PartialMethodOnlyOneActual" xml:space="preserve">
    <value>Um método parcial não pode ter várias declarações de implementação</value>
  </data>
  <data name="ERR_RefReadonlyLocalCause" xml:space="preserve">
    <value>Não é possível usar '{0}' como um valor ref ou out porque ele é '{1}'</value>
  </data>
  <data name="ERR_FriendRefSigningMismatch" xml:space="preserve">
    <value>O acesso Friend foi concedido por "{0}", mas o estado de assinatura de nome forte do assembly de saída não corresponde àquele do assembly de concessão.</value>
  </data>
  <data name="ERR_ConstructedDynamicTypeAsBound" xml:space="preserve">
    <value>Restrição não pode ser um tipo dinâmico "{0}"</value>
  </data>
  <data name="ERR_BadUnaryOp" xml:space="preserve">
    <value>O operador "{0}" não pode ser aplicado ao operando do tipo "{1}"</value>
  </data>
  <data name="WRN_VolatileByRef" xml:space="preserve">
    <value>"{0}": uma referência a um campo volátil não será tratada como volátil</value>
  </data>
  <data name="ERR_ExpressionTreeContainsDynamicOperation" xml:space="preserve">
    <value>Uma árvore de expressões não pode conter uma operação dinâmica</value>
  </data>
  <data name="ERR_ImplicitlyTypedLocalCannotBeFixed" xml:space="preserve">
    <value>Variáveis locais do tipo implícito não podem ser fixas</value>
  </data>
  <data name="ERR_ImportedCircularBase" xml:space="preserve">
    <value>Tipo importado "{0}" é inválido. Ele contém uma dependência de classe de base circular.</value>
  </data>
  <data name="ERR_QueryMultipleProviders" xml:space="preserve">
    <value>Várias implementações do padrão de consulta foram encontradas para o tipo de origem "{0}". Chamada ambígua para "{1}".</value>
  </data>
  <data name="WRN_UnimplementedCommandLineSwitch" xml:space="preserve">
    <value>A opção de linha de comando "{0}" ainda não está implementada e foi ignorada.</value>
  </data>
  <data name="WRN_ExternMethodNoImplementation" xml:space="preserve">
    <value>Método, operador ou acessador "{0}" está marcado como externo e sem atributos. Considere a adição de um atributo DllImport para especificar a implementação externa.</value>
  </data>
  <data name="ERR_BadVisIndexerParam" xml:space="preserve">
    <value>Acessibilidade inconsistente: tipo de parâmetro "{1}" é menos acessível do que o indexador "{0}"</value>
  </data>
  <data name="IDS_FeatureExpressionBodiedProperty" xml:space="preserve">
    <value>propriedade apta para expressão</value>
  </data>
  <data name="ERR_StructOffsetOnBadField" xml:space="preserve">
    <value>O atributo FieldOffset não é permitido em campos estáticos e const</value>
  </data>
  <data name="ERR_AnonDelegateCantUseLocal" xml:space="preserve">
    <value>Não é possível usar a referência local '{0}' em um método anônimo, expressão lambda ou expressão de consulta</value>
  </data>
  <data name="ERR_AmbigBinaryOps" xml:space="preserve">
    <value>O operador "{0}" é ambíguo em operandos dos tipos "{1}" e "{2}"</value>
  </data>
  <data name="WRN_CLS_BadReturnType" xml:space="preserve">
    <value>Tipo de retorno de "{0}" não tem conformidade com CLS</value>
  </data>
  <data name="WRN_UnifyReferenceMajMin_Title" xml:space="preserve">
    <value>Presume-se que a referência do assembly coincide com a identidade</value>
  </data>
  <data name="ERR_NoSuchMemberOrExtensionNeedUsing" xml:space="preserve">
    <value>"{0}" não contém uma definição para "{1}" e nenhum método de extensão "{1}" aceitando um primeiro argumento do tipo "{0}" pode ser encontrado (está faltando uma diretiva using para "{2}"?)</value>
  </data>
  <data name="WRN_DelaySignButNoKey_Title" xml:space="preserve">
    <value>A assinatura atrasada foi especificada e requer uma chave pública, mas nenhuma chave pública foi especificada</value>
  </data>
  <data name="WRN_DotOnDefault" xml:space="preserve">
    <value>Expressão sempre causará uma System.NullReferenceException porque o valor padrão de "{0}" é nulo</value>
  </data>
  <data name="ERR_IndexerNeedsParam" xml:space="preserve">
    <value>Indexadores devem ter no mínimo um parâmetro</value>
  </data>
  <data name="WRN_IsDynamicIsConfusing" xml:space="preserve">
    <value>Usar "{0}" para testar a compatibilidade com "{1}" é essencialmente idêntico testar compatibilidade com "{2}" e terá êxito para todos os valores não-nulos</value>
  </data>
  <data name="ERR_IntegralTypeValueExpected" xml:space="preserve">
    <value>Um valor de tipo integral é esperado</value>
  </data>
  <data name="ERR_MultiParamMod" xml:space="preserve">
    <value>Um parâmetro não pode ter todos os modificadores especificados; há muitos modificadores no parâmetro</value>
  </data>
  <data name="ERR_NotYetImplementedInRoslyn" xml:space="preserve">
    <value>Esse recurso de idioma ("{0}") ainda não está implementado.</value>
  </data>
  <data name="SyntaxTreeIsNotASubmission" xml:space="preserve">
    <value>A árvore de sintaxe deve ser criada de uma submissão.</value>
  </data>
  <data name="WRN_DebugFullNameTooLong_Title" xml:space="preserve">
    <value>O nome totalmente qualificado é muito longo para as informações de depuração</value>
  </data>
  <data name="WRN_NoRuntimeMetadataVersion" xml:space="preserve">
    <value>Nenhum valor para RuntimeMetadataVersion encontrado. Nenhum assembly contendo System.Object foi encontrado nem foi encontrado um valor de RuntimeMetadataVersion especificado por meio de opções.</value>
  </data>
  <data name="WRN_CoClassWithoutComImport_Title" xml:space="preserve">
    <value>Interface marcada com 'CoClassAttribute', não com 'ComImportAttribute'</value>
  </data>
  <data name="WRN_CA2000_DisposeObjectsBeforeLosingScope2_Title" xml:space="preserve">
    <value>Instância alocada não descartada em todos os caminhos de exceção</value>
  </data>
  <data name="ERR_InExpected" xml:space="preserve">
    <value>in' esperado</value>
  </data>
  <data name="ERR_ErrorInReferencedAssembly" xml:space="preserve">
    <value>Há um erro em um assembly referenciado '{0}'.</value>
  </data>
  <data name="ERR_TupleReservedElementNameAnyPosition" xml:space="preserve">
    <value>O nome do elemento de tupla '{0}' não é permitido em qualquer posição.</value>
  </data>
  <data name="WRN_NegativeArrayIndex" xml:space="preserve">
    <value>Indexando uma matriz com um índice negativo. (Índices de matriz sempre começam em zero)</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnReturn" xml:space="preserve">
    <value>O atributo CLSCompliant não tem sentido quando aplicado a tipos de retorno. Tente colocá-lo no método.</value>
  </data>
  <data name="ERR_MainClassNotClass" xml:space="preserve">
    <value>"{0}" especificado para método Main deve ser uma classe ou estrutura não-genérica válida</value>
  </data>
  <data name="ERR_DeprecatedCollectionInitAddStr" xml:space="preserve">
    <value>O melhor método Adicionar sobrecarregado "{0}" para o elemento do inicializador de coleção está obsoleto. {1}</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnPrivateType_Title" xml:space="preserve">
    <value>A verificação de compatibilidade com CLS não será executada porque ela não é vista de fora deste assembly</value>
  </data>
  <data name="ERR_PartialWrongConstraints" xml:space="preserve">
    <value>Declarações parciais de "{0}" têm restrições inconsistentes para o parâmetro de tipo "{1}"</value>
  </data>
  <data name="ERR_MainClassNotFound" xml:space="preserve">
    <value>Não foi possível encontrar "{0}" especificado para o método Main</value>
  </data>
  <data name="WRN_ByRefNonAgileField_Title" xml:space="preserve">
    <value>Usar um campo de uma classe marshal por referência como um valor ref ou out ou obter seu endereço pode gerar uma exceção de tempo de execução</value>
  </data>
  <data name="ERR_PropertyAccessModInInterface" xml:space="preserve">
    <value>"{0}": modificadores de acessibilidade não podem ser usados em aceessadores em uma interface</value>
  </data>
  <data name="ERR_NoCorrespondingArgument" xml:space="preserve">
    <value>Não há nenhum argumento fornecido que corresponde ao parâmetro formal necessário "{0}" de "{1}"</value>
  </data>
  <data name="ERR_BadSourceCodeKind" xml:space="preserve">
    <value>O tipo de código-fonte fornecido não tem suporte ou é inválido: '{0}'</value>
  </data>
  <data name="ERR_DefaultValueForParamsParameter" xml:space="preserve">
    <value>Não é possível especificar um valor padrão para uma matriz de parâmetros</value>
  </data>
  <data name="WRN_AssignmentToSelf_Title" xml:space="preserve">
    <value>Atribuição feita à mesma variável</value>
  </data>
  <data name="ERR_InvalidPreprocessingSymbol" xml:space="preserve">
    <value>Nome inválido para um símbolo de pré-processamento. '{0}' não é um identificador válido</value>
  </data>
  <data name="ERR_UnifyingInterfaceInstantiations" xml:space="preserve">
    <value>"{0}" não pode implementar "{1}" e "{2}" porque eles podem se unificar em algumas substituições de parâmetro de tipo</value>
  </data>
  <data name="ERR_ForwardedTypeConflictsWithExportedType" xml:space="preserve">
    <value>Tipo "{0}" encaminhado para o assembly "{1}" está em conflito com tipo "{2}" exportado do módulo "{3}".</value>
  </data>
  <data name="ERR_ValConstraintNotSatisfied" xml:space="preserve">
    <value>O tipo "{2}" deve ser um tipo de valor não nulo para que seja usado como parâmetro "{1}" no tipo ou método genérico "{0}"</value>
  </data>
  <data name="WRN_InvalidMainSig_Title" xml:space="preserve">
    <value>O método tem a assinatura incorreta para ser um ponto de entrada</value>
  </data>
  <data name="ERR_DuplicateModifier" xml:space="preserve">
    <value>Duplicar modificador "{0}"</value>
  </data>
  <data name="IDS_Contravariantly" xml:space="preserve">
    <value>contravariantly</value>
  </data>
  <data name="ERR_ExpectedVerbatimLiteral" xml:space="preserve">
    <value>Palavra-chave, cadeia de caracteres ou identificador esperado após o especificador textual: @</value>
  </data>
  <data name="ERR_ExplicitPropertyMissingAccessor" xml:space="preserve">
    <value>Implementação de interface explícita "{0}" está sem o acessador "{1}"</value>
  </data>
  <data name="ERR_NewConstraintNotSatisfied" xml:space="preserve">
    <value>"{2}" deve ser um tipo non-abstract com um construtor público sem-parâmetros para que possa ser usado como parâmetro "{1}" no tipo ou método genérico "{0}"</value>
  </data>
  <data name="ERR_ClassDoesntImplementInterface" xml:space="preserve">
    <value>"{0}": tipo recipiente não implementa interface "{1}"</value>
  </data>
  <data name="ERR_QueryNoProviderStandard" xml:space="preserve">
    <value>Não foi possível encontrar uma implementação do padrão de consulta para o tipo de origem "{0}". "{1}" não encontrado. Está faltando uma referência a "System.Core.dll" ou uma diretiva using para "System.Linq"?</value>
  </data>
  <data name="ERR_OperatorCantReturnVoid" xml:space="preserve">
    <value>Operadores definidos pelo usuário não podem retornar void</value>
  </data>
  <data name="IDS_FeatureBinaryLiteral" xml:space="preserve">
    <value>literais binários</value>
  </data>
  <data name="ERR_NegativeArraySize" xml:space="preserve">
    <value>Não é possível criar uma matriz com um tamanho negativo</value>
  </data>
  <data name="IDS_FeatureStaticClasses" xml:space="preserve">
    <value>classes static</value>
  </data>
  <data name="ERR_YieldInAnonMeth" xml:space="preserve">
    <value>A instrução yield não pode ser usada em um método anônimo ou expressão lambda</value>
  </data>
  <data name="ERR_GenericsUsedInNoPIAType" xml:space="preserve">
    <value>Tipo "{0}" não pode ser incorporado porque ele tem um argumento genérico. Considere definir a propriedade "Incorporar Tipos de Interoperabilidade" como falso.</value>
  </data>
  <data name="WRN_TooManyLinesForDebugger_Title" xml:space="preserve">
    <value>O arquivo de origem excedeu o limite de 16.707.565 linhas representáveis no PDB; as informações de depuração estarão incorretas</value>
  </data>
  <data name="ERR_AutoPropertyInitializerInInterface" xml:space="preserve">
    <value>Propriedades autoimplementadas em interfaces não podem ter inicializadores.</value>
  </data>
  <data name="ERR_UnimplementedInterfaceAccessor" xml:space="preserve">
    <value>"{0}" não implementa membro de interface "{1}". "{2}" não é público.</value>
  </data>
  <data name="ERR_TyVarNotFoundInConstraint" xml:space="preserve">
    <value>"{1}" não define parâmetro de tipo "{0}"</value>
  </data>
  <data name="ERR_BadDynamicTypeof" xml:space="preserve">
    <value>O operador typeof não pode ser usado no tipo dinâmico</value>
  </data>
  <data name="ERR_IncrementLvalueExpected" xml:space="preserve">
    <value>O operando de aumento ou diminuição deve ser uma variável, propriedade ou indexador</value>
  </data>
  <data name="ERR_CannotEmbedWithoutPdb" xml:space="preserve">
    <value>Só há suporte para o comutador /embed ao emitir um PDB Portátil (/debug:portable ou /debug:embedded).</value>
  </data>
  <data name="ERR_AbstractAndExtern" xml:space="preserve">
    <value>"{0}" não pode ser extern e abstract</value>
  </data>
  <data name="ERR_RetObjectRequired" xml:space="preserve">
    <value>Um objeto de tipo conversível em "{0}" é necessário</value>
  </data>
  <data name="ERR_InstantiatingStaticClass" xml:space="preserve">
    <value>Não é possível criar uma instância da classe estática "{0}"</value>
  </data>
  <data name="WRN_NewRequired" xml:space="preserve">
    <value>"{0}" oculta o membro herdado "{1}". Use a nova palavra-chave se foi pretendido ocultar.</value>
  </data>
  <data name="XML_InvalidUnicodeChar" xml:space="preserve">
    <value>Caractere unicode inválido.</value>
  </data>
  <data name="ERR_BadRefReturnExpressionTree" xml:space="preserve">
    <value>Expressões lambda que retornam por referência não podem ser convertidas para árvores de expressão</value>
  </data>
  <data name="ERR_TupleElementNamesAttributeMissing" xml:space="preserve">
    <value>Não é possível definir uma classe ou membro que utiliza tuplas porque o tipo '{0}' necessário de compilador não pode ser localizado. Uma referência está ausente?</value>
  </data>
  <data name="ERR_PublicKeyFileFailure" xml:space="preserve">
    <value>Erro ao assinar a saída com a chave pública do arquivo "{0}" -- {1}</value>
  </data>
  <data name="ERR_RefValBoundWithClass" xml:space="preserve">
    <value>"{0}": não é possível especificar uma classe de restrição e a restrição "class" ou "struct"</value>
  </data>
  <data name="ERR_BadUsingType" xml:space="preserve">
    <value>Uma diretiva de 'usando estático' pode apenas ser aplicada a tipos; '{0}' é um namespace, não um tipo. Considere uma diretiva 'usando namespace'</value>
  </data>
  <data name="ERR_BadDynamicMethodArgLambda" xml:space="preserve">
    <value>Não é possível usar uma expressão lambda como um argumento para uma operação despachada dinamicamente sem primeiro convertê-la para um tipo delegate ou de árvore de expressão.</value>
  </data>
  <data name="ERR_MustHaveRefReturn" xml:space="preserve">
    <value>Retornos by-value podem ser usados somente em métodos que retornam um valor</value>
  </data>
  <data name="ERR_InvalidFwdType" xml:space="preserve">
    <value>Tipo inválido especificado como argumento para o atributo TypeForwardedTo</value>
  </data>
  <data name="ERR_DelegateOnConditional" xml:space="preserve">
    <value>Não é possível criar representante com "{0}" porque ele ou um método que substitui tem um atributo Conditional</value>
  </data>
  <data name="ERR_DefaultLiteralNotValid" xml:space="preserve">
    <value>O uso do literal padrão não é válido neste contexto</value>
  </data>
  <data name="ERR_NoImplicitConvCast" xml:space="preserve">
    <value>Não é possível converter implicitamente tipo "{0}" em "{1}". Existe uma conversão explícita (há uma conversão ausente?)</value>
  </data>
  <data name="WRN_AnalyzerCannotBeCreated" xml:space="preserve">
    <value>Uma instância do analisador de {0} não pode ser criada de {1} : {2}.</value>
  </data>
  <data name="WRN_DuplicateUsing_Title" xml:space="preserve">
    <value>Usando diretiva exibida anteriormente neste namespace</value>
  </data>
  <data name="WRN_BadXMLRef_Title" xml:space="preserve">
    <value>O comentário XML possui um atributo cref que não pode ser resolvido</value>
  </data>
  <data name="ERR_ExplicitTupleElementNamesAttribute" xml:space="preserve">
    <value>Não é possível fazer referência a 'System.Runtime.CompilerServices.TupleElementNamesAttribute' explicitamente. Use a sintaxe de tupla para definir os nomes das tuplas.</value>
  </data>
  <data name="WRN_FilterIsConstant_Title" xml:space="preserve">
    <value>Expressão de filtro é uma constante</value>
  </data>
  <data name="WRN_InvalidNumber" xml:space="preserve">
    <value>Número inválido</value>
  </data>
  <data name="ERR_BadDelArgCount" xml:space="preserve">
    <value>Delegado "{0}" não obtém {1} argumentos</value>
  </data>
  <data name="ERR_HidingAbstractMethod" xml:space="preserve">
    <value>"{0}" oculta membro abstrato herdado "{1}"</value>
  </data>
  <data name="ERR_DuplicateTypeParameter" xml:space="preserve">
    <value>Duplicar atributo de tipo "{0}"</value>
  </data>
  <data name="ERR_EventPropertyInInterface" xml:space="preserve">
    <value>O evento em uma interface não pode ter acessadores add e remove</value>
  </data>
  <data name="WRN_DeprecatedCollectionInitAddStr_Title" xml:space="preserve">
    <value>O melhor método Add sobrecarregado para o elemento do inicializador de coleta está obsoleto</value>
  </data>
  <data name="WRN_ConflictingChecksum" xml:space="preserve">
    <value>Valores diferentes de checksum fornecidos para "{0}"</value>
  </data>
  <data name="ERR_EventNotDelegate" xml:space="preserve">
    <value>"{0}": evento deve ser de um tipo delegado</value>
  </data>
  <data name="ERR_EmptyYield" xml:space="preserve">
    <value>Expressão esperada após yield return</value>
  </data>
  <data name="ERR_SourceLinkRequiresPdb" xml:space="preserve">
    <value>A opção /sourcelink tem suporte apenas ao emitir o PDB.</value>
  </data>
  <data name="ERR_SecurityAttributeMissingAction" xml:space="preserve">
    <value>Primeiro argumento para um atributo de segurança deve ser uma SecurityAction válida</value>
  </data>
  <data name="ERR_TypeVarNotFoundRangeVariable" xml:space="preserve">
    <value>A palavra-chave contextual 'var' não pode ser usada em uma declaração de variável de intervalo</value>
  </data>
  <data name="ERR_BadExternIdentifier" xml:space="preserve">
    <value>Alias extern inválido para "/reference"; "{0}" não é um identificador válido</value>
  </data>
  <data name="WRN_NewOrOverrideExpected_Title" xml:space="preserve">
    <value>O membro oculta o membro herdado; palavra-chave substituta ausente</value>
  </data>
  <data name="ERR_StructOffsetOnBadStruct" xml:space="preserve">
    <value>O atributo FieldOffset só pode ser colocado em membros de tipos marcados com StructLayout(LayoutKind.Explicit)</value>
  </data>
  <data name="WRN_DuplicateParamTag_Title" xml:space="preserve">
    <value>O comentário XML tem uma marca param duplicada</value>
  </data>
  <data name="IDS_SK_TYPE" xml:space="preserve">
    <value>tipo</value>
  </data>
  <data name="ERR_GenericArgIsStaticClass" xml:space="preserve">
    <value>"{0}": tipos estáticos não podem ser usados como argumentos de tipo</value>
  </data>
  <data name="ERR_ThrowMisplaced" xml:space="preserve">
    <value>Uma expressão throw não é permitida neste contexto.</value>
  </data>
  <data name="WRN_CallerLineNumberParamForUnconsumedLocation" xml:space="preserve">
    <value>O CallerLineNumberAttribute aplicado ao parâmetro "{0}" não terá efeito porque ele se aplica a um membro que é usado em contextos que não permitem argumentos opcionais</value>
  </data>
  <data name="ERR_OvlBinaryOperatorExpected" xml:space="preserve">
    <value>Operador binário que pode ser sobrecarregado é esperado</value>
  </data>
  <data name="ERR_ImplicitlyTypedArrayNoBestType" xml:space="preserve">
    <value>Não foi encontrado nenhum tipo melhor para a matriz do tipo implícita</value>
  </data>
  <data name="XML_InvalidWhitespace" xml:space="preserve">
    <value>Espaço em branco não é permitido neste local.</value>
  </data>
  <data name="WRN_UnprocessedXMLComment" xml:space="preserve">
    <value>O comentário XML não está inserido em um elemento de linguagem válido</value>
  </data>
  <data name="ERR_NegativeStackAllocSize" xml:space="preserve">
    <value>Não é possível usar um tamanho negativo com stackalloc</value>
  </data>
  <data name="ERR_SwitchNeedsString" xml:space="preserve">
    <value>Erro de sintaxe de linha de comando: "{0}" ausente para a opção "{1}"</value>
  </data>
  <data name="ERR_UnsafeNeeded" xml:space="preserve">
    <value>Ponteiros e buffers de tamanho fixo só podem ser usados em um contexto sem segurança</value>
  </data>
  <data name="WRN_CLS_OverloadUnnamed_Title" xml:space="preserve">
    <value>O método sobrecarregado diferindo somente pelos tipos de matriz sem nome não tem conformidade com CLS</value>
  </data>
  <data name="ERR_ErrorBuildingWin32Resources" xml:space="preserve">
    <value>Erro ao compliar recursos do Win32 -- {0}</value>
  </data>
  <data name="ERR_PartialMethodInExpressionTree" xml:space="preserve">
    <value>Os métodos parciais com apenas uma declaração de definição ou métodos condicionais removidos não podem ser usados em árvores de expressão</value>
  </data>
  <data name="ERR_TupleInferredNamesNotAvailable" xml:space="preserve">
    <value>O nome do elemento de tupla '{0}' é deduzido. Use a versão de idioma {1} ou posterior para acessar um elemento pelo nome deduzido.</value>
  </data>
  <data name="WRN_BadRefCompareRight" xml:space="preserve">
    <value>Comparação de referência não intencional possível; para obter uma comparação de valor, converta o lado direito no tipo "{0}"</value>
  </data>
  <data name="WRN_DuplicateTypeParamTag_Title" xml:space="preserve">
    <value>O comentário XML tem uma marca typeparam duplicada</value>
  </data>
  <data name="ERR_AssemblyMatchBadVersion" xml:space="preserve">
    <value>Assembly "{0}" com identidade "{1}" usa "{2}" que tem uma versão mais recente do que o assembly referenciado "{3}" com identidade "{4}"</value>
  </data>
  <data name="ERR_HasNoTypeVars" xml:space="preserve">
    <value>O {1} não genérico "{0}" não pode ser usado como argumentos de tipo</value>
  </data>
  <data name="ERR_ReservedAssemblyName" xml:space="preserve">
    <value>O nome do assembly "{0}" é reservado e não pode ser usado como uma referência em uma sessão interativa</value>
  </data>
  <data name="WRN_EqualityOpWithoutEquals_Title" xml:space="preserve">
    <value>O tipo define os operadores == ou !=, mas não substitui o Object.Equals(object o)</value>
  </data>
  <data name="ERR_CantChangeTypeOnOverride" xml:space="preserve">
    <value>"{0}": tipo deve ser "{2}" para corresponder ao membro substituído "{1}"</value>
  </data>
  <data name="WRN_BitwiseOrSignExtend" xml:space="preserve">
    <value>Operador OR bit a bit usado em um operando de assinatura estendida; é recomendável realizar a conversão em um tipo menor sem assinatura primeiro</value>
  </data>
  <data name="ERR_FixedBufferNotFixed" xml:space="preserve">
    <value>Você não pode usar buffers de tamanho fixo contidos em expressões unfixed. Tente usar a instrução fixed.</value>
  </data>
  <data name="ERR_InvalidAddrOp" xml:space="preserve">
    <value>Não é possível obter o endereço da expressão especificada</value>
  </data>
  <data name="ERR_FeatureNotValidInExpressionTree" xml:space="preserve">
    <value>Uma árvore de expressão não pode conter "{0}"</value>
  </data>
  <data name="ERR_DefaultValueUsedWithAttributes" xml:space="preserve">
    <value>Não é possível especificar um valor de parâmetro padrão junto com DefaultParameterAttribute ou OptionalAttribute</value>
  </data>
  <data name="ERR_MissingDeconstruct" xml:space="preserve">
    <value>Nenhuma instância nem método de extensão de Desconstrução foi localizado para o tipo '{0}' com {1} parâmetros de saída e um tipo de retorno nulo.</value>
  </data>
  <data name="ERR_BadExtensionAgg" xml:space="preserve">
    <value>O método de extensão deve ser definido em uma classe estática não genérica</value>
  </data>
  <data name="ERR_NotNullConstRefField" xml:space="preserve">
    <value>"{0}" é do tipo "{1}". Um campo const de um tipo de referência diferente de cadeia de caracteres pode somente ser inicializado com null.</value>
  </data>
  <data name="ERR_NewBoundWithVal" xml:space="preserve">
    <value>A restrição 'new()' não pode ser usada com a restrição 'struct'</value>
  </data>
  <data name="ERR_VarargsAsync" xml:space="preserve">
    <value>__arglist não é permitido na lista de parâmetros dos métodos assíncronos</value>
  </data>
  <data name="ERR_ExplicitExtension" xml:space="preserve">
    <value>Não use "System.Runtime.CompilerServices.ExtensionAttribute". Em vez disso, use a palavra-chave "this".</value>
  </data>
  <data name="ERR_AddOrRemoveExpected" xml:space="preserve">
    <value>Acessador add ou remove esperado</value>
  </data>
  <data name="ERR_BadDelegateLeave" xml:space="preserve">
    <value>O controle não pode sair do corpo de um método anônimo ou expressão lambda</value>
  </data>
  <data name="WRN_ObsoleteOverridingNonObsolete_Title" xml:space="preserve">
    <value>O membro obsoleto substitui o membro não obsoleto</value>
  </data>
  <data name="ERR_ClassBoundNotFirst" xml:space="preserve">
    <value>A restrição de tipo de classe "{0}" deve vir antes de qualquer outra restrição</value>
  </data>
  <data name="ERR_CantChangeRefReturnOnOverride" xml:space="preserve">
    <value>'{0}' deve {2}retornar por referência para corresponder a um membro substituído '{1}'</value>
  </data>
  <data name="WRN_CallerLineNumberPreferredOverCallerFilePath_Title" xml:space="preserve">
    <value>O CallerFilePathAttribute não terá nenhum efeito; ele é substituído pelo CallerLineNumberAttribute</value>
  </data>
  <data name="ERR_NameofExtensionMethod" xml:space="preserve">
    <value>Grupos de métodos de extensão não são permitidos como um argumento para 'nameof'.</value>
  </data>
  <data name="ERR_InitializeByValueVariableWithReference" xml:space="preserve">
    <value>Não é possível inicializar uma variável by-value com uma referência</value>
  </data>
  <data name="ERR_NoSuchMemberOrExtension" xml:space="preserve">
    <value>"{0}" não contém uma definição para "{1}" e não foi possível encontrar nenhum método de extensão "{1}" que aceite um primeiro argumento do tipo "{0}" (há uma diretiva de uso ou referência de assembly ausente?)</value>
  </data>
  <data name="ERR_TypeArgsNotAllowed" xml:space="preserve">
    <value>O {1} "{0}" não pode ser usado com argumentos de tipo</value>
  </data>
  <data name="ERR_PartialMethodOnlyOneLatent" xml:space="preserve">
    <value>Um método parcial não pode ter várias declarações de definição</value>
  </data>
  <data name="ERR_InvalidAssemblyName" xml:space="preserve">
    <value>Referência do assembly "{0}" é inválida e não pode ser resolvida</value>
  </data>
  <data name="ERR_ConstructorInStaticClass" xml:space="preserve">
    <value>Classes static não podem ter construtores de instância</value>
  </data>
  <data name="ERR_BadAwaitArg" xml:space="preserve">
    <value>"await" requer que o tipo {0} tenha um método GetAwaiter adequado</value>
  </data>
  <data name="ERR_MemberReserved" xml:space="preserve">
    <value>Tipo "{1}" já reserva um membro chamado "{0}" com os mesmos tipos de parâmetro</value>
  </data>
  <data name="WRN_CLS_BadArgType_Title" xml:space="preserve">
    <value>Tipo de argumento não tem conformidade com CLS</value>
  </data>
  <data name="ERR_IllegalEscape" xml:space="preserve">
    <value>Sequência de escape não reconhecida</value>
  </data>
  <data name="WRN_MissingParamTag_Title" xml:space="preserve">
    <value>O parâmetro não tem nenhuma marca param correspondente no comentário XML (mas outros parâmetros têm)</value>
  </data>
  <data name="ERR_CycleInInterfaceInheritance" xml:space="preserve">
    <value>Interface herdada "{1}" gera um ciclo na hierarquia de interface de "{0}"</value>
  </data>
  <data name="ERR_GlobalSingleTypeNameNotFound" xml:space="preserve">
    <value>O tipo ou nome do namespace "{0}" não pode ser encontrado no namespace global (uma referência de assembly está faltando?)</value>
  </data>
  <data name="ERR_BadAwaitInCatchFilter" xml:space="preserve">
    <value>Não é possível aguardar na expressão do filtro de uma cláusula catch</value>
  </data>
  <data name="ERR_ArrayInitToNonArrayType" xml:space="preserve">
    <value>Só é possível usar expressões de inicializador de matriz para atribuir a tipos de matriz. Tente usar uma expressão new.</value>
  </data>
  <data name="ERR_ImplicitlyTypedVariableWithNoInitializer" xml:space="preserve">
    <value>Variáveis de tipo implícito devem ser inicializadas</value>
  </data>
  <data name="ERR_TypeParamMustBeIdentifier" xml:space="preserve">
    <value>A declaração de parâmetro de tipo deve ser um identificador, e não um tipo</value>
  </data>
  <data name="ERR_ProtectedInStruct" xml:space="preserve">
    <value>"{0}": novo membro protegido declarado em struct</value>
  </data>
  <data name="ERR_ProtectedInStatic" xml:space="preserve">
    <value>"{0}": classes static não podem conter membros protegidos</value>
  </data>
  <data name="ERR_InstanceMemberInStaticClass" xml:space="preserve">
    <value>"{0}": não pode declarar membros de instância em uma classe estática</value>
  </data>
  <data name="ERR_InvalidAssemblyCultureForExe" xml:space="preserve">
    <value>Executáveis não podem ser assemblies satélites; cultura deve estar sempre vazia</value>
  </data>
  <data name="ERR_BaseIllegal" xml:space="preserve">
    <value>O uso da palavra-chave "base" não é válido neste contexto</value>
  </data>
  <data name="ERR_NoTypeDef" xml:space="preserve">
    <value>O tipo "{0}" está definido em um assembly que não é referenciado. Você deve adicionar uma referência ao assembly "{1}".</value>
  </data>
  <data name="ERR_ExplicitPropertyAddingAccessor" xml:space="preserve">
    <value>"{0}" adiciona um assessor não encontrado no membro de interface "{1}"</value>
  </data>
  <data name="ERR_BadSwitch" xml:space="preserve">
    <value>Opção não reconhecida: "{0}"</value>
  </data>
  <data name="ERR_SecurityCriticalOrSecuritySafeCriticalOnAsyncInClassOrStruct" xml:space="preserve">
    <value>Métodos assíncronos não são permitidos em uma Interface, Classe ou Estrutura que tem o atributo "SecurityCritical" ou "SecuritySafeCritical".</value>
  </data>
  <data name="ERR_LambdaInIsAs" xml:space="preserve">
    <value>O primeiro operando de um operador "is" ou "as" não pode ser uma expressão lambda, um método anônimo ou um grupo de métodos.</value>
  </data>
  <data name="ERR_NamedArgumentForArray" xml:space="preserve">
    <value>Um acesso à matriz não pode ter um especificador de argumento nomeado</value>
  </data>
  <data name="ERR_BadDynamicMethodArgMemgrp" xml:space="preserve">
    <value>Não é possível usar um grupo de métodos como um argumento para uma operação dinamicamente despachada. Você pretendia invocar o método?</value>
  </data>
  <data name="ERR_RefReadonly" xml:space="preserve">
    <value>Um campo somente leitura não pode ser usado como um valor ref ou out (exceto em um construtor)</value>
  </data>
  <data name="InvalidGetDeclarationNameMultipleDeclarators" xml:space="preserve">
    <value>GetDeclarationName chamado para um nó de declaração que possivelmente pode conter múltiplos declaradores variáveis.</value>
  </data>
  <data name="WRN_CLS_OverloadUnnamed_Description" xml:space="preserve">
    <value>Este erro ocorre se você tiver um método sobrecarregado que usa uma matriz denteada e a única diferença entre as assinaturas do método é o tipo de elemento da matriz. Para evitar esse erro, considere usar uma matriz retangular em vez de uma matriz denteada, usar um parâmetro adicional para desambiguar a chamada de função, renomear um ou mais dos métodos sobrecarregados ou, se não for necessária conformidade com CLS, remova o atributo CLSCompliantAttribute.</value>
  </data>
  <data name="ERR_ImplBadTupleNames" xml:space="preserve">
    <value>Os nomes de elemento de tupla na assinatura do método '{0}' devem corresponder aos nomes de elemento de tupla do método de interface '{1}' (incluindo o tipo de retorno).</value>
  </data>
  <data name="ERR_DuplicateAttributeInNetModule" xml:space="preserve">
    <value>Duplicar atributo "{0}" em "{1}"</value>
  </data>
  <data name="IDS_FeatureAsync" xml:space="preserve">
    <value>função assíncrona</value>
  </data>
  <data name="ERR_InvalidDebugInformationFormat" xml:space="preserve">
    <value>Formato de informações de depuração inválidas: {0}</value>
  </data>
  <data name="WRN_DefaultInSwitch" xml:space="preserve">
    <value>Você pretendia usar o rótulo de switch padrão (`default:`) em vez de `case default:`? Caso realmente pretenda utilizar o valor literal padrão, considere `case (default):` ou outro valor literal (`case 0:` ou `case null:`) conforme apropriado.</value>
  </data>
  <data name="ERR_UnsafeAsyncArgType" xml:space="preserve">
    <value>Os métodos assíncronos não podem ter parâmetros ou tipos de retorno sem segurança</value>
  </data>
  <data name="WRN_NonObsoleteOverridingObsolete_Title" xml:space="preserve">
    <value>O membro substitui o membro obsoleto</value>
  </data>
  <data name="ERR_BadAsyncLocalType" xml:space="preserve">
    <value>Os métodos assíncronos não podem ter locais por referência</value>
  </data>
  <data name="ERR_InitializerOnNonAutoProperty" xml:space="preserve">
    <value>Somente propriedades implementadas automaticamente podem ter inicializadores.</value>
  </data>
  <data name="FTL_OutputFileExists" xml:space="preserve">
    <value>Não é possível criar nome de arquivo curto "{0}" quando já existe um nome de arquivo longo com o mesmo nome de arquivo curto</value>
  </data>
  <data name="WRN_WarningDirective" xml:space="preserve">
    <value>#warning: "{0}"</value>
  </data>
  <data name="ERR_StaticNotVirtual" xml:space="preserve">
    <value>Um membro estático "{0}" não pode ser marcado como override, virtual ou abstract</value>
  </data>
  <data name="ERR_AssgLvalueExpected" xml:space="preserve">
    <value>O lado esquerdo de uma atribuição deve ser uma variável, uma propriedade ou um indexador</value>
  </data>
  <data name="ERR_OverrideNotNew" xml:space="preserve">
    <value>Um membro "{0}" marcado como override não pode ser marcado como new ou virtual</value>
  </data>
  <data name="ERR_PartialMethodInconsistentTupleNames" xml:space="preserve">
    <value>Ambas as declarações de método parciais, '{0}' e '{1}', devem usar os mesmos elementos de nome de tupla.</value>
  </data>
  <data name="ERR_RefReturnStructThis" xml:space="preserve">
    <value>Membros struct não podem retornar 'this' ou outros membros de instância por referência</value>
  </data>
  <data name="ERR_ReturnExpected" xml:space="preserve">
    <value>"{0}": nem todos os caminhos de código retornam um valor</value>
  </data>
  <data name="ERR_PatternIsSubsumed" xml:space="preserve">
    <value>O caso do switch já foi manipulado por um caso anterior.</value>
  </data>
  <data name="ERR_ForwardedTypeIsNested" xml:space="preserve">
    <value>Não é possível encaminhar o tipo "{0}" porque ele é um tipo aninhado de "{1}"</value>
  </data>
  <data name="ERR_EndOfPPLineExpected" xml:space="preserve">
    <value>Comentário de linha única ou final de linha esperado</value>
  </data>
  <data name="ERR_DynamicTypeAsBound" xml:space="preserve">
    <value>A restrição não pode ser o tipo dinâmico</value>
  </data>
  <data name="ERR_ParamUnassigned" xml:space="preserve">
    <value>O parâmetro out "{0}" deve ser atribuído antes que o controle saia do método atual</value>
  </data>
  <data name="WRN_DefineIdentifierRequired_Title" xml:space="preserve">
    <value>Nome inválido para um símbolo de pré-processamento; ele não é um identificador válido</value>
  </data>
  <data name="WRN_LowercaseEllSuffix" xml:space="preserve">
    <value>O sufixo 'l' é facilmente confundido com o dígito '1' -- use 'L' para diferenciar</value>
  </data>
  <data name="ERR_ExplicitInterfaceImplementationNotInterface" xml:space="preserve">
    <value>"{0}" na declaração de interface explícita não é uma interface</value>
  </data>
  <data name="ERR_CantOverrideBogusMethod" xml:space="preserve">
    <value>"{0}": não é possível substituir "{1}" porque não é suportado pelo idioma</value>
  </data>
  <data name="ERR_NonInvocableMemberCalled" xml:space="preserve">
    <value>O membro não invocável "{0}" não pode ser usado como um método.</value>
  </data>
  <data name="ERR_RefLvalueExpected" xml:space="preserve">
    <value>Um valor ref ou out deve ser uma variável que possa ser atribuída</value>
  </data>
  <data name="SyntaxTreeSemanticModelMust" xml:space="preserve">
    <value>SyntaxTreeSemanticModel deve ser fornecido para fornecer a qualificação do tipo mínimo.</value>
  </data>
  <data name="ERR_NoTypeDefFromModule" xml:space="preserve">
    <value>O tipo "{0}" está definido em um módulo não foi adicionado. Você deve adicionar o módulo "{1}".</value>
  </data>
  <data name="ERR_SameFullNameNsAgg" xml:space="preserve">
    <value>O namespace "{1}" em "{0}" está em conflito com o tipo "{3}" em "{2}"</value>
  </data>
  <data name="ERR_StaticConstParam" xml:space="preserve">
    <value>"{0}": um construtor estático não deve ter parâmetros</value>
  </data>
  <data name="ERR_InAttrOnOutParam" xml:space="preserve">
    <value>Um parâmetro out não pode ter atributo In</value>
  </data>
  <data name="IDS_MethodGroup" xml:space="preserve">
    <value>grupo de métodos</value>
  </data>
  <data name="WRN_UnassignedInternalField_Title" xml:space="preserve">
    <value>O campo nunca é atribuído e sempre terá seu valor padrão</value>
  </data>
  <data name="ERR_BadThisParam" xml:space="preserve">
    <value>Método "{0}" tem um modificador de parâmetro "this" que não está no primeiro parâmetro</value>
  </data>
  <data name="XML_StringLiteralNonAsciiQuote" xml:space="preserve">
    <value>Aspas não ASCII não podem ser usadas em literais de cadeia de caracteres.</value>
  </data>
  <data name="ERR_NoBaseClass" xml:space="preserve">
    <value>Uma classe base é necessária para uma referência "base"</value>
  </data>
  <data name="ERR_UnexpectedDirective" xml:space="preserve">
    <value>Diretiva de pré-processamento inesperada</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnPrivateType" xml:space="preserve">
    <value>Verificação de compatibilidade com CLS não será executada em "{0}" porque ele não é visível de fora deste assembly</value>
  </data>
  <data name="ERR_CantOverrideNonProperty" xml:space="preserve">
    <value>"{0}": não é possível substituir porque "{1}" não é uma propriedade</value>
  </data>
  <data name="ERR_PatternWrongGenericTypeInVersion" xml:space="preserve">
    <value>Uma expressão do tipo '{0}' não pode ser manipulada por um padrão do tipo '{1}' em C# {2}. Use a versão de linguagem {3} ou superior.</value>
  </data>
  <data name="WRN_UnreferencedVarAssg" xml:space="preserve">
    <value>A variável "{0}" é atribuída, mas seu valor nunca é usado</value>
  </data>
  <data name="ERR_TupleReservedElementName" xml:space="preserve">
    <value>O nome do elemento de tupla '{0}' é permitido somente na posição {1}.</value>
  </data>
  <data name="ERR_BadMemberProtection" xml:space="preserve">
    <value>Mais de um modificador de proteção</value>
  </data>
  <data name="WRN_BadXMLRefSyntax" xml:space="preserve">
    <value>O comentário XML tem atributo cref sintaticamente incorreto "{0}"</value>
  </data>
  <data name="ERR_BindToBogus" xml:space="preserve">
    <value>O idioma não dá suporte a "{0}"</value>
  </data>
  <data name="WRN_UnmatchedParamRefTag_Title" xml:space="preserve">
    <value>O comentário XML tem uma marca paramref, mas não há nenhum parâmetro com esse nome</value>
  </data>
  <data name="ERR_BadAwaitWithoutVoidAsyncMethod" xml:space="preserve">
    <value>O operador 'await' só pode ser usado em um método assíncrono. Considere marcar esse método com o modificador 'async' e alterar seu tipo de retorno para 'Task'.</value>
  </data>
  <data name="ERR_EncUpdateFailedMissingAttribute" xml:space="preserve">
    <value>Não é possível atualizar '{0}'; o atributo '{1}' está ausente.</value>
  </data>
  <data name="WRN_ProtectedInSealed" xml:space="preserve">
    <value>"{0}": novo membro protegido declarado na classe sealed</value>
  </data>
  <data name="ERR_SwitchFallThrough" xml:space="preserve">
    <value>Controle não pode passar através de um rótulo case ("{0}") para outro</value>
  </data>
  <data name="ERR_AnonMethToNonDel" xml:space="preserve">
    <value>Não é possível converter {0} para o tipo "{1}" porque ele não é um tipo delegado</value>
  </data>
  <data name="ERR_StatementLambdaToExpressionTree" xml:space="preserve">
    <value>Uma expressão lambda com um corpo de instrução não pode ser convertida em uma árvore de expressões</value>
  </data>
  <data name="IDS_ToolName" xml:space="preserve">
    <value>Compilador do Microsoft (R) Visual C#</value>
  </data>
  <data name="ERR_NoExplicitBuiltinConv" xml:space="preserve">
    <value>Não é possível converter tipo "{0}" para "{1}" por meio de uma conversão de referência, conversão boxing, conversão unboxing ou conversão de tipo nulo</value>
  </data>
  <data name="ERR_PtrIndexSingle" xml:space="preserve">
    <value>Um ponteiro deve ser indexado somente por um valor</value>
  </data>
  <data name="WRN_BadWarningNumber_Title" xml:space="preserve">
    <value>Este não um número de aviso válido</value>
  </data>
  <data name="IDS_FeatureRefLocalsReturns" xml:space="preserve">
    <value>retornos e locais de byref</value>
  </data>
  <data name="ERR_DynamicLocalFunctionParamsParameter" xml:space="preserve">
    <value>Não é possível passar argumento com tipo dinâmico para parâmetro params '{0}' da função local '{1}'.</value>
  </data>
  <data name="ERR_InteropMethodWithBody" xml:space="preserve">
    <value>Método de interoperabilidade inserido "{0}" contém um corpo.</value>
  </data>
  <data name="WRN_DeprecatedCollectionInitAdd" xml:space="preserve">
    <value>O melhor método Add sobrecarregado "{0}" para o elemento do inicializador de coleção está obsoleto.</value>
  </data>
  <data name="IDS_FeatureDynamic" xml:space="preserve">
    <value>dinâmica</value>
  </data>
  <data name="ERR_VariableUsedBeforeDeclarationAndHidesField" xml:space="preserve">
    <value>Não é possível usar a variável local "{0}" antes de declará-la. A declaração da variável local oculta o campo "{1}".</value>
  </data>
  <data name="ERR_PPDefFollowsToken" xml:space="preserve">
    <value>Não é possível definir nem remover os símbolos de pré-processamento após o primeiro token no arquivo</value>
  </data>
  <data name="ERR_MutuallyExclusiveOptions" xml:space="preserve">
    <value>As opções de compilação '{0}' e '{1}' não podem ser especificadas ao mesmo tempo.</value>
  </data>
  <data name="WRN_CallerMemberNameParamForUnconsumedLocation_Title" xml:space="preserve">
    <value>O CallerMemberNameAttribute não tem efeito porque ele se aplica a um membro que é usado em contextos que não aceitam argumentos opcionais</value>
  </data>
  <data name="ERR_CheckedOverflow" xml:space="preserve">
    <value>A operação estoura o tempo de compilação no modo de ativação</value>
  </data>
  <data name="IDS_FeatureGlobalNamespace" xml:space="preserve">
    <value>qualificador alias de namespace</value>
  </data>
  <data name="ERR_BadEmptyThrow" xml:space="preserve">
    <value>Uma instrução throw sem argumentos não é permitida fora de uma cláusula catch</value>
  </data>
  <data name="WRN_UnreferencedEvent" xml:space="preserve">
    <value>O evento "{0}" nunca é usado</value>
  </data>
  <data name="WRN_UnprocessedXMLComment_Title" xml:space="preserve">
    <value>O comentário XML não está inserido em um elemento de linguagem válido</value>
  </data>
  <data name="ERR_DocFileGen" xml:space="preserve">
    <value>Erro gravando no arquivo de documentação XML: {0}</value>
  </data>
  <data name="IDS_FeatureGenerics" xml:space="preserve">
    <value>genéricos</value>
  </data>
  <data name="WRN_CoClassWithoutComImport" xml:space="preserve">
    <value>"{0}" interface marcada com "CoClassAttribute" não marcada com "ComImportAttribute"</value>
  </data>
  <data name="ERR_RefReadonlyLocal2Cause" xml:space="preserve">
    <value>Não é possível usar campos de '{0}' como um valor ref ou out porque ele é um '{1}'</value>
  </data>
  <data name="ERR_UseDefViolationProperty" xml:space="preserve">
    <value>Uso de propriedades autoimplementadas possivelmente não atribuídas '{0}'</value>
  </data>
  <data name="WRN_UnreferencedField" xml:space="preserve">
    <value>O campo "{0}" nunca é usado</value>
  </data>
  <data name="WRN_UnreferencedLabel" xml:space="preserve">
    <value>Este rótulo não foi usado como referência</value>
  </data>
  <data name="ERR_DuplicateNamedAttributeArgument" xml:space="preserve">
    <value>"{0}" duplicar argumento de atributo nomeado</value>
  </data>
  <data name="ERR_MethodArgCantBeRefAny" xml:space="preserve">
    <value>Não é possível fazer referência à variável do tipo "{0}"</value>
  </data>
  <data name="ERR_BadAwaitWithoutAsync" xml:space="preserve">
    <value>O operador 'await' só poderá ser usado quando contido em um método ou expressão lambda marcada com o modificador 'async'</value>
  </data>
  <data name="ERR_ExpressionTreeContainsTupleLiteral" xml:space="preserve">
    <value>Uma árvore de expressão não pode conter um literal de tupla.</value>
  </data>
  <data name="WRN_ComparisonToSelf_Title" xml:space="preserve">
    <value>Comparação feita com a mesma variável</value>
  </data>
  <data name="ERR_BadDynamicMethodArgDefaultLiteral" xml:space="preserve">
    <value>Não é possível usar um padrão literal como um argumento para uma operação dinamicamente expedida.</value>
  </data>
  <data name="ERR_ObjectOrCollectionInitializerWithDelegateCreation" xml:space="preserve">
    <value>As expressões de objeto e de inicializador de coleção não podem ser aplicadas a uma expressão de criação de representante</value>
  </data>
  <data name="WRN_DuplicateTypeParamTag" xml:space="preserve">
    <value>O comentário XML tem uma marca typeparam duplicada para "{0}"</value>
  </data>
  <data name="ERR_ConversionWithDerived" xml:space="preserve">
    <value>"{0}": conversões definidas pelo usuário para ou de uma classe derivada não são permitidas</value>
  </data>
  <data name="ERR_InvalidSpecifier" xml:space="preserve">
    <value>"{0}" não é um especificador de formato válido</value>
  </data>
  <data name="ERR_DuplicateImportSimple" xml:space="preserve">
    <value>Um assembly com o mesmo nome simples "{0}" já foi importado. Tente remover uma das referências (por exemplo: "{1}") ou assine-as para ativar lado a lado.</value>
  </data>
  <data name="ERR_BadAwaitInStaticVariableInitializer" xml:space="preserve">
    <value>O operador 'await' não pode ser usado em um inicializador de variável de script estático.</value>
  </data>
  <data name="ERR_ExplicitImplCollisionOnRefOut" xml:space="preserve">
    <value>Não é possível herdar a interface "{0}" com os parâmetros do tipo especificado porque isso faz com que o método "{1}" contenha sobrecargas que diferem somente em ref e out</value>
  </data>
  <data name="ERR_QueryOuterKey" xml:space="preserve">
    <value>O nome "{0}" não está no escopo à esquerda de "equals". Considere trocar as expressões em cada lado de "equals".</value>
  </data>
  <data name="ERR_NoConversionForCallerFilePathParam" xml:space="preserve">
    <value>CallerFilePathAttribute não pode ser aplicado porque não há conversões padrões do tipo "{0}" para o tipo "{1}"</value>
  </data>
  <data name="WRN_CLS_BadIdentifierCase" xml:space="preserve">
    <value>Identificador "{0}" diferindo somente se não tem conformidade com CLS</value>
  </data>
  <data name="ERR_BadVisPropertyType" xml:space="preserve">
    <value>Acessibilidade inconsistente: tipo de propriedade "{1}" é menos acessível do que a propriedade "{0}"</value>
  </data>
  <data name="ERR_CantOpenWin32Res" xml:space="preserve">
    <value>Erro ao abrir o arquivo de recursos do Win32 "{0}" -- "{1}"</value>
  </data>
  <data name="ERR_EmptyFormatSpecifier" xml:space="preserve">
    <value>Especificador de formato vazio.</value>
  </data>
  <data name="WRN_BitwiseOrSignExtend_Title" xml:space="preserve">
    <value>Bit a bit ou operador usado em um operando de assinatura estendida</value>
  </data>
  <data name="WRN_NubExprIsConstBool_Title" xml:space="preserve">
    <value>O resultado da expressão é sempre o mesmo, pois um valor deste tipo nunca é 'null' </value>
  </data>
  <data name="ERR_UnsupportedTransparentIdentifierAccess" xml:space="preserve">
    <value>Falha no acesso de membro de identificador transparente para o campo "{0}" de "{1}". Os dados que estão sendo consultados implementam o padrão de consulta?</value>
  </data>
  <data name="ERR_NoConversionForCallerLineNumberParam" xml:space="preserve">
    <value>CallerLineNumberAttribute não pode ser aplicado porque não há conversões padrões do tipo "{0}" para o tipo "{1}"</value>
  </data>
  <data name="ERR_ExternAliasNotAllowed" xml:space="preserve">
    <value>"alias externo" não é válido neste contexto</value>
  </data>
  <data name="ERR_NoPIANestedType" xml:space="preserve">
    <value>Tipo "{0}" não pode ser inserido porque ele é de um tipo aninhado. Considere configurar a propriedade "Inserir Tipos de Interoperabilidade" como falsa.</value>
  </data>
  <data name="WRN_CLS_NotOnModules2" xml:space="preserve">
    <value>Você não pode especificar o atributo CLSCompliant em um módulo diferente do atributo CLSCompliant no assembly</value>
  </data>
  <data name="WRN_ErrorOverride" xml:space="preserve">
    <value>{0}. Veja também o erro CS{1}.</value>
  </data>
  <data name="ERR_BadBaseType" xml:space="preserve">
    <value>Tipo base inválido</value>
  </data>
  <data name="ERR_DottedTypeNameNotFoundInAgg" xml:space="preserve">
    <value>O nome de tipo "{0}" não existe no tipo "{1}"</value>
  </data>
  <data name="IDS_XMLNOINCLUDE" xml:space="preserve">
    <value> Nenhum elemento correspondente foi encontrado na seguinte marca include </value>
  </data>
  <data name="ERR_FeatureIsExperimental" xml:space="preserve">
    <value>O recurso '{0}' é experimental e não tem suporte; use '/features:{1}' para habilitá-lo.</value>
  </data>
  <data name="WRN_EqualsWithoutGetHashCode_Title" xml:space="preserve">
    <value>O tipo substitui Object. Equals (objeto o), mas não substitui o Object.GetHashCode()</value>
  </data>
  <data name="WRN_GotoCaseShouldConvert_Title" xml:space="preserve">
    <value>O valor 'goto case' não é implicitamente conversível para o tipo da opção</value>
  </data>
  <data name="WRN_MissingXMLComment_Description" xml:space="preserve">
    <value>A opção de compilador /doc foi especificada, mas um ou mais construtores não tinha comentários.</value>
  </data>
  <data name="ERR_CantOverrideNonVirtual" xml:space="preserve">
    <value>"{0}": não é possível substituir o membro herdado "{1}" porque ele não está marcado como virtual, abstract ou override</value>
  </data>
  <data name="ERR_DuplicateParamName" xml:space="preserve">
    <value>O nome do parâmetro "{0}" é uma duplicata</value>
  </data>
  <data name="ERR_StaticConstructorWithAccessModifiers" xml:space="preserve">
    <value>"{0}": modificadores de acesso não são permitidos em construtores estáticos</value>
  </data>
  <data name="ERR_UnexpectedUnboundGenericName" xml:space="preserve">
    <value>Uso inesperado de um nome genérico não associado</value>
  </data>
  <data name="ERR_AccessorImplementingMethod" xml:space="preserve">
    <value>O acessador "{0}" não pode implementar membro de interface "{1}" para o tipo "{2}". Use uma implementação de interface explícita.</value>
  </data>
  <data name="ERR_PartialMethodExtensionDifference" xml:space="preserve">
    <value>As duas declarações de métodos parciais devem ser métodos de extensão ou nenhuma delas poderá ser desse tipo</value>
  </data>
  <data name="ERR_ExpectedEndTry" xml:space="preserve">
    <value>Catch ou finally esperado</value>
  </data>
  <data name="ERR_BadNewExpr" xml:space="preserve">
    <value>Uma expressão new requer (), [] ou {} após o tipo</value>
  </data>
  <data name="WRN_UnreferencedVar_Title" xml:space="preserve">
    <value>A variável foi declarada, mas nunca foi usada</value>
  </data>
  <data name="ERR_OpenEndedComment" xml:space="preserve">
    <value>Final do arquivo encontrado. '*/' esperado</value>
  </data>
  <data name="CantReferenceCompilationOf" xml:space="preserve">
    <value>Não é possível fazer referência a compilação do tipo "{0}" de {1} compilação.</value>
  </data>
  <data name="WRN_NewOrOverrideExpected" xml:space="preserve">
    <value>"{0}" oculta o membro herdado "{1}". Para que o membro atual substitua essa implementação, adicione a palavra-chave override. Caso contrário, adicione a palavra-chave new.</value>
  </data>
  <data name="ERR_CloseUnimplementedInterfaceMemberNotPublic" xml:space="preserve">
    <value>"{0}" não implementa membro de interface "{1}". "{2}" não pode implementar um membro de interface, pois não é público.</value>
  </data>
  <data name="WrongSemanticModelType" xml:space="preserve">
    <value>Espera-se um {0} SemanticModel.</value>
  </data>
  <data name="IDS_FeatureDefault" xml:space="preserve">
    <value>operador padrão</value>
  </data>
  <data name="ERR_ExpressionVariableInQueryClause" xml:space="preserve">
    <value>As declarações da variável de saída e da variável padrão não são permitidas em uma cláusula de consulta.</value>
  </data>
  <data name="ERR_VoidAssignment" xml:space="preserve">
    <value>Um valor do tipo 'void' não pode ser atribuído.</value>
  </data>
  <data name="IDS_FeatureDefaultLiteral" xml:space="preserve">
    <value>literal padrão</value>
  </data>
  <data name="ERR_PatternWrongType" xml:space="preserve">
    <value>Uma expressão do tipo '{0}' não pode ser manipulada por um padrão do tipo '{1}'.</value>
  </data>
  <data name="ERR_CantHaveWin32ResAndIcon" xml:space="preserve">
    <value>Opções conflitantes especificadas: arquivo de recursos do Win32; ícone do Win32</value>
  </data>
  <data name="WRN_AttributeIgnoredWhenPublicSigning_Title" xml:space="preserve">
    <value>O atributo é ignorado quando a autenticação pública é especificada.</value>
  </data>
  <data name="ERR_QueryInnerKey" xml:space="preserve">
    <value>O nome "{0}" não está no escopo à direita de "equals". Considere trocar as expressões em cada lado de "equals".</value>
  </data>
  <data name="ERR_CantChangeTupleNamesOnOverride" xml:space="preserve">
    <value>'{0}': não pode alterar os nomes de elemento de tupla ao substituir o membro herdado '{1}'</value>
  </data>
  <data name="ERR_TooManyUserStrings" xml:space="preserve">
    <value>O comprimento combinado de cadeias do usuários usadas pelo programa excede o limite permitido. Tente diminuir o uso de literais de cadeia.</value>
  </data>
  <data name="ERR_LbraceExpected" xml:space="preserve">
    <value>{ esperado</value>
  </data>
  <data name="WRN_LowercaseEllSuffix_Title" xml:space="preserve">
    <value>O sufixo 'l'é facilmente confundido com o dígito '1'</value>
  </data>
  <data name="XML_ExpectedEndOfXml" xml:space="preserve">
    <value>Caractere inesperado neste local.</value>
  </data>
  <data name="XML_ExpectedEndOfTag" xml:space="preserve">
    <value>"&gt;" ou "/&gt;" está faltando para fechar a marca "{0}".</value>
  </data>
  <data name="WRN_MissingTypeParamTag_Title" xml:space="preserve">
    <value>O parâmetro de tipo não tem nenhuma marca typeparam correspondente no comentário XML (mas outros parâmetros têm)</value>
  </data>
  <data name="WRN_GlobalAliasDefn" xml:space="preserve">
    <value>A definição de um alias denominado 'global' não é recomendável, pois 'global::' sempre faz referência ao namespace global, e não a um alias</value>
  </data>
  <data name="WRN_CallerMemberNameParamForUnconsumedLocation" xml:space="preserve">
    <value>O CallerMemberNameAttribute aplicado ao parâmetro "{0}" não terá efeito porque ele se aplica a um membro que é usado em contextos que não permitem argumentos opcionais</value>
  </data>
  <data name="ERR_BadAttributeParamType" xml:space="preserve">
    <value>Parâmetro de construtor de atributo "{0}" tem tipo "{1}", o qual não é um tipo de parâmetro de atributo válido</value>
  </data>
  <data name="ERR_IllegalVarianceSyntax" xml:space="preserve">
    <value>Modificador de variação inválido. Apenas os parâmetros do tipo de representante e de interface podem ser especificados como variante.</value>
  </data>
  <data name="WRN_CLS_OverloadRefOut_Title" xml:space="preserve">
    <value>O método sobrecarregado diferindo somente em ref ou out, ou a classificação de matriz, não tem conformidade com CLS</value>
  </data>
  <data name="ERR_VolatileStruct" xml:space="preserve">
    <value>"{0}": um campo volátil não pode ser do tipo "{1}"</value>
  </data>
  <data name="ERR_BadStackAllocExpr" xml:space="preserve">
    <value>Uma expressão stackalloc requer [] após o tipo</value>
  </data>
  <data name="ERR_InvalidAnonymousTypeMemberDeclarator" xml:space="preserve">
    <value>Declarador de membro de tipo anônimo inválido. Membros de tipo anônimo devem ser declarados com uma atribuição de membro, nome simples ou acesso de membro.</value>
  </data>
  <data name="ERR_VoidInTuple" xml:space="preserve">
    <value>Uma tupla não pode conter um valor do tipo 'void'.</value>
  </data>
  <data name="ERR_OutAttrOnRefParam" xml:space="preserve">
    <value>Não é possível especificar somente o atributo Out em um parâmetro ref. Use ambos os atributos In e Out, ou nenhuma deles.</value>
  </data>
  <data name="WRN_FileAlreadyIncluded" xml:space="preserve">
    <value>Arquivo de origem "{0}" especificado várias vezes</value>
  </data>
  <data name="ERR_ValueTypePropertyInObjectInitializer" xml:space="preserve">
    <value>Membros da propriedade "{0}" do tipo "{1}" não podem ser atribuídos com um inicializador de objeto porque ele é de um tipo de valor</value>
  </data>
  <data name="ERR_StructWithBaseConstructorCall" xml:space="preserve">
    <value>"{0}": structs não podem chamar construtores de classe base</value>
  </data>
  <data name="WRN_PatternIsAmbiguous_Title" xml:space="preserve">
    <value>O tipo não implementa o padrão de coleção; os membros são ambíguos</value>
  </data>
  <data name="ERR_StackallocInCatchFinally" xml:space="preserve">
    <value>stackalloc não pode ser usado em um bloco catch ou finally</value>
  </data>
  <data name="XML_StringLiteralNoStartQuote" xml:space="preserve">
    <value>Um literal de cadeia de caracteres era esperado, mas nenhuma aspa de abertura foi encontrada.</value>
  </data>
  <data name="ERR_ExternHasBody" xml:space="preserve">
    <value>"{0}" não pode ser externo e declarar um corpo</value>
  </data>
  <data name="ERR_InvalidPreprocExpr" xml:space="preserve">
    <value>Expressão de pré-processamento inválida</value>
  </data>
  <data name="ERR_ThisInBadContext" xml:space="preserve">
    <value>A palavra-chave 'this' não está disponível no contexto atual</value>
  </data>
  <data name="SyntaxTreeFromLoadNoRemoveReplace" xml:space="preserve">
    <value>A SyntaxTree "{0}" é resultado de uma diretiva #load, e não é permitido removê-la nem substituí-la diretamente.</value>
  </data>
  <data name="WRN_IllegalPragma" xml:space="preserve">
    <value>Diretiva #pragma não reconhecida</value>
  </data>
  <data name="ERR_AnonymousTypeDuplicatePropertyName" xml:space="preserve">
    <value>Um tipo anônimo não pode ter várias propriedades com o mesmo nome</value>
  </data>
  <data name="ERR_MetadataNameTooLong" xml:space="preserve">
    <value>Nome "{0}" excede o comprimento máximo permitido em metadados.</value>
  </data>
  <data name="ERR_NoAliasHere" xml:space="preserve">
    <value>Uma diretiva 'usando estático' não pode ser usada para declarar um alias</value>
  </data>
  <data name="WRN_AssignmentToSelf" xml:space="preserve">
    <value>Atribuição feita à mesma variável. Você pretendia atribuir outro elemento?</value>
  </data>
  <data name="WRN_UnreferencedEvent_Title" xml:space="preserve">
    <value>O evento nunca é usado</value>
  </data>
  <data name="ERR_BadEventUsageNoField" xml:space="preserve">
    <value>O evento "{0}" só pode aparecer no lado esquerdo de += ou -=</value>
  </data>
  <data name="IDS_XMLBADINCLUDE" xml:space="preserve">
    <value> Marca include inválida </value>
  </data>
  <data name="ERR_CycleInTypeForwarder" xml:space="preserve">
    <value>O encaminhador de tipo para o tipo "{0}" no assembly "{1}" gera um ciclo</value>
  </data>
  <data name="ERR_DuplicateNameInClass" xml:space="preserve">
    <value>O tipo "{0}" já contém uma definição para "{1}"</value>
  </data>
  <data name="ERR_ExpressionTreeContainsOptionalArgument" xml:space="preserve">
    <value>Uma árvore de expressão não pode conter chamada ou invocação que use argumentos opcionais</value>
  </data>
  <data name="FTL_MetadataCantOpenFile" xml:space="preserve">
    <value>Arquivo de metadados "{0}" não pode ser aberto -- {1}</value>
  </data>
  <data name="WRN_CmpAlwaysFalse" xml:space="preserve">
    <value>Comparação com null do tipo "{0}" sempre produz "false"</value>
  </data>
  <data name="IDS_FeatureModuleAttrLoc" xml:space="preserve">
    <value>módulo como um especificador de destino de atributo</value>
  </data>
  <data name="WRN_MultipleRuntimeImplementationMatches_Description" xml:space="preserve">
    <value>Esse aviso pode ser gerado quando dois métodos de interface são diferenciados somente por se um determinado parâmetro é marcado com ref ou out. É aconselhável alterar o código para evitar este aviso porque não fica óbvio ou garantido qual método é chamado no tempo de execução.

Embora C# faça a distinção entre out e ref, o CLR os vê da mesma forma. Ao decidir qual método implementa a interface, o CLR simplesmente escolhe um deles.

Forneça ao compilador alguma forma de diferenciar os métodos. Por exemplo, você pode dar-lhes nomes diferentes ou fornecer um parâmetro adicional em um deles.</value>
  </data>
  <data name="ERR_PPReferenceFollowsToken" xml:space="preserve">
    <value>Não é possível usar #r após o primeiro token no arquivo</value>
  </data>
  <data name="ERR_CloseUnimplementedInterfaceMemberStatic" xml:space="preserve">
    <value>"{0}" não implementa membro de interface "{1}". "{2}" não pode implementar um membro de interface, pois é estático.</value>
  </data>
  <data name="ERR_InitializeByReferenceVariableWithValue" xml:space="preserve">
    <value>Não é possível inicializar uma variável por referência com um valor</value>
  </data>
  <data name="IDS_FeatureNamedArgument" xml:space="preserve">
    <value>argumento nomeado</value>
  </data>
  <data name="WRN_MultiplePredefTypes" xml:space="preserve">
    <value>O tipo pré-definido "{0}" está definido em vários assemblies no alias global; usando definição de "{1}"</value>
  </data>
  <data name="ERR_RefReturningCallInExpressionTree" xml:space="preserve">
    <value>O lambda da árvore de expressão pode não conter uma chamada para um método, propriedade ou indexador que é retornado por referência</value>
  </data>
  <data name="ERR_PartialMethodInvalidModifier" xml:space="preserve">
    <value>Um método parcial não pode ter modificadores de acesso ou modificadores do tipo virtual, abstract, override, new, sealed ou extern</value>
  </data>
  <data name="XML_MissingEqualsAttribute" xml:space="preserve">
    <value>Ausência de sinal de igual entre atributo e o valor de atributo.</value>
  </data>
  <data name="ERR_DeconstructWrongCardinality" xml:space="preserve">
    <value>Não é possível desconstruir uma tupla de '{0}' elementos em '{1}' variáveis.</value>
  </data>
  <data name="ERR_UnimplementedAbstractMethod" xml:space="preserve">
    <value>"{0}" não implementa membro abstrato herdado "{1}"</value>
  </data>
  <data name="ERR_NoNewTyvar" xml:space="preserve">
    <value>Não é possível criar uma instância do tipo de variável "{0}" porque ela não tem a restrição new()</value>
  </data>
  <data name="ERR_RecursivelyTypedVariable" xml:space="preserve">
    <value>Tipo de "{0}" não pode ser inferido porque seu inicializador direta ou indiretamente refere-se à definição.</value>
  </data>
  <data name="ERR_LoadDirectiveOnlyAllowedInScripts" xml:space="preserve">
    <value>#load só pode ser usado em scripts</value>
  </data>
  <data name="WRN_CLS_OverloadUnnamed" xml:space="preserve">
    <value>Metódo sobrecarregado "{0}" diferindo somente por tipos de matriz não nomeados não tem conformidade com CLS</value>
  </data>
  <data name="ERR_RefValBoundMustBeFirst" xml:space="preserve">
    <value>A restrição 'class' ou 'struct' deve vir antes de qualquer outra restrição</value>
  </data>
  <data name="ERR_BadAttributeArgument" xml:space="preserve">
    <value>Um argumento attribute deve ser uma expressão constant, typeof ou array creation de um tipo de parâmetro attribute</value>
  </data>
  <data name="IDS_ThrowExpression" xml:space="preserve">
    <value>&lt;expressão throw&gt;</value>
  </data>
  <data name="IDS_FeaturePartialTypes" xml:space="preserve">
    <value>tipos parciais</value>
  </data>
  <data name="GenericParameterDefinition" xml:space="preserve">
    <value>Parâmetro genérico é definição quando é esperado que seja referência {0}</value>
  </data>
  <data name="ERR_VarInvocationLvalueReserved" xml:space="preserve">
    <value>A sintaxe 'var (...)' como um lvalue está reservada.</value>
  </data>
  <data name="WRN_NoConfigNotOnCommandLine" xml:space="preserve">
    <value>Ignorando a opção /noconfig porque ela foi especificada em um arquivo de resposta</value>
  </data>
  <data name="ERR_BadIsPatternExpression" xml:space="preserve">
    <value>Operando inválido para correspondência de padrão. Um valor era obrigatório, mas '{0}' foi encontrado.</value>
  </data>
  <data name="ERR_PropertyCantHaveVoidType" xml:space="preserve">
    <value>"{0}": propriedade ou indexador não pode ter tipo void</value>
  </data>
  <data name="ERR_CantOverrideSealed" xml:space="preserve">
    <value>"{0}": não é possível substituir o membro herdado "{1}" porque ele é sealed</value>
  </data>
  <data name="ERR_BadIteratorArgType" xml:space="preserve">
    <value>Iteradores não podem ter parâmetros ref nem out</value>
  </data>
  <data name="ERR_IndexedPropertyMustHaveAllOptionalParams" xml:space="preserve">
    <value>Propriedade indexada "{0}" deve ter todos os argumentos opcionais</value>
  </data>
  <data name="ERR_InconsistentLambdaParameterUsage" xml:space="preserve">
    <value>Utilização inconsistente do parâmetro lambda; todos os tipos de parâmetros devem ser explícitos ou implícitos.</value>
  </data>
  <data name="WRN_UnableToLoadAnalyzer_Title" xml:space="preserve">
    <value>Não é possível carregar o assembly do analisador</value>
  </data>
  <data name="ERR_DiscardTypeInferenceFailed" xml:space="preserve">
    <value>Não é possível inferir o tipo de descarte de tipo implícito.</value>
  </data>
  <data name="ERR_NonInterfaceInInterfaceList" xml:space="preserve">
    <value>Tipo "{0}" na lista de interfaces não é uma interface</value>
  </data>
  <data name="IDS_SK_UNKNOWN" xml:space="preserve">
    <value>elemento</value>
  </data>
  <data name="ERR_VarargsLast" xml:space="preserve">
    <value>Um parâmetro __arglist deve ser o último em uma lista formal de parâmetros</value>
  </data>
  <data name="ERR_ExpressionTreeContainsIsMatch" xml:space="preserve">
    <value>Uma árvore de expressão não pode conter um operador 'is' com padrões correspondentes.</value>
  </data>
  <data name="ERR_AttributesInLocalFuncDecl" xml:space="preserve">
    <value>Os atributos não são permitidos em parâmetros de função local ou parâmetros de tipo</value>
  </data>
  <data name="ERR_AmbigUDConv" xml:space="preserve">
    <value>Conversões ambíguas definidas por usuário "{0}" e "{1}" ao realizar a conversão de "{2}" em "{3}"</value>
  </data>
  <data name="ERR_NewCoClassOnLink" xml:space="preserve">
    <value>Tipo de interoperabilidade "{0}" não pode ser incorporado. Ao invés disso, use a interface aplicável.</value>
  </data>
  <data name="ERR_RefAssignmentMustHaveIdentityConversion" xml:space="preserve">
    <value>A expressão deve ser do tipo '{0}' porque ela está sendo atribuída por referência</value>
  </data>
  <data name="WRN_NoAnalyzerInAssembly_Title" xml:space="preserve">
    <value>O assembly não contém analisadores</value>
  </data>
  <data name="WRN_NegativeArrayIndex_Title" xml:space="preserve">
    <value>Indexando uma matriz com um índice negativo</value>
  </data>
  <data name="ERR_RefPropertyCannotHaveSetAccessor" xml:space="preserve">
    <value>As propriedades que retornam por referência não podem ter acessadores definidos</value>
  </data>
  <data name="ERR_SwitchNeedsNumber" xml:space="preserve">
    <value>Erro de sintaxe de linha de comando: ":&lt;number&gt;" ausente para a opção "{0}"</value>
  </data>
  <data name="ERR_MissingTypeInAssembly" xml:space="preserve">
    <value>Referência ao tipo "{0}" declara que ele é definido em "{1}", mas não pode ser encontrado</value>
  </data>
  <data name="WRN_AssignmentToLockOrDispose" xml:space="preserve">
    <value>Atribuição possivelmente incorreta ao local "{0}" que é o argumento para uma instrução using ou lock. A chamada Dispose desbloqueio ou acontecerá no valor original do local.</value>
  </data>
  <data name="ERR_ConversionNotTupleCompatible" xml:space="preserve">
    <value>A tupla com {0} elementos não pode ser convertida para o tipo '{1}'.</value>
  </data>
  <data name="XML_LessThanInAttributeValue" xml:space="preserve">
    <value>O caractere "&lt;" não pode ser usado em um valor de atributo.</value>
  </data>
  <data name="WRN_IllegalPPChecksum" xml:space="preserve">
    <value>Sintaxe de #pragma checksum inválida; deve ser #pragma checksum "nome_de_arquivo" "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" "XXXX..."</value>
  </data>
  <data name="IDS_Invariantly" xml:space="preserve">
    <value>invariantement</value>
  </data>
  <data name="WRN_Experimental" xml:space="preserve">
    <value>'{0}' é para fins de avaliação somente e está sujeito a alterações ou remoções em atualizações futuras.</value>
  </data>
  <data name="PositionIsNotWithinSyntax" xml:space="preserve">
    <value>Posição não está dentro da árvore de sintaxe com intervalo total {0}</value>
  </data>
  <data name="ERR_ExtensionAttrNotFound" xml:space="preserve">
    <value>Não é possível definir um novo método de extensão porque o tipo necessário de compilador "{0}" não pode ser encontrado. Está faltando uma referência a System.Core.dll?</value>
  </data>
  <data name="ERR_BadBoolOp" xml:space="preserve">
    <value>Para ser aplicável como um operador de circuito pequeno, um operador lógico definido pelo usuário ("{0}") deve ter o mesmo tipo de retorno e tipos de parâmetro</value>
  </data>
  <data name="WRN_ComparisonToSelf" xml:space="preserve">
    <value>Comparação feita com a mesma variável. Você pretendia comparar com outro elemento?</value>
  </data>
  <data name="WRN_CLS_BadIdentifierCase_Title" xml:space="preserve">
    <value>O identificador difere somente quando não tem conformidade com CLS</value>
  </data>
  <data name="ERR_InvalidReal" xml:space="preserve">
    <value>Literal real inválido.</value>
  </data>
  <data name="ERR_FixedNotNeeded" xml:space="preserve">
    <value>A instrução fixed não pode ser usada para obter o endereço de uma expressão fixed</value>
  </data>
  <data name="WRN_CLS_BadAttributeType" xml:space="preserve">
    <value>"{0}" não tem construtores acessíveis que usam somente tipos em conformidade com CLS</value>
  </data>
  <data name="ERR_DecConstError" xml:space="preserve">
    <value>Falha na avaliação da expressão decimal constante</value>
  </data>
  <data name="ERR_DuplicateLabel" xml:space="preserve">
    <value>O rótulo "{0}" é uma duplicata</value>
  </data>
  <data name="ERR_AssgReadonly" xml:space="preserve">
    <value>Um campo somente leitura não pode ser atribuído (exceto em um construtor ou inicializador de variável)</value>
  </data>
  <data name="ERR_DuplicateAlias" xml:space="preserve">
    <value>O alias using "{0}" exibido anteriormente neste namespace</value>
  </data>
  <data name="ERR_BadArgRef" xml:space="preserve">
    <value>Argumento {0} não deve ser transmitido com a palavra-chave "{1}"</value>
  </data>
  <data name="ERR_InvalidNamedArgument" xml:space="preserve">
    <value>Valor inválido para o argumento de atributo denominado "{0}"</value>
  </data>
  <data name="ERR_DuplicateBound" xml:space="preserve">
    <value>Duplicar restrição "{0}" para o parâmetro de tipo "{1}"</value>
  </data>
  <data name="ERR_ReadonlyValueTypeInObjectInitializer" xml:space="preserve">
    <value>Membros do campo de somente leitura "{0}" do tipo "{1}" não podem ser atribuídos com um inicializador de objeto porque ele é de um tipo de valor</value>
  </data>
  <data name="ERR_BadAsyncLacksBody" xml:space="preserve">
    <value>O modificador 'async' só pode ser usado em métodos que têm um corpo.</value>
  </data>
  <data name="ERR_PartialMultipleBases" xml:space="preserve">
    <value>Declarações parciais de "{0}" não devem especificar classes base diferentes</value>
  </data>
  <data name="ERR_BadAccess" xml:space="preserve">
    <value>"{0}" é inacessível devido ao seu nível de proteção</value>
  </data>
  <data name="ERR_AmbigOverride" xml:space="preserve">
    <value>Os membros herdados "{0}" e "{1}" têm a mesma assinatura no tipo "{2}", portanto, eles não podem ser substituídos</value>
  </data>
  <data name="ERR_NoDynamicPhantomOnBaseIndexer" xml:space="preserve">
    <value>O acesso ao indexador deve ser expedido dinamicamente, mas isso não é possível porque ele faz parte de uma expressão de acesso de base. Converta os argumentos dinâmicos ou elimine o acesso de base.</value>
  </data>
  <data name="ERR_BadArgTypeDynamicExtension" xml:space="preserve">
    <value>"{0}" não tem nenhum método aplicável nomeado "{1}" mas parece ter um método de extensão com esse nome. Métodos de extensão não podem ser despachados dinamicamente. Considere a possibilidade de converter os argumentos dinâmicos ou chamar o método de extensão sem a sintaxe do método de extensão.</value>
  </data>
  <data name="ERR_PrivateAbstractAccessor" xml:space="preserve">
    <value>"{0}": propriedades abstratas não podem ter acessadores particulares</value>
  </data>
  <data name="WRN_IsAlwaysFalse_Title" xml:space="preserve">
    <value>A expressão 'is' determinada nunca é do tipo fornecido</value>
  </data>
  <data name="ERR_InvalidVersionFormat2" xml:space="preserve">
    <value>A cadeia de caracteres de versão especificada não está de acordo com o formato necessário - major.minor.build.revision</value>
  </data>
  <data name="ERR_CantOpenWin32Manifest" xml:space="preserve">
    <value>Erro ao abrir o arquivo de manifesto Win32 {0} -- {1}</value>
  </data>
  <data name="ERR_NewVirtualInSealed" xml:space="preserve">
    <value>"{0}" é um novo membro virtual na classe sealed "{1}"</value>
  </data>
  <data name="ERR_ExpressionTreeContainsIndexedProperty" xml:space="preserve">
    <value>Uma árvore de expressão não pode conter uma propriedade indexada</value>
  </data>
  <data name="WRN_IllegalPPChecksum_Title" xml:space="preserve">
    <value>Sintaxe de soma de verificação #pragma inválida</value>
  </data>
  <data name="LookupOptionsHasInvalidCombo" xml:space="preserve">
    <value>LookupOptions tem uma combinação inválida de opções</value>
  </data>
  <data name="ERR_ArrayInitializerIncorrectLength" xml:space="preserve">
    <value>Inicializador de matriz de comprimento "{0}" é esperado</value>
  </data>
  <data name="ERR_RefReturnReadonly" xml:space="preserve">
    <value>Um campo somente leitura não pode ser retornado por referência</value>
  </data>
  <data name="ERR_V6SwitchGoverningTypeValueExpected" xml:space="preserve">
    <value>Uma expressão de switch ou um rótulo case deve ser um bool, char, cadeia, integral ou um tipo que permite valor nulo correspondente em C# 6 e anterior.</value>
  </data>
  <data name="LocationMustBeProvided" xml:space="preserve">
    <value>Local deve ser fornecido para fornecer a qualificação do tipo mínimo.</value>
  </data>
  <data name="WRN_CLS_ModuleMissingCLS" xml:space="preserve">
    <value>Módulos adicionados devem ser marcados com o atributo CLSCompliant para corresponder ao assembly</value>
  </data>
  <data name="ERR_RefConstraintNotSatisfied" xml:space="preserve">
    <value>O tipo "{2}" deve ser um tipo de referência para que seja usado como parâmetro "{1}" no tipo ou método genérico "{0}"</value>
  </data>
  <data name="SubmissionCanOnlyInclude" xml:space="preserve">
    <value>Envio só pode incluir código de script.</value>
  </data>
  <data name="ERR_NoGetToOverride" xml:space="preserve">
    <value>"{0}": não pode substituir porque "{1}" não tem um acessador get substituível</value>
  </data>
  <data name="WRN_UnreachableGeneralCatch_Title" xml:space="preserve">
    <value>Uma cláusula catch anterior já captura todas as exceções</value>
  </data>
  <data name="ERR_InterfacesCantContainOperators" xml:space="preserve">
    <value>Interfaces não podem conter operadores</value>
  </data>
  <data name="ERR_BinaryFile" xml:space="preserve">
    <value>"{0}" é um arquivo binário em vez de um arquivo de texto</value>
  </data>
  <data name="ERR_SwitchExpressionValueExpected" xml:space="preserve">
    <value>A expressão switch deve ser um valor. {0} foi encontrado.</value>
  </data>
  <data name="ERR_AnonymousTypePropertyAssignedBadValue" xml:space="preserve">
    <value>Não é possível atribuir '{0}' à propriedade de tipo anônimo</value>
  </data>
  <data name="ERR_OverloadRefOutCtor" xml:space="preserve">
    <value>Não é possível definir o construtor sobrecarregado "{0}" porque ele é diferente de outro construtor somente em ref e out</value>
  </data>
  <data name="ERR_CantOpenFileWrite" xml:space="preserve">
    <value>Não é possível abrir "{0}" para escrever -- "{1}"</value>
  </data>
  <data name="WRN_PossibleMistakenNullStatement" xml:space="preserve">
    <value>Instrução empty possivelmente incorreta</value>
  </data>
  <data name="ERR_PartialMethodToDelegate" xml:space="preserve">
    <value>Não é possível criar representante do método "{0}" porque ele é um método parcial sem declaração de implementação</value>
  </data>
  <data name="ERR_OverrideFinalizeDeprecated" xml:space="preserve">
    <value>Em vez de substituir object.Finalize, forneça um destruidor.</value>
  </data>
  <data name="IDS_FeatureExpressionBodiedDeOrConstructor" xml:space="preserve">
    <value>destruidor e construtor do corpo da expressão</value>
  </data>
  <data name="ERR_ExplicitLayoutAndAutoImplementedProperty" xml:space="preserve">
    <value>'{0}': propriedades implementadas automaticamente não podem ser usadas dentro de um tipo marcado com StructLayout(LayoutKind.Explicit)</value>
  </data>
  <data name="ERR_MissingPPFile" xml:space="preserve">
    <value>Nome do arquivo entre aspas, comentário de linha única ou fim da linha é esperado</value>
  </data>
  <data name="WRN_BadXMLRefTypeVar" xml:space="preserve">
    <value>O comentário XML tem atributo cref "{0}" que refere-se a um parâmetro de tipo</value>
  </data>
  <data name="ERR_BadDelegateConstructor" xml:space="preserve">
    <value>O representante "{0}" não tem um construtor válido</value>
  </data>
  <data name="ERR_DeconstructTooFewElements" xml:space="preserve">
    <value>A desconstrução deve conter pelo menos duas variáveis.</value>
  </data>
  <data name="ERR_ValueTypeExtDelegate" xml:space="preserve">
    <value>Método de extensão "{0}" definido no tipo de valor "{1}" não pode ser usado para criar representantes</value>
  </data>
  <data name="ERR_BadVisBaseClass" xml:space="preserve">
    <value>Acessibilidade inconsistente: classe base "{1}" é menos acessível do que a classe "{0}"</value>
  </data>
  <data name="ERR_InvalidGotoCase" xml:space="preserve">
    <value>Um goto case só é válido dentro de uma instrução switch</value>
  </data>
  <data name="ERR_ObjectCantHaveBases" xml:space="preserve">
    <value>Classe System.Object não pode ter uma classe base nem implementar uma interface</value>
  </data>
  <data name="ERR_CantChangeAccessOnOverride" xml:space="preserve">
    <value>"{0}": não é possível alterar modificadores de acesso ao substituir "{1}" membro herdado "{2}"</value>
  </data>
  <data name="ERR_IndexerCantHaveVoidType" xml:space="preserve">
    <value>Indexadores não podem ter o tipo void</value>
  </data>
  <data name="ERR_BadVisOpParam" xml:space="preserve">
    <value>Acessibilidade inconsistente: tipo de parâmetro "{1}" é menos acessível do que o operador "{0}"</value>
  </data>
  <data name="ERR_ConstValueRequired" xml:space="preserve">
    <value>O campo const requer um valor a ser fornecido</value>
  </data>
  <data name="ERR_RefReturnReceiver" xml:space="preserve">
    <value>Não é possível retornar o '{0}' por referência, pois seu receptor não pode ser retornado por referência</value>
  </data>
  <data name="WRN_BadRestoreNumber" xml:space="preserve">
    <value>Não é possível restaurar o aviso "CS{0}" porque ele foi desabilitado globalmente</value>
  </data>
  <data name="WRN_FinalizeMethod" xml:space="preserve">
    <value>A introdução de um método 'Finalize' pode interferir na invocação do destruidor. Você pretendia declarar um destruidor?</value>
  </data>
  <data name="ERR_BadIteratorReturnRef" xml:space="preserve">
    <value>O corpo de '{0}' não pode ser um bloco de iteradores, pois '{0}' é retornado por referência</value>
  </data>
  <data name="ERR_BadIndexCount" xml:space="preserve">
    <value>Número incorreto de índices dentro de []; esperado {0}</value>
  </data>
  <data name="WRN_DelaySignButNoKey" xml:space="preserve">
    <value>A assinatura atrasada foi especificada e requer uma chave pública, mas nenhuma chave pública foi especificada</value>
  </data>
  <data name="ERR_PartialMethodCannotHaveOutParameters" xml:space="preserve">
    <value>Um método parcial não pode ter parâmetros out</value>
  </data>
  <data name="ERR_InvalidExprTerm" xml:space="preserve">
    <value>Termo de expressão inválido "{0}"</value>
  </data>
  <data name="ERR_InvalidPropertyAccessMod" xml:space="preserve">
    <value>O modificador de acessibilidade do "{0}" acessador deve ser mais restritivo que a propriedade ou o indexador "{1}"</value>
  </data>
  <data name="ERR_BadCallerFilePathParamWithoutDefaultValue" xml:space="preserve">
    <value>O CallerFilePathAttribute só pode ser aplicado a parâmetros com valores padrão</value>
  </data>
  <data name="ERR_NoFileSpec" xml:space="preserve">
    <value>Falta a especificação de arquivo para "{0}" opção</value>
  </data>
  <data name="ERR_ExpectedPPFile" xml:space="preserve">
    <value>Nome do arquivo entre aspas é esperado</value>
  </data>
  <data name="ERR_DuplicateConversionInClass" xml:space="preserve">
    <value>Duplicar convenção definida pelo usuário no tipo "{0}"</value>
  </data>
  <data name="ERR_IntegralTypeExpected" xml:space="preserve">
    <value>Tipo byte, sbyte, short, ushort, int, uint, long ou ulong esperado</value>
  </data>
  <data name="ERR_UnexpectedGenericName" xml:space="preserve">
    <value>Uso inesperado de um nome genérico</value>
  </data>
  <data name="WRN_CLS_AssemblyNotCLS2" xml:space="preserve">
    <value>"{0}" não necessista de um atributo CLSCompliant porque o assembly não tem um atributo CLSCompliant</value>
  </data>
  <data name="ERR_BadCoClassSig" xml:space="preserve">
    <value>A assinatura de classe coclass wrapper gerenciada "{0}" para interface "{1}" não é uma assinatura de nome de classe válida</value>
  </data>
  <data name="ERR_SameFullNameAggAgg" xml:space="preserve">
    <value>O tipo "{1}" existe em "{0}" e "{2}"</value>
  </data>
  <data name="WRN_SameFullNameThisAggAgg_Title" xml:space="preserve">
    <value>Conflitos de tipo com o tipo importado</value>
  </data>
  <data name="ERR_EscapedCurly" xml:space="preserve">
    <value>Um caractere '{0}' somente deve ser de escape ao duplicar '{0}{0}' em uma cadeia de caracteres interpolada.</value>
  </data>
  <data name="WRN_InvalidInclude_Title" xml:space="preserve">
    <value>XML inválido para incluir elemento</value>
  </data>
  <data name="WRN_FinalizeMethod_Description" xml:space="preserve">
    <value>Este aviso ocorre quando você cria uma classe com um método cuja assinatura é o vazio virtual Finalize público.

Se tal classe for usada como uma classe base e se a classe derivada definir um destruidor, o destruidor substituirá o método Finalize da classe básica, não o Finalize.</value>
  </data>
  <data name="ERR_DoNotUseFixedBufferAttr" xml:space="preserve">
    <value>Não use o atributo 'System.Runtime.CompilerServices.FixedBuffer'. Use o modificador de campos 'fixed' em seu lugar.</value>
  </data>
  <data name="ERR_NullNotValid" xml:space="preserve">
    <value>O uso de null não é válido neste contexto</value>
  </data>
  <data name="ERR_AliasQualAsExpression" xml:space="preserve">
    <value>O qualificador alias de namespace '::' sempre é resolvido em um tipo ou namespace, por isso é inválido aqui. Use '.' em seu lugar.</value>
  </data>
  <data name="ERR_AsWithTypeVar" xml:space="preserve">
    <value>O parâmetro do tipo "{0}" não pode ser usado com o operador "as" porque não tem uma restrição de tipo de classe nem uma restrição "class"</value>
  </data>
  <data name="ERR_BaseInStaticMeth" xml:space="preserve">
    <value>A palavra-chave 'base' não está disponível em um método estático</value>
  </data>
  <data name="ERR_MemberCannotBeInitialized" xml:space="preserve">
    <value>Membro "{0}" não pode ser inicializado. Não é um campo ou propriedade.</value>
  </data>
  <data name="ERR_AmbigMember" xml:space="preserve">
    <value>Ambiguidade entre "{0}" e "{1}"</value>
  </data>
  <data name="ERR_PartialMethodOnlyMethods" xml:space="preserve">
    <value>Somente métodos, classes, estruturas ou interfaces podem ser parciais</value>
  </data>
  <data name="ERR_MissingGuidForOption" xml:space="preserve">
    <value>Erro de sintaxe de linha de comando: falta Guid para a opção "{1}"</value>
  </data>
  <data name="WRN_ConflictingMachineAssembly" xml:space="preserve">
    <value>Assembly referenciado "{0}" destinado a um processador diferente.</value>
  </data>
  <data name="ERR_ImplicitlyTypedVariableAssignedBadValue" xml:space="preserve">
    <value>Não é possível atribuir {0} a uma variável de tipo implícito</value>
  </data>
  <data name="ERR_PeWritingFailure" xml:space="preserve">
    <value>Ocorreu um erro ao gravar o arquivo de saída: {0}.</value>
  </data>
  <data name="ERR_StaticConstructorWithExplicitConstructorCall" xml:space="preserve">
    <value>"{0}": construtor estático não pode ter uma chamada de construtor "this" ou "base" explícita</value>
  </data>
  <data name="IDS_LIB_ENV" xml:space="preserve">
    <value>variável de ambiente LIB</value>
  </data>
  <data name="ERR_MixingWinRTEventWithRegular" xml:space="preserve">
    <value>"{0}" não pode implementar "{1}" porque "{2}" é um evento de Tempo de Execução do Windows e "{3}" é um evento regular do .NET.</value>
  </data>
  <data name="WRN_DeprecatedSymbol" xml:space="preserve">
    <value>"{0}" está obsoleto</value>
  </data>
  <data name="ERR_InvalidConstantDeclarationType" xml:space="preserve">
    <value>"{0}" é do tipo "{1}". O tipo especificado em uma declaração constante deve ser sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool, cadeia de caracteres, um tipo enum ou um tipo de referência.</value>
  </data>
  <data name="WRN_InvalidVersionFormat_Title" xml:space="preserve">
    <value>A cadeia de caracteres de versão especificada não está de acordo com o formato recomendado - major.minor.build.revision</value>
  </data>
  <data name="WRN_MissingParamTag" xml:space="preserve">
    <value>Parâmetro "{0}" não tem marca param correspondente no comentário XML para "{1}" (mas outros parâmetros têm)</value>
  </data>
  <data name="ERR_IndexedPropertyRequiresParams" xml:space="preserve">
    <value>Propriedade indexada "{0}" tem argumentos não opcionais que devem ser fornecidos</value>
  </data>
  <data name="ERR_BadAsyncMethodBuilderTaskProperty" xml:space="preserve">
    <value>Para o tipo '{0}' a ser usado como um AsyncMethodBuilder para o tipo '{1}', sua propriedade Task deve retornar o tipo '{1}' em vez do tipo '{2}'.</value>
  </data>
  <data name="ERR_VolatileAndReadonly" xml:space="preserve">
    <value>"{0}": um campo não pode ser volátil e somente leitura</value>
  </data>
  <data name="ERR_EndRegionDirectiveExpected" xml:space="preserve">
    <value>Diretiva #endregion esperada</value>
  </data>
  <data name="ERR_DuplicateGeneratedName" xml:space="preserve">
    <value>O nome de parâmetro "{0}" está em conflito com um nome de parâmetro gerado automaticamente</value>
  </data>
  <data name="ERR_NameofMethodGroupWithTypeParameters" xml:space="preserve">
    <value>Os parâmetros de tipo não são permitidos em um grupo de métodos como um argumento para 'nameof'.</value>
  </data>
  <data name="ERR_BadVisDelegateParam" xml:space="preserve">
    <value>Acessibilidade inconsistente: tipo de parâmetro "{1}" é menos acessível do que o delegado "{0}"</value>
  </data>
  <data name="WRN_UnreachableGeneralCatch" xml:space="preserve">
    <value>Uma cláusula catch anterior já captura todas as exceções. Todas as não exceções lançadas serão ajustadas em uma System.Runtime.CompilerServices.RuntimeWrappedException.</value>
  </data>
  <data name="IDS_XMLFAILEDINCLUDE" xml:space="preserve">
    <value> Falha ao inserir alguns ou todos os XML incluídos </value>
  </data>
  <data name="ERR_BadAwaitArgIntrinsic" xml:space="preserve">
    <value>Não é possível aguardar "{0}"</value>
  </data>
  <data name="ERR_MixedDeconstructionUnsupported" xml:space="preserve">
    <value>Uma desconstrução não pode mesclar declarações e expressões à esquerda.</value>
  </data>
  <data name="ERR_ConstantExpected" xml:space="preserve">
    <value>Um valor constante é esperado</value>
  </data>
  <data name="WRN_TypeParameterSameAsOuterTypeParameter" xml:space="preserve">
    <value>Parâmetro de tipo "{0}" tem o mesmo nome do parâmetro de tipo de tipo externo "{1}"</value>
  </data>
  <data name="ERR_LiteralDoubleCast" xml:space="preserve">
    <value>Literal do tipo double não pode ser convertido implicitamente no tipo "{1}"; use um sufixo "{0}" para criar um literal desse tipo</value>
  </data>
  <data name="IDS_CSCHelp" xml:space="preserve">
    <value>
                              Opções do Compilador do Visual C#

                        – ARQUIVOS DE SAÍDA –
 /out:&lt;file&gt;                   Especifica o nome do arquivo de saída (padrão: nome de base do
                               arquivo com a classe principal ou o primeiro arquivo)
 /target:exe                   Compila um executável de console (padrão) (Forma
                               abreviada: /t:exe)
 /target:winexe                Compila um executável do Windows (Forma abreviada:
                               /t:winexe)
 /target:library               Compila uma biblioteca (Forma abreviada: /t:library)
 /target:module                Compila um módulo que pode ser adicionado a outro
                               assembly (Forma abreviada: /t:module)
 /target:appcontainerexe (Forma abreviada: /t:module)
 /target:appcontainerexe       Compila um executável de contêiner de aplicativo (Forma abreviada: 
                               /t:appcontainerexe)
 /target:winmdobj              Compila um arquivo intermediário do Windows Runtime que 
                               é consumido pelo WinMDExp (Forma abreviada: /t:winmdobj)
 /doc:&lt;file&gt;                   Arquivo de Documentação XML a ser gerado
 /refout:&lt;file&gt;                Saída do assembly de referência a ser gerado
 /platform:&lt;string&gt;            Limita em quais plataformas o código pode ser executado: x86,
                               Itanium, x64, arm, anycpu32bitpreferred ou 
                               anycpu. O padrão é anycpu.

                        – ARQUIVOS DE ENTRADA –
 /recurse:&lt;wildcard&gt;           Inclui todos os arquivos no diretório e 
                               subdiretórios atuais de acordo com as especificações de 
                               curinga
 /reference:&lt;alias&gt;=&lt;file&gt;     Metadados de referência do arquivo de assembly 
                               especificado usando o alias informado (Forma abreviada: /r)
 /reference:&lt;file list&gt;        Metadados de referência dos arquivos de assembly 
                               especificados (Forma abreviada: /r)
 /addmodule:&lt;file list&gt;        Vincula os módulos especificados ao assembly
 /link:&lt;file list&gt;             Insere metadados dos arquivos de assembly 
                               de interoperalidade especificados (Forma abreviada: /l)
 /analyzer:&lt;file list&gt;         Executa os analisadores do assembly
                               (Forma abreviada: /a)
 /additionalfile:&lt;file list&gt;   Arquivos adicionais que não afetam diretamente a geração
                               de código, mas que podem ser usados por analisadores para produzir
                               erros ou avisos.
 /embed                        Insere todos os arquivos de origem no PDB.
 /embed:&lt;file list&gt;            Insere arquivos específicos no PDB

                        – RECURSOS –
 /win32res:&lt;file&gt;              Especifica um arquivo de recurso Win32 (.res)
 /win32icon:&lt;file&gt;             Use esse ícone para a saída
 /win32manifest:&lt;file&gt;         Especifica um arquivo de manifesto Win32 (.xml)
 /nowin32manifest              Não inclui o manifesto Win32 padrão
 /resource:&lt;resinfo&gt;           Insere o recurso especificado (Forma abreviada: /res)
 /linkresource:&lt;resinfo&gt;       Vincula o recurso especificado ao assembly 
                               (Forma abreviada: /linkres) Em que o formato resinfo 
                               é &lt;file&gt;[,&lt;string name&gt;[,public|private]]

                        – GERAÇÃO DE CÓDIGO –
 /debug[+|-]                   Emite informações de depuração
 /debug:{full|pdbonly|portable|embedded}
                               Especifica o tipo de depuração ('full' é o padrão, 
                               'portable' é um formato multiplataforma e
                               'embedded' é um formato multiplataforma inserido no 
                               .dll ou no .exe de destino)
 /optimize[+|-]                Habilita otimizações (Forma abreviada: /o)
 /deterministic                Produz um assembly determinístico
                               (incluindo carimbo de data/hora e GUID da versão do módulo)
 /instrument:TestCoverage      Produz um assembly instrumentado para coletar
                               informações de cobertura
 /sourcelink:&lt;file&gt;            Informações do link de origem a ser inserido no PDB.

                        – ERROS E AVISOS –
 /warnaserror[+|-]             Relata todos os avisos como erros
 /warnaserror[+|-]:&lt;warn list&gt; Relata avisos específicos como erros
 /warn:&lt;n&gt;                     Define o nível de aviso (0 – 4) (Forma abreviada: /w)
 /nowarn:&lt;warn list&gt;           Desabilita mensagens de aviso específicas
 /ruleset:&lt;file&gt;               Especifica um arquivo de conjunto de regras que desabilita um diagnóstico
                               específico.
 /errorlog:&lt;file&gt;              Especifica um arquivo para registrar todos os diagnósticos do compilador e do
                               analisador.
 /reportanalyzer               Relata informações adicionais do analisador, como o
                               tempo de execução.
 
                        – LINGUAGEM –
 /checked[+|-]                 Gera verificações de estouro
 /unsafe[+|-]                  Permite código 'não seguro'
 /define:&lt;symbol list&gt;         Define símbolos de compilação condicional (Forma 
                               abreviada: /d)
 /langversion:&lt;string&gt;         Especifica o modo da versão da linguagem: ISO-1, ISO-2, 3, 
                               4, 5, 6, 7, 7.1, Padrão ou Mais Recente

                        – SEGURANÇA –
 /delaysign[+|-]               Faz a assinatura atrasada do assembly usando apenas a parte 
                               pública da chave de nome forte
 /publicsign[+|-]              Faz a assinatura pública do assembly usando somente a parte
                               pública da chave de nome forte
 /keyfile:&lt;file&gt;               Especifica um arquivo de chave de nome forte
 /keycontainer:&lt;string&gt;        Especifica um contêiner de chaves de nomes fortes
 /highentropyva[+|-]           Habilita ASLR de alta entropia

                        – DIVERSOS –
 @&lt;file&gt;                       Lê o arquivo de resposta para obter mais opções
 /help                         Exibe essa mensagem de uso (Forma abreviada: /?)
 /nologo                       Suprime a mensagem de direitos autorais do compilador
 /noconfig                     Não inclui o arquivo CSC.RSP automaticamente
 /parallel[+|-]                Build simultâneo.
 /version                      Exibe o número de versão do compilador e sai.

                        – AVANÇADO –
 /baseaddress:&lt;address&gt;        Endereço básico da biblioteca a ser compilada
 /checksumalgorithm:&lt;alg&gt;      Especifica o algoritmo para calcular a soma de verificação do 
                               arquivo de origem armazenada no PDB. Os valores com suporte são:
                               SHA1 (padrão) ou SHA256.
 /codepage:&lt;n&gt;                 Especifica a página de código a ser usada ao abrir os arquivos de 
                               origem
 /utf8output                   Mensagens de saída do compilador em codificação UTF-8
 /main:&lt;type&gt;                  Especifica o tipo que contém o ponto de entrada 
                               (ignora todos os outros pontos de entrada possíveis) (Forma 
                               abreviada: /m)
 /fullpaths                    O compilador gera caminhos totalmente qualificados
 /filealign:&lt;n&gt;                Especifica o alinhamento usado para as seções do arquivo de 
                               saída
 /pathmap:&lt;K1&gt;=&lt;V1&gt;,&lt;K2&gt;=&lt;V2&gt;,...
                               Especifica um mapeamento para os nomes dos caminhos de origem produzidos pelo
                               compilador.
 /pdb:&lt;file&gt;                   Especifica o nome do arquivo de informações de depuração (padrão: 
                               nome do arquivo de saída com a extensão .pdb)
 /errorendlocation             Linha e coluna de saída da localização final de 
                               cada erro
 /preferreduilang              Especifica o nome da linguagem de saída preferencial.
 /nostdlib[+|-]                Não referencia a biblioteca padrão (mscorlib.dll)
 /subsystemversion:&lt;string&gt;    Especifica a versão do subsistema do assembly
 /lib:&lt;file list&gt;              Especifica diretórios adicionais a serem pesquisados em relação a 
                               referências
 /errorreport:&lt;string&gt;         Especifica como lidar com os erros internos do compilador: 
                               avisar, enviar, colocar na fila ou nada. O padrão é 
                               colocar na fila.
 /appconfig:&lt;file&gt;             Especifica um arquivo de configuração de aplicativo 
                               contendo configurações de associações do assembly
 /moduleassemblyname:&lt;string&gt;  Nome do assembly do qual o módulo fará 
                               parte
 /modulename:&lt;string&gt;          Especifica o nome do módulo de origem
</value>
  </data>
  <data name="ERR_ValueExpected" xml:space="preserve">
    <value>Erro de sintaxe, valor esperado</value>
  </data>
  <data name="ERR_SealedNonOverride" xml:space="preserve">
    <value>"{0}" não pode ser sealed porque não é uma substituição</value>
  </data>
  <data name="ERR_ErrorDirective" xml:space="preserve">
    <value>#error: "{0}"</value>
  </data>
  <data name="ERR_QueryDuplicateRangeVariable" xml:space="preserve">
    <value>A variável de intervalo "{0}" já foi declarada</value>
  </data>
  <data name="ERR_InvalidSignaturePublicKey" xml:space="preserve">
    <value>Chave pública de assinatura inválida especificada em AssemblySignatureKeyAttribute.</value>
  </data>
  <data name="ERR_OverloadRefOut" xml:space="preserve">
    <value>"{0}" não pode definir métodos sobrecarregados que diferem somente em ref e out</value>
  </data>
  <data name="WRN_TupleLiteralNameMismatch" xml:space="preserve">
    <value>O nome do elemento de tupla '{0}' foi ignorado porque um nome diferente ou nenhum nome foi especificado pelo tipo de destino '{1}'.</value>
  </data>
  <data name="WRN_CallOnNonAgileField_Description" xml:space="preserve">
    <value>Este aviso ocorre quando você tentar chamar um método, propriedade ou indexador em um membro de uma classe que é derivada de MarshalByRefObject, e o membro é um tipo de valor. Objetos herdados de MarshalByRefObject geralmente são destinados a ser empacotado por referência em um domínio de aplicativo. Se um código tentar acessar o membro de tipo de valor de tal objeto diretamente em um domínio de aplicativo, ocorrerá uma exceção de tempo de execução. Para resolver o aviso, primeiro copie o membro em uma variável local e chame o método nessa variável.</value>
  </data>
  <data name="ERR_InconsistentIndexerNames" xml:space="preserve">
    <value>Dois indexadores têm nomes diferentes. O atributo IndexerName deve ser usado com o mesmo nome em cada indexador dentro de um tipo</value>
  </data>
  <data name="ERR_BadAwaiterPattern" xml:space="preserve">
    <value>"await" requer que o tipo de retorno "{0}" de "{1}.GetAwaiter()" tenha membros IsCompleted OnCompleted e GetResult adequados e implemente INotifyCompletion ou ICriticalNotifyCompletion</value>
  </data>
  <data name="ERR_AmbigContext" xml:space="preserve">
    <value>"{0}" é uma referência ambígua entre "{1}" e "{2}"</value>
  </data>
  <data name="ERR_ParamsCantBeRefOut" xml:space="preserve">
    <value>O parâmetro params não pode ser declarado como ref ou out</value>
  </data>
  <data name="WRN_CmdOptionConflictsSource_Title" xml:space="preserve">
    <value>Esta opção substitui o atributo fornecido em um arquivo de origem ou módulo adicionado</value>
  </data>
  <data name="ERR_PartialMethodMustReturnVoid" xml:space="preserve">
    <value>Os métodos parciais devem ter um tipo de retorno void</value>
  </data>
  <data name="ERR_CircularBase" xml:space="preserve">
    <value>Dependência de classe base circular envolvendo "{0}" e "{1}"</value>
  </data>
  <data name="WRN_IdentifierOrNumericLiteralExpected_Title" xml:space="preserve">
    <value>Identificador esperado ou literal numérico</value>
  </data>
  <data name="ERR_NoImplicitConv" xml:space="preserve">
    <value>Não é possível converter implicitamente tipo "{0}" em "{1}"</value>
  </data>
  <data name="WRN_FailedInclude_Title" xml:space="preserve">
    <value>Não é possível incluir fragmento XML</value>
  </data>
  <data name="ERR_InterfaceEventInitializer" xml:space="preserve">
    <value>"{0}": evento na interface não pode ter inicializador</value>
  </data>
  <data name="ERR_RecursiveConstructorCall" xml:space="preserve">
    <value>Construtor "{0}" não pode chamar a si mesmo</value>
  </data>
  <data name="ERR_SingleLineCommentInExpressionHole" xml:space="preserve">
    <value>Um comentário de uma linha não pode ser usado em uma cadeia de caracteres interpolada.</value>
  </data>
  <data name="ERR_LocalDuplicate" xml:space="preserve">
    <value>Uma variável de local ou função denominada '{0}' já está definida neste escopo</value>
  </data>
  <data name="WRN_UnifyReferenceMajMin_Description" xml:space="preserve">
    <value>Dois assemblies diferem no número de versão. Para que a união ocorra, você deve especificar as diretivas no arquivo .config do aplicativo e fornecer o nome forte correto de um assembly.</value>
  </data>
  <data name="ERR_ReturnNotLValue" xml:space="preserve">
    <value>Não é possível modificar o valor de retorno "{0}" porque ele não é uma variável</value>
  </data>
  <data name="WRN_CLS_BadBase" xml:space="preserve">
    <value>"{0}": tipo base "{1}" não tem conformidade com CLS</value>
  </data>
  <data name="ERR_AssgReadonlyLocal" xml:space="preserve">
    <value>Não é possível atribuir a "{0}" porque ele é somente leitura</value>
  </data>
  <data name="ERR_BadParamType" xml:space="preserve">
    <value>Parâmetro {0} é declarado como tipo "{1}{2}", mas deve ser "{3}{4}"</value>
  </data>
  <data name="ERR_PermissionSetAttributeFileReadError" xml:space="preserve">
    <value>Erro ao ler arquivo "{0}" especificado para o argumento nomeado "{1}" para o atributo PermissionSet: "{2}"</value>
  </data>
  <data name="ERR_DuplicateConstraintClause" xml:space="preserve">
    <value>Uma cláusula de restrição já foi especificada para parâmetro de tipo "{0}". Todas as restrições de parâmetro de tipo devem ser especificadas em uma única cláusula where.</value>
  </data>
  <data name="ERR_BadAwaitArgVoidCall" xml:space="preserve">
    <value>Não é possível aguardar "void"</value>
  </data>
  <data name="ERR_RefReturnLocal" xml:space="preserve">
    <value>Não é possível retornar o local '{0}' por referência porque ele não é um local ref</value>
  </data>
  <data name="ERR_NoDynamicPhantomOnBaseCtor" xml:space="preserve">
    <value>A chamada de construtor deve ser expedida dinamicamente, mas isso não é possível porque ela faz parte de um inicializador de construtor. Converta os argumentos dinâmicos.</value>
  </data>
  <data name="ERR_RefReturnCall2" xml:space="preserve">
    <value>Não é possível retornar por referência um membro do resultado de '{0}', porque o argumento passado para o parâmetro '{1}' não pode ser retornado por referência</value>
  </data>
  <data name="ERR_TypeInferenceFailedForImplicitlyTypedOutVariable" xml:space="preserve">
    <value>Não é possível inferir o tipo da variável out de tipo implícito '{0}'.</value>
  </data>
  <data name="ERR_NoPIAAssemblyMissingAttribute" xml:space="preserve">
    <value>Não é possível inserir tipos de interoperabilidade do assembly "{0}" porque ele está sem o "{1}" atributo.</value>
  </data>
  <data name="IDS_FeatureObjectInitializer" xml:space="preserve">
    <value>inicializador de objeto</value>
  </data>
  <data name="ERR_ImplicitlyTypedVariableMultipleDeclarator" xml:space="preserve">
    <value>Variáveis de tipo implícito não podem ter vários declaradores</value>
  </data>
  <data name="ERR_NamespaceUnexpected" xml:space="preserve">
    <value>Um namespace não pode conter diretamente membros, como campos ou métodos</value>
  </data>
  <data name="ERR_BadModifierLocation" xml:space="preserve">
    <value>Modificador de membro "{0}" deve preceder o nome e o tipo de membro</value>
  </data>
  <data name="ERR_RbraceExpected" xml:space="preserve">
    <value>} esperada</value>
  </data>
  <data name="WRN_EmptySwitch_Title" xml:space="preserve">
    <value>Bloco switch vazio</value>
  </data>
  <data name="ERR_NamedArgumentExpected" xml:space="preserve">
    <value>Argumento de atributo nomeado esperado</value>
  </data>
  <data name="ERR_ParamDefaultValueDiffersFromAttribute" xml:space="preserve">
    <value>O parâmetro tem vários valores padrão diferentes.</value>
  </data>
  <data name="ERR_DefaultValueBadValueType" xml:space="preserve">
    <value>Argumento do tipo "{0}" não é aplicável para o atributo DefaultParameterValue</value>
  </data>
  <data name="ERR_ConversionNotInvolvingContainedType" xml:space="preserve">
    <value>A conversão definida pelo usuário deve ser convertida a partir de ou em um tipo de delimitador</value>
  </data>
  <data name="ERR_StructLayoutCycle" xml:space="preserve">
    <value>Membro struct "{0}" do tipo "{1}" gera um ciclo no layout de struct</value>
  </data>
  <data name="WRN_CLS_BadTypeVar_Title" xml:space="preserve">
    <value>Tipo de restrição não tem conformidade com CLS</value>
  </data>
  <data name="ERR_AbstractAttributeClass" xml:space="preserve">
    <value>Não é possível aplicar classe de atributo "{0}" porque ela é abstract</value>
  </data>
  <data name="ERR_ConcreteMissingBody" xml:space="preserve">
    <value>"{0}" deve declarar um corpo porque não está marcado como abstract, extern ou partial</value>
  </data>
  <data name="WRN_UnreachableCode_Title" xml:space="preserve">
    <value>Código inacessível detectado</value>
  </data>
  <data name="WRN_AsyncLacksAwaits" xml:space="preserve">
    <value>Este método assíncrono não possui operadores 'await' e será executado de modo síncrono. É recomendável o uso do operador 'await' para aguardar chamadas à API desbloqueadas ou do operador 'await Task.Run(...)' para realizar um trabalho associado à CPU em um thread em segundo plano.</value>
  </data>
  <data name="ERR_QueryRangeVariableSameAsTypeParam" xml:space="preserve">
    <value>A variável de intervalo "{0}" não pode ter o mesmo nome de um parâmetro de tipo de método</value>
  </data>
  <data name="ERR_NoConstructors" xml:space="preserve">
    <value>O tipo "{0}" não tem construtores definidos</value>
  </data>
  <data name="IDS_AnonMethod" xml:space="preserve">
    <value>método anônimo</value>
  </data>
  <data name="ERR_ExpectedSingleScript" xml:space="preserve">
    <value>Era esperado um script (arquivo .csx), mas não há scripts especificados</value>
  </data>
  <data name="IDS_FeatureNullable" xml:space="preserve">
    <value>tipos anuláveis</value>
  </data>
  <data name="WRN_NoConfigNotOnCommandLine_Title" xml:space="preserve">
    <value>Ignorando a opção /noconfig porque ela foi especificada em um arquivo de resposta</value>
  </data>
  <data name="ERR_DeconstructionVarFormDisallowsSpecificType" xml:space="preserve">
    <value>O formulário de desconstrução 'var (...)' não permite um tipo específico para 'var'.</value>
  </data>
  <data name="ERR_InvalidLineNumber" xml:space="preserve">
    <value>Número de linha especificado para diretiva #line ausente ou inválido</value>
  </data>
  <data name="IDS_XMLIGNORED2" xml:space="preserve">
    <value> Arquivo XML mal formado "{0}" não pode ser incluído</value>
  </data>
  <data name="WRN_UnableToLoadAnalyzer" xml:space="preserve">
    <value>Não é possível carregar o assembly do Analisador {0} : {1}</value>
  </data>
  <data name="ERR_OperatorsMustBeStatic" xml:space="preserve">
    <value>O operador definido pelo usuário "{0}" deve ser declarado como static e public</value>
  </data>
  <data name="ERR_BadOperatorSyntax" xml:space="preserve">
    <value>Declaração não é válida; ao invés disso, use "{0} operador &lt;dest-type&gt; (..."</value>
  </data>
  <data name="ERR_ReturnTypeIsStaticClass" xml:space="preserve">
    <value>"{0}": tipos static não podem ser usados como tipos de retorno</value>
  </data>
  <data name="ERR_ExplicitImplParams" xml:space="preserve">
    <value>"{0}" não deve ter um parâmetro params porque "{1}" não tem um</value>
  </data>
  <data name="ERR_CantMakeTempFile" xml:space="preserve">
    <value>Não é possível criar arquivo temporário -- {0}</value>
  </data>
  <data name="ERR_BadNamedArgument" xml:space="preserve">
    <value>A melhor sobrecarga de "{0}" não tem um parâmetro chamado "{1}"</value>
  </data>
  <data name="ERR_TypeVariableSameAsParent" xml:space="preserve">
    <value>Parâmetro de tipo "{0}" tem o mesmo nome do tipo recipiente ou do método</value>
  </data>
  <data name="WRN_NewRequired_Title" xml:space="preserve">
    <value>O membro oculta o membro herdado; nova palavra-chave ausente</value>
  </data>
  <data name="ERR_PartialMethodOnlyInPartialClass" xml:space="preserve">
    <value>Um método parcial deve ser declarado em uma classe parcial ou estrutura parcial</value>
  </data>
  <data name="WRN_SameFullNameThisAggNs" xml:space="preserve">
    <value>O tipo "{1}" em "{0}" está em conflito com o namespace importado "{3}" em "{2}". Usar o tipo definido em "{0}".</value>
  </data>
  <data name="WRN_SameFullNameThisNsAgg" xml:space="preserve">
    <value>O namespace "{1}" em "{0}" está em conflito com o tipo importado "{3}" em "{2}". Usar o namespace definido em "{0}".</value>
  </data>
  <data name="ERR_BadArgTypesForCollectionAdd" xml:space="preserve">
    <value>O melhor método Add sobrecarregado "{0}" do inicializador de coleção tem alguns argumentos inválidos</value>
  </data>
  <data name="ERR_MissingArraySize" xml:space="preserve">
    <value>A criação de matriz deve ter tamanho de matriz ou inicializador de matriz</value>
  </data>
  <data name="WRN_MissingTypeParamTag" xml:space="preserve">
    <value>Parâmetro de tipo "{0}" não tem marca typeparam correspondente no comentário XML para "{1}" (mas outros parâmetros têm)</value>
  </data>
  <data name="WRN_IncorrectBooleanAssg" xml:space="preserve">
    <value>Atribuição em expressão condicional é sempre constante. Deseja usar == em vez de = ?</value>
  </data>
  <data name="ERR_AttributeCantBeGeneric" xml:space="preserve">
    <value>Não é possível aplicar classe de atributo "{0}" porque ela é genérica</value>
  </data>
  <data name="ERR_CantSetWin32Manifest" xml:space="preserve">
    <value>Erro ao ler o arquivo de manifesto Win32 "{0}" -- "{1}"</value>
  </data>
  <data name="WRN_AssemblyAttributeFromModuleIsOverridden" xml:space="preserve">
    <value>Atributo "{0}" do módulo "{1}" será ignorado em favor da instância que aparece na fonte</value>
  </data>
  <data name="ERR_QueryRangeVariableAssignedBadValue" xml:space="preserve">
    <value>Não é possível atribuir {0} a uma variável de intervalo</value>
  </data>
  <data name="ERR_ParamsLast" xml:space="preserve">
    <value>Um parâmetro params deve ser o último parâmetro na lista de parâmetros formal</value>
  </data>
  <data name="ERR_BadEmptyThrowInFinally" xml:space="preserve">
    <value>Não é permitida uma instrução throw sem argumentos em uma cláusula finally que está aninhada dentro da cláusula catch delimitadora mais próxima</value>
  </data>
  <data name="ERR_TupleTooFewElements" xml:space="preserve">
    <value>A tupla deve conter pelo menos dois elementos.</value>
  </data>
  <data name="ERR_BadTypeArgument" xml:space="preserve">
    <value>O tipo "{0}" não pode ser usado como um argumento de tipo</value>
  </data>
  <data name="ERR_InteropTypeMissingAttribute" xml:space="preserve">
    <value>Tipo de interoperabilidade "{0}" não pode ser inserido porque está faltando o atributo "{1}" necessário.</value>
  </data>
  <data name="ERR_TaskRetNoObjectRequiredLambda" xml:space="preserve">
    <value>Expressão lambda assíncrona convertida a um representante de retorno "Task" não pode retornar um valor. Você pretendia retornar "Task&lt;T&gt;"?</value>
  </data>
  <data name="WRN_BadUILang" xml:space="preserve">
    <value>O nome de idioma "{0}" é inválido.</value>
  </data>
  <data name="ERR_MultiTypeInDeclaration" xml:space="preserve">
    <value>Não é possível usar mais de um tipo em uma instrução for, using, fixed ou or de declaração</value>
  </data>
  <data name="ERR_QueryRangeVariableReadOnly" xml:space="preserve">
    <value>A variável de intervalo "{0}" não pode ser atribuída a -- ela é de somente leitura</value>
  </data>
  <data name="ERR_BadCtorArgCount" xml:space="preserve">
    <value>"{0}" não contém um construtor que aceita {1} argumentos</value>
  </data>
  <data name="ERR_InvalidAssemblyCulture" xml:space="preserve">
    <value>As cadeias de caracteres de cultura de assembly podem não conter caracteres NUL incorporados.</value>
  </data>
  <data name="ERR_AddrOnReadOnlyLocal" xml:space="preserve">
    <value>Não é possível obter o endereço de uma variável local somente leitura</value>
  </data>
  <data name="ERR_PatternNullableType" xml:space="preserve">
    <value>É ilegal usar o tipo que permite valor nulo '{0}' em um padrão; em vez disso, use o tipo subjacente '{1}'.</value>
  </data>
  <data name="ERR_PartialMethodParamsDifference" xml:space="preserve">
    <value>As duas declarações do método parcial devem usar um parâmetro params ou nenhuma delas pode usar um parâmetro params</value>
  </data>
  <data name="ERR_InterfaceMemberNotFound" xml:space="preserve">
    <value>"{0}" na declaração de interface explícita não é um membro de interface</value>
  </data>
  <data name="WRN_SameFullNameThisAggAgg" xml:space="preserve">
    <value>O tipo "{1}" em "{0}" está em conflito com o tipo importado "{3}" em "{2}". Usar o tipo definido em "{0}".</value>
  </data>
  <data name="ERR_ArrayElementCantBeRefAny" xml:space="preserve">
    <value>Elementos de matriz não podem ser do tipo "{0}"</value>
  </data>
  <data name="ERR_NoModifiersOnAccessor" xml:space="preserve">
    <value>Modificadores não podem ser colocados em declarações de acessador de evento</value>
  </data>
  <data name="ERR_BaseClassMustBeFirst" xml:space="preserve">
    <value>Classe base "{0}" deve vir antes de quaisquer interfaces</value>
  </data>
  <data name="ERR_CantHaveWin32ResAndManifest" xml:space="preserve">
    <value>Opções de conflito especificadas: Arquivo de recurso Win32; manifesto Win32</value>
  </data>
  <data name="ERR_UnsafeIteratorArgType" xml:space="preserve">
    <value>Iteradores não podem ter tipos yield nem parâmetros sem segurança</value>
  </data>
  <data name="ERR_NoConversionForCallerMemberNameParam" xml:space="preserve">
    <value>CallerMemberNameAttribute não pode ser aplicado porque não há conversões padrões do tipo "{0}" para o tipo "{1}"</value>
  </data>
  <data name="ERR_RefReturnParameter2" xml:space="preserve">
    <value>Não é possível retornar um membro do parâmetro '{0}' por referência, pois ele não é um parâmetro ref ou out</value>
  </data>
  <data name="IDS_RELATEDERROR" xml:space="preserve">
    <value>(Local do símbolo relacionado ao erro anterior)</value>
  </data>
  <data name="ERR_BadYieldInCatch" xml:space="preserve">
    <value>Não é possível usar a instrução yield no corpo de uma cláusula catch</value>
  </data>
  <data name="ERR_BadAsyncReturnExpression" xml:space="preserve">
    <value>Como este é um método assíncrono, a expressão de retorno deve ser do tipo "{0}" em vez de "Task&lt;{0}&gt;"</value>
  </data>
  <data name="ERR_SemiOrLBraceExpected" xml:space="preserve">
    <value>{ ou ; esperado</value>
  </data>
  <data name="ERR_ThisInStaticMeth" xml:space="preserve">
    <value>A palavra-chave 'this' não é válida em uma propriedade, um método ou um inicializador de campo estático</value>
  </data>
  <data name="IDS_FeatureOptionalParameter" xml:space="preserve">
    <value>parâmetro opcional</value>
  </data>
  <data name="WRN_InvalidSearchPathDir_Title" xml:space="preserve">
    <value>Caminho de pesquisa especificado inválido</value>
  </data>
  <data name="ERR_RefReturnCall" xml:space="preserve">
    <value>Não é possível retornar por referência um resultado de '{0}', pois o argumento passado para o parâmetro '{1}' não pode ser retornado por referência</value>
  </data>
  <data name="ERR_NoCanonicalView" xml:space="preserve">
    <value>Não é possível encontrar o tipo de interoperabilidade que corresponda ao tipo de interoperabilidade inserido "{0}". Está faltando uma referência de assembly?</value>
  </data>
  <data name="WRN_CmdOptionConflictsSource_Description" xml:space="preserve">
    <value>Este aviso ocorre se os atributos de assembly AssemblyKeyFileAttribute ou o AssemblyKeyNameAttribute encontrados na fonte estiverem em conflito com a opção de linha de comando /keyfile ou /keycontainer ou nome do arquivo-chave ou contêiner-chave especificado nas propriedades do projeto.</value>
  </data>
  <data name="WRN_InvalidAssemblyName_Description" xml:space="preserve">
    <value>Este aviso indica que um atributo, como InternalsVisibleToAttribute, não foi especificado corretamente.</value>
  </data>
  <data name="ERR_ByReferenceVariableMustBeInitialized" xml:space="preserve">
    <value>A declaração de uma variável por referência deve ter um inicializador</value>
  </data>
  <data name="ERR_SynchronizedAsyncMethod" xml:space="preserve">
    <value>Não é possível aplicar 'MethodImplOptions.Synchronized' a um método assíncrono</value>
  </data>
  <data name="ERR_RefReturnParameter" xml:space="preserve">
    <value>Não é possível retornar um parâmetro por referência '{0}', pois ele não é um parâmetro ref ou out</value>
  </data>
  <data name="ERR_NoNamespacePrivate" xml:space="preserve">
    <value>Os elementos definidos em um namespace não podem ser declarados explicitamente como privado, protegido ou interno protegido</value>
  </data>
  <data name="ERR_AssemblyNameOnNonModule" xml:space="preserve">
    <value>A opção /moduleassemblyname só pode ser especificada ao criar um tipo de destino de 'module'</value>
  </data>
  <data name="ERR_BaseConstraintConflict" xml:space="preserve">
    <value>O parâmetro de tipo "{0}" herda as restrições conflitantes "{1}" e "{2}"</value>
  </data>
  <data name="ERR_ResourceNotUnique" xml:space="preserve">
    <value>Identificador de recurso "{0}" já foi usado neste assembly</value>
  </data>
  <data name="ERR_DefaultValueMustBeConstant" xml:space="preserve">
    <value>Valor do parâmetro padrão "{0}" deve ser uma constante de tempo de compilação</value>
  </data>
  <data name="ERR_NoEntryPoint" xml:space="preserve">
    <value>Programa não contém um método "Main" estático adequado para um ponto de entrada</value>
  </data>
  <data name="WRN_MultiplePredefTypes_Description" xml:space="preserve">
    <value>Este erro ocorre quando um tipo predefinido do sistema, como System.Int32, encontra-se em dois assemblies. Uma forma que pode fazer isso acontecer é referenciar mscorlib ou System.Runtime.dll de dois lugares diferentes, por exemplo, tentando executar duas versões de .NET Framework lado a lado.</value>
  </data>
  <data name="ERR_RefReturnNonreturnableLocal2" xml:space="preserve">
    <value>Não é possível retornar por referência um membro de '{0}' porque ele foi inicializado para um valor que não pode ser retornado por referência</value>
  </data>
  <data name="WRN_CLS_NoVarArgs_Title" xml:space="preserve">
    <value>Métodos com argumentos de variável não estão em conformidade com CLS</value>
  </data>
  <data name="UseLiteralForNumeric" xml:space="preserve">
    <value>Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal para criar tokens literais numéricos.</value>
  </data>
  <data name="ERR_PartialMethodStaticDifference" xml:space="preserve">
    <value>As duas declarações de métodos parciais devem ser estáticas ou nenhuma delas deve ser desse tipo</value>
  </data>
  <data name="ERR_LockNeedsReference" xml:space="preserve">
    <value>"{0}" não é um tipo de referência como necessário pela instrução lock</value>
  </data>
  <data name="ERR_RefReturnReadonlyStatic" xml:space="preserve">
    <value>Um campo somente leitura estático não pode ser retornado por referência</value>
  </data>
  <data name="WRN_CLS_BadInterfaceMember_Title" xml:space="preserve">
    <value>Interfaces em conformidade com CLS devem ter somente membros em conformidade com CLS</value>
  </data>
  <data name="WRN_CLS_ModuleMissingCLS_Title" xml:space="preserve">
    <value>Módulos adicionados devem ser marcados com o atributo CLSCompliant para corresponder ao assembly</value>
  </data>
  <data name="ERR_LocalSameNameAsTypeParam" xml:space="preserve">
    <value>'{0}': um parâmetro, variável de local ou função de local não pode ter o mesmo nome que um parâmetro de tipo de método</value>
  </data>
  <data name="WRN_CLS_BadReturnType_Title" xml:space="preserve">
    <value>Tipo de retorno não tem conformidade com CLS</value>
  </data>
  <data name="ERR_CantOpenIcon" xml:space="preserve">
    <value>Erro ao abrir o arquivo de ícones {0} -- {1}</value>
  </data>
  <data name="SyntaxTreeNotFoundTo" xml:space="preserve">
    <value>SyntaxTree "{0}" não encontrada para remover</value>
  </data>
  <data name="ERR_TypeInferenceFailedForImplicitlyTypedDeconstructionVariable" xml:space="preserve">
    <value>Não é possível inferir o tipo da variável de desconstrução digitada implicitamente '{0}'.</value>
  </data>
  <data name="ERR_OverrideWithConstraints" xml:space="preserve">
    <value>Restrições para métodos de substituição e implementação de interface explícita são herdadas do método base, por isso não podem ser especificadas diretamente</value>
  </data>
  <data name="WRN_FileNameTooLong_Title" xml:space="preserve">
    <value>Nome de arquivo inválido especificado para diretiva de pré-processamento</value>
  </data>
  <data name="ERR_UnescapedCurly" xml:space="preserve">
    <value>Um caractere '{0}' deve ser de escape (ao duplicar) em uma cadeia de caracteres interpolada.</value>
  </data>
  <data name="IDS_FeatureExtensionMethod" xml:space="preserve">
    <value>método de extensão</value>
  </data>
  <data name="ERR_ExpressionHasNoName" xml:space="preserve">
    <value>A expressão não tem um nome.</value>
  </data>
  <data name="FTL_DebugEmitFailure" xml:space="preserve">
    <value>Erro inesperado ao gravar informações de depuração -- "{0}"</value>
  </data>
  <data name="CompilationC" xml:space="preserve">
    <value>Compilação (C#): </value>
  </data>
  <data name="WRN_CLS_BadFieldPropType_Title" xml:space="preserve">
    <value>Tipo tem conformidade com CLS</value>
  </data>
  <data name="ERR_ConvertToStaticClass" xml:space="preserve">
    <value>Não é possível converter em tipo estático "{0}"</value>
  </data>
  <data name="WRN_CLS_BadAttributeType_Title" xml:space="preserve">
    <value>O tipo não tem nenhum construtor acessível que use somente tipos em conformidade com CLS</value>
  </data>
  <data name="WRN_CLS_IllegalTrueInFalse" xml:space="preserve">
    <value>"{0}" não pode ser marcado como em conformidade com CLS porque é membro do tipo não tem conformidade com CLS "{1}"</value>
  </data>
  <data name="IDS_FeatureAnonymousTypes" xml:space="preserve">
    <value>tipos anônimos</value>
  </data>
  <data name="ERR_StaticConstant" xml:space="preserve">
    <value>A constante "{0}" não pode ser marcada como static</value>
  </data>
  <data name="ERR_PropertyLacksGet" xml:space="preserve">
    <value>A propriedade ou o indexador "{0}" não pode ser usado neste contexto porque não possui o acessador get</value>
  </data>
  <data name="ERR_LanguageVersionCannotHaveLeadingZeroes" xml:space="preserve">
    <value>A versão de linguagem '{0}' especificada não pode ter zeros à esquerda</value>
  </data>
  <data name="ERR_OpenResponseFile" xml:space="preserve">
    <value>Erro ao abrir arquivo de resposta "{0}"</value>
  </data>
  <data name="WRN_DeprecatedCollectionInitAdd_Title" xml:space="preserve">
    <value>O melhor método Add sobrecarregado para o elemento do inicializador de coleta está obsoleto</value>
  </data>
  <data name="ERR_BadVisOpReturn" xml:space="preserve">
    <value>Acessibilidade inconsistente: tipo de retorno "{1}" é menos acessível do que o operador "{0}"</value>
  </data>
  <data name="HDN_UnusedExternAlias" xml:space="preserve">
    <value>Alias externo não usado.</value>
  </data>
  <data name="ERR_ImplicitlyTypedOutVariableUsedInTheSameArgumentList" xml:space="preserve">
    <value>Referência a uma variável '{0}' digitada implicitamente não é permitida na mesma lista de argumentos.</value>
  </data>
  <data name="ERR_MissingPartial" xml:space="preserve">
    <value>Modificador parcial ausente na declaração do tipo "{0}"; existe outra declaração parcial deste tipo</value>
  </data>
  <data name="ERR_NoSetToOverride" xml:space="preserve">
    <value>"{0}": não pode substituir porque "{1}" não tem um acessador set substituível</value>
  </data>
  <data name="ERR_BadExternAlias" xml:space="preserve">
    <value>O alias extern "{0}" não foi especificado em uma opção /reference</value>
  </data>
  <data name="WRN_DefaultInSwitch_Title" xml:space="preserve">
    <value>Você pretendia usar o rótulo de switch padrão (`default:`) em vez de `case default:`? Caso realmente pretenda utilizar o valor literal padrão, considere `case (default):` ou outro valor literal (`case 0:` ou `case null:`) conforme apropriado.</value>
  </data>
  <data name="WRN_InvalidAttributeLocation" xml:space="preserve">
    <value>"{0}" não é um local de atributo reconhecido. Locais de atributo válidso para essa declaração são '{1}'. Todos os atributos neste bloco serão ignorados.</value>
  </data>
  <data name="ERR_BadParamRef" xml:space="preserve">
    <value>Parâmetro {0} deve ser declarado com a palavra-chave "{1}"</value>
  </data>
  <data name="ERR_MissingSourceInterface" xml:space="preserve">
    <value>Interface "{0}" tem uma interface de origem inválida que é necessária para incorporar o evento "{1}".</value>
  </data>
  <data name="ERR_InitializerAddHasParamModifiers" xml:space="preserve">
    <value>A melhor correspondência de método sobrecarregado "{0}" do elemento de inicializador de coleção não pode ser usada. Os métodos "Add" do inicializador de coleção não podem ter os parâmetros ref ou out.</value>
  </data>
  <data name="ERR_OverrideNotExpected" xml:space="preserve">
    <value>"{0}": não encontrado nenhum método adequado para substituição</value>
  </data>
  <data name="IDS_PathList" xml:space="preserve">
    <value>&lt;lista de caminho&gt;</value>
  </data>
  <data name="ERR_AssgReadonlyLocal2Cause" xml:space="preserve">
    <value>Não é possível modificar membros de "{0}" porque ele é um "{1}"</value>
  </data>
  <data name="WRN_CLS_NoAbstractMembers" xml:space="preserve">
    <value>"{0}": somente membros em conformidade com CLS podem ser abstratos</value>
  </data>
  <data name="HDN_UnusedUsingDirective_Title" xml:space="preserve">
    <value>Diretiva de uso desnecessária</value>
  </data>
  <data name="ERR_CantRefResource" xml:space="preserve">
    <value>Não é possível vincular arquivos de recursos ao criar um módulo</value>
  </data>
  <data name="IDS_GlobalNamespace" xml:space="preserve">
    <value>&lt;namespace global&gt;</value>
  </data>
  <data name="ERR_CircularConstraint" xml:space="preserve">
    <value>Dependência de restrição circular envolvendo "{0}" e "{1}"</value>
  </data>
  <data name="WRN_EqualityOpWithoutGetHashCode" xml:space="preserve">
    <value>"{0}" define o operador = = ou operador !=, mas não substitui Object.GetHashCode()</value>
  </data>
  <data name="ERR_BadBinaryOperatorSignature" xml:space="preserve">
    <value>Um dos parâmetros de um operador binário deve ser do tipo recipiente</value>
  </data>
  <data name="ERR_DoesntImplementAwaitInterface" xml:space="preserve">
    <value>"{0}" não implementa "{1}"</value>
  </data>
  <data name="ERR_BadProtectedAccess" xml:space="preserve">
    <value>Não é possível acessar membro protegido "{0}" através de um qualificador do tipo "{1}"; o qualificador deve ser do tipo "{2}" (ou derivado dele)</value>
  </data>
  <data name="ERR_MissingPredefinedMember" xml:space="preserve">
    <value>Membro "{0}.{1}" necessário ao compilador ausente</value>
  </data>
  <data name="ERR_GlobalAttributesNotAllowed" xml:space="preserve">
    <value>Atributos assembly e module não são permitidos neste contexto</value>
  </data>
  <data name="WRN_EndOfPPLineExpected" xml:space="preserve">
    <value>Comentário de linha única ou final de linha esperado</value>
  </data>
  <data name="WRN_NewNotRequired_Title" xml:space="preserve">
    <value>O membro não oculta um membro herdado; não é necessária uma nova palavra-chave</value>
  </data>
  <data name="ERR_InitializerInStructWithoutExplicitConstructor" xml:space="preserve">
    <value>Estruturas sem construtores explícitos não podem conter membros com inicializadores.</value>
  </data>
  <data name="ERR_ConstraintIsStaticClass" xml:space="preserve">
    <value>"{0}": classes estáticas não podem ser utilizadas como restrições</value>
  </data>
  <data name="ERR_BadAsyncReturn" xml:space="preserve">
    <value>O tipo de retorno de um método assíncrono deve ser void, Task ou Task&lt;T&gt;</value>
  </data>
  <data name="WRN_BadXMLRef" xml:space="preserve">
    <value>O comentário XML tem atributo cref "{0}" que não pode ser resolvido</value>
  </data>
  <data name="ERR_DottedTypeNameNotFoundInNSFwd" xml:space="preserve">
    <value>O nome do tipo "{0}" não pode ser encontrado no namespace "{1}". Este tipo foi encaminhado para o assembly "{2}" Considere adicionar uma referência a esse assembly.</value>
  </data>
  <data name="ERR_AnonMethGrpInForEach" xml:space="preserve">
    <value>Foreach não pode operar em um "{0}". Você pretendia invocar o "{0}"?</value>
  </data>
  <data name="WRN_VolatileByRef_Title" xml:space="preserve">
    <value>Uma referência a um campo volátil não será tratada como volátil</value>
  </data>
  <data name="WRN_CallOnNonAgileField_Title" xml:space="preserve">
    <value>Acessar um membro em um campo de uma classe de empacotamento por referência pode gerar uma exceção de tempo de execução</value>
  </data>
  <data name="ERR_FieldCantHaveVoidType" xml:space="preserve">
    <value>O campo não pode ter tipo void</value>
  </data>
  <data name="WRN_CLS_BadBase_Title" xml:space="preserve">
    <value>Tipo base não tem conformidade com CLS</value>
  </data>
  <data name="ERR_ExtensionMethodsDecl" xml:space="preserve">
    <value>Métodos de extensão devem ser definidos em uma classe estática de nível superior; {0} é uma classe aninhada</value>
  </data>
  <data name="ERR_NetModuleNameMustBeUnique" xml:space="preserve">
    <value>Módulo "{0}" já está definido neste assembly. Cada módulo deve ter um filename exclusivo.</value>
  </data>
  <data name="ERR_AttributesNotAllowed" xml:space="preserve">
    <value>Atributos não são válidos neste contexto.</value>
  </data>
  <data name="IDS_FeatureFixedBuffer" xml:space="preserve">
    <value>buffers de tamanho fixo</value>
  </data>
  <data name="ERR_UnexpectedSemicolon" xml:space="preserve">
    <value>Ponto-e-vírgula após bloco de acessador ou método não é válido</value>
  </data>
  <data name="ERR_LocalTypeNameClash" xml:space="preserve">
    <value>Incorporar o tipo de interoperabilidade "{0}" do assembly "{1}" causa um conflito de nome no assembly atual. Considere definir a propriedade "Incorporar Tipos de Interoperabilidade" como falsa.</value>
  </data>
  <data name="WRN_CLS_NoVarArgs" xml:space="preserve">
    <value>Métodos com argumentos de variável não estão em conformidade com CLS</value>
  </data>
  <data name="ERR_AccessModMissingAccessor" xml:space="preserve">
    <value>"{0}": modificadores de acessibilidade nos assessores podem somente ser usados se a propriedade ou o indexador tiver um acessador get e um accessador set</value>
  </data>
  <data name="ERR_DynamicAttributeMissing" xml:space="preserve">
    <value>Não é possível definir uma classe ou membro que utiliza "dynamic" porque o tipo necessário pelo compilador "{0}" não pode ser encontrado. </value>
  </data>
  <data name="ERR_AbstractField" xml:space="preserve">
    <value>O modificador 'abstract' não é válido em campos. Em vez disso, tente usar uma propriedade.</value>
  </data>
  <data name="IDS_FeatureSwitchOnBool" xml:space="preserve">
    <value>opção em tipo booleano</value>
  </data>
  <data name="WRN_AlwaysNull" xml:space="preserve">
    <value>O resultado da expressão sempre é "null" do tipo "{0}"</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnReturn_Title" xml:space="preserve">
    <value>O atributo CLSCompliant não tem sentido quando aplicado a tipos de retorno</value>
  </data>
  <data name="ERR_CantConvAnonMethReturns" xml:space="preserve">
    <value>Não é possível converter {0} para o tipo delegate pretendido porque alguns dos tipos de retorno no bloco não são implicitamente conversíveis para o tipo de retorno delegate</value>
  </data>
  <data name="WRN_MissingXMLComment" xml:space="preserve">
    <value>Comentário XML ausente para tipo publicamente visível ou membro "{0}"</value>
  </data>
  <data name="WRN_MultipleRuntimeImplementationMatches" xml:space="preserve">
    <value>Membro "{0}" implementa membro de interface "{1}" no tipo "{2}". Há várias correspondências para o membro de interface em tempo de execução. Ele é dependente de implementação cujo método será chamado.</value>
  </data>
  <data name="WRN_ErrorOverride_Description" xml:space="preserve">
    <value>O compilador emite esse aviso quando substitui um erro com um aviso. Para obter informações sobre o problema, procure o código de erro mencionado.</value>
  </data>
  <data name="IDS_USINGLOCAL" xml:space="preserve">
    <value>variável using</value>
  </data>
  <data name="ERR_NewBoundMustBeLast" xml:space="preserve">
    <value>A restrição new() deve ser a última especificada</value>
  </data>
  <data name="ERR_DuplicateInterfaceWithTupleNamesInBaseList" xml:space="preserve">
    <value>'{0}' já está listado na lista de interface no tipo '{2}' com nomes de elemento de tupla diferentes, como '{1}'.</value>
  </data>
  <data name="WRN_UnassignedInternalField" xml:space="preserve">
    <value>Campo "{0}" nunca é atribuído e sempre terá seu valor padrão {1}</value>
  </data>
  <data name="ERR_FriendAssemblySNReq" xml:space="preserve">
    <value>Referência do assembly Friend "{0}" é inválida. Assemblies assinados com nome forte devem especificar uma chave pública em suas declarações InternalsVisibleTo.</value>
  </data>
  <data name="WRN_CLS_BadInterface_Title" xml:space="preserve">
    <value>O tipo não tem conformidade com CLS porque a interface base não tem conformidade com CLS</value>
  </data>
  <data name="ERR_MemberAlreadyExists" xml:space="preserve">
    <value>Tipo "{1}" já define um membro chamado "{0}" com os mesmos tipos de parâmetro</value>
  </data>
  <data name="IDS_XMLIGNORED" xml:space="preserve">
    <value>&lt;! -- Comentário XML mal formado ignorado para o membro "{0}" --&gt;</value>
  </data>
  <data name="ERR_CantConvAnonMethNoParams" xml:space="preserve">
    <value>Não é possível converter bloco de métodos anônimos sem uma lista de parâmetros de tipo delegate "{0}" porque ele tem um ou mais parâmetros out</value>
  </data>
  <data name="ERR_ConditionalOnNonAttributeClass" xml:space="preserve">
    <value>Atributo "{0}" é somente válido em métodos ou classes de atributo</value>
  </data>
  <data name="ERR_NoVoidHere" xml:space="preserve">
    <value>A palavra-chave 'void' não pode ser usada neste contexto</value>
  </data>
  <data name="ERR_DuplicateNameInNS" xml:space="preserve">
    <value>O namespace "{1}" já contém uma definição para "{0}"</value>
  </data>
  <data name="ItemsMustBeNonEmpty" xml:space="preserve">
    <value>itens: devem ser não vazios</value>
  </data>
  <data name="WRN_IdentifierOrNumericLiteralExpected" xml:space="preserve">
    <value>Identificador esperado ou literal numérico.</value>
  </data>
  <data name="WRN_UnmatchedParamRefTag" xml:space="preserve">
    <value>Comentário XML em "{1}" tem uma marca de paramref para "{0}", mas não há parâmetro por esse nome</value>
  </data>
  <data name="ERR_OvlUnaryOperatorExpected" xml:space="preserve">
    <value>Operador unário que pode ser sobrecarregado é esperado</value>
  </data>
  <data name="ERR_BadOpOnNullOrDefault" xml:space="preserve">
    <value>O operador '{0}' não pode ser aplicado ao operando '{1}'</value>
  </data>
  <data name="ERR_LookupInTypeVariable" xml:space="preserve">
    <value>Não é possível fazer pesquisa de membro em "{0}" porque ele é um parâmetro de tipo</value>
  </data>
  <data name="ERR_NetModuleNameMismatch" xml:space="preserve">
    <value>Nome do módulo "{0}" armazenado em "{1}" deve coincidir com seu filename.</value>
  </data>
  <data name="WRN_ByRefNonAgileField" xml:space="preserve">
    <value>Usar '{0}' como um valor ref ou out ou obter seu endereço pode gerar uma exceção de tempo de execução porque ele é um campo de uma classe mashal por referência</value>
  </data>
  <data name="WRN_InvalidVersionFormat" xml:space="preserve">
    <value>A cadeia de caracteres de versão especificada não está de acordo com o formato recomendado - major.minor.build.revision</value>
  </data>
  <data name="ERR_ArrayOfStaticClass" xml:space="preserve">
    <value>"{0}": elementos de matriz não podem ser do tipo static</value>
  </data>
  <data name="ERR_InvalidQM" xml:space="preserve">
    <value>Tipo de expressão condicional não pode ser determinado porque não há conversão implícita entre "{0}" e "{1}"</value>
  </data>
  <data name="ERR_AssgReadonlyLocalCause" xml:space="preserve">
    <value>Não é possível atribuir a "{0}" porque ele é um "{1}"</value>
  </data>
  <data name="ERR_BadEventUsage" xml:space="preserve">
    <value>O evento "{0}" pode apenas aparecer à esquerda de + = ou -= (exceto quando usado de dentro do tipo "{1}")</value>
  </data>
  <data name="ERR_InaccessibleSetter" xml:space="preserve">
    <value>A propriedade ou o indexador "{0}" não pode ser usado neste contexto porque o acessador set é inacessível</value>
  </data>
  <data name="ERR_NamedArgumentUsedInPositional" xml:space="preserve">
    <value>O argumento nomeado "{0}" especifica um parâmetro para o qual já foi atribuído um argumento posicional</value>
  </data>
  <data name="ERR_MethGrpToNonDel" xml:space="preserve">
    <value>Não é possível converter o grupo de métodos "{0}" no tipo "{1}" não delegado. Você pretendia invocar o método?</value>
  </data>
  <data name="WRN_CantHaveManifestForModule_Title" xml:space="preserve">
    <value>Ignore /win32manifest do módulo porque ele só se aplica aos assemblies</value>
  </data>
  <data name="ERR_BadGetEnumerator" xml:space="preserve">
    <value>foreach requer que o tipo de retorno "{0}" de "{1}" deve ter um método MoveNext público adequado e a propriedade Current pública</value>
  </data>
  <data name="IDS_RELATEDWARNING" xml:space="preserve">
    <value>(Local do símbolo relacionado ao aviso anterior)</value>
  </data>
  <data name="ERR_ArrayInitInBadPlace" xml:space="preserve">
    <value>Inicializadores de matriz só podem ser usados em um inicializador de campo ou variável. Tente usar uma expressão new.</value>
  </data>
  <data name="IDS_NULL" xml:space="preserve">
    <value>&lt;nulo&gt;</value>
  </data>
  <data name="IDS_Text" xml:space="preserve">
    <value>&lt;texto&gt;</value>
  </data>
  <data name="ERR_DelegateRefMismatch" xml:space="preserve">
    <value>Incompatibilidade de referência entre '{0}' e o delegado '{1}'</value>
  </data>
  <data name="ERR_CantOverrideNonFunction" xml:space="preserve">
    <value>"{0}": não é possível substituir porque "{1}" não é uma função</value>
  </data>
  <data name="IDS_FeatureImplicitLocal" xml:space="preserve">
    <value>variável local digitada implicitamente</value>
  </data>
  <data name="ERR_PredefinedValueTupleTypeMustBeStruct" xml:space="preserve">
    <value>O tipo predefinido '{0}' deve ser um struct.</value>
  </data>
  <data name="IDS_FeatureImplicitArray" xml:space="preserve">
    <value>matriz digitada implicitamente</value>
  </data>
  <data name="UseVerbatimIdentifier" xml:space="preserve">
    <value>Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Identifier ou Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VerbatimIdentifier para criar tokens de identificador.</value>
  </data>
  <data name="ERR_FieldInitializerInStruct" xml:space="preserve">
    <value>'{0}': não é possível ter propriedade de instância ou inicializadores de campo em estruturas</value>
  </data>
  <data name="ERR_IteratorInInteractive" xml:space="preserve">
    <value>Instruções yield podem não aparecer no nível superior no código interativo.</value>
  </data>
  <data name="ERR_NoConvToIDisp" xml:space="preserve">
    <value>"{0}": tipo usado em uma instrução using deve ser implicitamente conversível para "System. IDisposable"</value>
  </data>
  <data name="WRN_BadRefCompareLeft" xml:space="preserve">
    <value>Comparação de referência não intencional possível; para obter uma comparação de valor, converta o lado esquerdo para o tipo "{0}"</value>
  </data>
  <data name="ERR_InvalidArray" xml:space="preserve">
    <value>Especificador de classificação inválido: era esperado "," ou "]"</value>
  </data>
  <data name="ERR_DuplicateAccessor" xml:space="preserve">
    <value>O acessador de propriedade já está definido</value>
  </data>
  <data name="ERR_ImplicitlyTypedVariableAssignedArrayInitializer" xml:space="preserve">
    <value>Não é possível inicializar uma variável de tipo implícito com um inicializador de matriz</value>
  </data>
  <data name="ERR_NewlineInConst" xml:space="preserve">
    <value>Newline em constante</value>
  </data>
  <data name="ERR_GenericDerivingFromAttribute" xml:space="preserve">
    <value>Um tipo genérico não pode derivar de "{0}" porque ele é uma classe de atributo</value>
  </data>
  <data name="WRN_AnalyzerCannotBeCreated_Title" xml:space="preserve">
    <value>Não é possível criar uma instância do analisador</value>
  </data>
  <data name="ERR_BadIteratorReturn" xml:space="preserve">
    <value>O corpo de "{0}" não pode ser um bloco de iteradores porque "{1}" não é um tipo de interface de iterador</value>
  </data>
  <data name="ERR_NotConstantExpression" xml:space="preserve">
    <value>A expressão que está sendo atribuída a "{0}" deve ser constante</value>
  </data>
  <data name="ERR_ArraySizeInDeclaration" xml:space="preserve">
    <value>O tamanho de matriz não pode ser especificado em uma declaração de variável (tente inicializar com uma expressão 'new')</value>
  </data>
  <data name="ERR_AbstractEventInitializer" xml:space="preserve">
    <value>"{0}": evento abstract não pode ter inicializador</value>
  </data>
  <data name="ERR_DuplicateImport" xml:space="preserve">
    <value>Vários assemblies com identidade equivalente foram importados: "{0}" e "{1}". Remova uma das referências duplicadas.</value>
  </data>
  <data name="ERR_SameFullNameThisAggThisNs" xml:space="preserve">
    <value>O tipo "{1}" em "{0}" está em conflito com o namespace "{3}" em "{2}"</value>
  </data>
  <data name="WRN_CallerLineNumberParamForUnconsumedLocation_Title" xml:space="preserve">
    <value>O CallerLineNumberAttribute não tem efeito porque ele se aplica a um membro que é usado em contextos que não aceitam argumentos opcionais</value>
  </data>
  <data name="ERR_TypeExpected" xml:space="preserve">
    <value>Tipo esperado</value>
  </data>
  <data name="PositionNotWithinTree" xml:space="preserve">
    <value>A posição deve ser dentro do intervalo da árvore de sintaxe.</value>
  </data>
  <data name="ERR_ExpressionTreeContainsMultiDimensionalArrayInitializer" xml:space="preserve">
    <value>Uma árvore de expressões não pode conter um inicializador de matriz multidimensional</value>
  </data>
  <data name="ERR_InterfacesCantContainFields" xml:space="preserve">
    <value>Interfaces não podem conter campos</value>
  </data>
  <data name="ERR_RefReturnNonreturnableLocal" xml:space="preserve">
    <value>Não é possível retornar '{0}' por referência porque ele foi inicializado para um valor que não pode ser retornado por referência</value>
  </data>
  <data name="ERR_UnexpectedAliasedName" xml:space="preserve">
    <value>Uso inesperado de um nome com alias</value>
  </data>
  <data name="ERR_BadParamModThis" xml:space="preserve">
    <value>Uma matriz de parâmetro não pode ser usada com o modificador 'this' em um método de extensão</value>
  </data>
  <data name="ERR_NoDynamicPhantomOnBase" xml:space="preserve">
    <value>A chamada para o método "{0}" precisa ser despachada dinamicamente, mas não pode ser porque ela é parte de uma expressão de acesso básica. Considere converter argumentos dinâmicos ou eliminar o acesso básico.</value>
  </data>
  <data name="ERR_SealedStaticClass" xml:space="preserve">
    <value>"{0}": uma classe não pode ser static e sealed</value>
  </data>
  <data name="ERR_PartialTypeKindConflict" xml:space="preserve">
    <value>Declarações parciais de "{0}" devem ser todas classes, todas as estruturas ou todas as interfaces</value>
  </data>
  <data name="WRN_CLS_VolatileField" xml:space="preserve">
    <value>Campo em conformidade com CLS "{0}" não pode ser volátil</value>
  </data>
  <data name="ERR_ExpectedContextualKeywordEquals" xml:space="preserve">
    <value>Palavra-chave contextual esperada 'equals'</value>
  </data>
  <data name="ERR_LegacyObjectIdSyntax" xml:space="preserve">
    <value>A sintaxe de 'id#' não tem mais suporte. Use '$id'.</value>
  </data>
  <data name="WRN_MainIgnored_Title" xml:space="preserve">
    <value>O ponto de entrada do programa é o código de script global; ignorando o ponto de entrada</value>
  </data>
  <data name="WRN_UnreferencedField_Title" xml:space="preserve">
    <value>O campo nunca é usado</value>
  </data>
  <data name="WRN_CA2202_DoNotDisposeObjectsMultipleTimes" xml:space="preserve">
    <value>Objeto "{0}" pode ser descartado mais de uma vez.</value>
  </data>
  <data name="ERR_CloseUnimplementedInterfaceMemberWrongRefReturn" xml:space="preserve">
    <value>O '{0}' não implementa o membro de inferface '{1}'. O '{2}' não pode implementar '{1}' pois ele não é retornado por {3}</value>
  </data>
  <data name="ERR_FixedNeedsLvalue" xml:space="preserve">
    <value>Buffers de tamanho fixo só podem ser acessados por meio de locais ou campos</value>
  </data>
  <data name="WRN_UnmatchedTypeParamRefTag" xml:space="preserve">
    <value>Comentário XML em "{1}" tem uma marca de typeparamref para "{0}", mas não há parâmetro de tipo com esse nome</value>
  </data>
  <data name="WRN_UnqualifiedNestedTypeInCref_Title" xml:space="preserve">
    <value>Em atributos cref, tipos aninhados de tipos genéricos devem ser qualificados</value>
  </data>
  <data name="ERR_ExpressionTreeContainsNamedArgument" xml:space="preserve">
    <value>Uma árvore de expressão não pode conter uma especificação de argumento nomeado</value>
  </data>
  <data name="FTL_InvalidTarget" xml:space="preserve">
    <value>Tipo de destino inválido para /target: deve especificar "exe", "winexe", "library" ou "module"</value>
  </data>
  <data name="ERR_AssgReadonlyStatic" xml:space="preserve">
    <value>Um campo somente leitura estático não pode ser atribuído (exceto em um construtor estático ou inicializador de variável)</value>
  </data>
  <data name="ERR_ObjectProhibited" xml:space="preserve">
    <value>O membro "{0}" não pode ser acessado com uma referência de instância; qualifique-o com um nome de tipo</value>
  </data>
  <data name="WRN_AssignmentToLockOrDispose_Title" xml:space="preserve">
    <value>Atribuição possivelmente incorreta ao local que é o argumento para uma instrução using ou lock</value>
  </data>
  <data name="ERR_BadFinallyLeave" xml:space="preserve">
    <value>O controle não pode sair do corpo de uma cláusula finally</value>
  </data>
  <data name="SyntaxNodeIsNotWithinSynt" xml:space="preserve">
    <value>Nó de sintaxe não está dentro da árvore de sintaxe</value>
  </data>
  <data name="ERR_MustNotHaveRefReturn" xml:space="preserve">
    <value>Retornos por referência podem ser usados somente em métodos que são retornados por referência</value>
  </data>
  <data name="ERR_BadConstType" xml:space="preserve">
    <value>O tipo "{0}" não pode ser declarado const</value>
  </data>
  <data name="ERR_BadAsyncArgType" xml:space="preserve">
    <value>Os métodos assíncronos não podem ter parâmetros ref ou out</value>
  </data>
  <data name="ERR_SwitchFallOut" xml:space="preserve">
    <value>O controle não pode ficar fora do switch do rótulo de caso final ('{0}')</value>
  </data>
  <data name="WRN_DuplicateUsing" xml:space="preserve">
    <value>A diretiva using para "{0}" apareceu anteriormente neste namespace</value>
  </data>
  <data name="ERR_BindToBogusProp1" xml:space="preserve">
    <value>O idioma não dá suporte à propriedade, ao indexador ou ao evento "{0}"; tente chamar diretamente o método de acessador "{1}"</value>
  </data>
  <data name="ERR_BindToBogusProp2" xml:space="preserve">
    <value>O idioma não dá suporte à propriedade, ao indexador ou ao evento "{0}"; tente chamar diretamente o método de acessador "{1}" ou "{2}"</value>
  </data>
  <data name="ERR_ConversionWithInterface" xml:space="preserve">
    <value>"{0}": conversões definidas pelo usuário para ou de uma interface não são permitidas</value>
  </data>
  <data name="ERR_NoRefOutWhenRefOnly" xml:space="preserve">
    <value>Não use refout ao usar refonly.</value>
  </data>
  <data name="ERR_AnonDelegateCantUse" xml:space="preserve">
    <value>Não é possível usar parâmetro ref ou out "{0}" dentro de um método anônimo, expressão lambda ou expressão de consulta</value>
  </data>
  <data name="WRN_AlwaysNull_Title" xml:space="preserve">
    <value>O resultado da expressão é sempre 'null'</value>
  </data>
  <data name="ERR_ModuleEmitFailure" xml:space="preserve">
    <value>Falha para emitir o módulo "{0}".</value>
  </data>
  <data name="IDS_FeatureThrowExpression" xml:space="preserve">
    <value>expressão throw</value>
  </data>
  <data name="ERR_MethodImplementingAccessor" xml:space="preserve">
    <value>Método "{0}" não pode implementar o acessador de interface "{1}" para o tipo "{2}". Use uma implementação de interface explícita.</value>
  </data>
  <data name="ERR_ConflictingAliasAndDefinition" xml:space="preserve">
    <value>Alias "{0}" está em conflito com {1} definição</value>
  </data>
  <data name="ERR_NoSuchMember" xml:space="preserve">
    <value>"{0}" não contém uma definição para "{1}"</value>
  </data>
  <data name="ERR_IntOverflow" xml:space="preserve">
    <value>Constante de integral muito grande</value>
  </data>
  <data name="CouldNotFindFile" xml:space="preserve">
    <value>Não foi possível encontrar o arquivo.</value>
  </data>
  <data name="ERR_DeclarationExpressionNotPermitted" xml:space="preserve">
    <value>Uma declaração não é permitida neste contexto.</value>
  </data>
  <data name="ERR_NonTaskMainCantBeAsync" xml:space="preserve">
    <value>Um ponto de entrada que retorna void ou int não pode ser assíncrono</value>
  </data>
  <data name="WRN_UnmatchedTypeParamRefTag_Title" xml:space="preserve">
    <value>O comentário XML tem uma marca typeparamref, mas não há nenhum parâmetro de tipo com esse nome</value>
  </data>
  <data name="WRN_PdbLocalNameTooLong_Title" xml:space="preserve">
    <value>O nome do local é muito longo para o PDB</value>
  </data>
  <data name="ERR_ComImportWithoutUuidAttribute" xml:space="preserve">
    <value>O atributo Guid deve ser especificado com o atributo ComImport</value>
  </data>
  <data name="ERR_BadYieldInTryOfCatch" xml:space="preserve">
    <value>Não é possível usar a instrução yield no corpo de um bloco try com uma cláusula catch</value>
  </data>
  <data name="WRN_ExplicitImplCollision_Title" xml:space="preserve">
    <value>A implementação de interface explícita corresponde a mais de um membro de interface</value>
  </data>
  <data name="ERR_NoMainOnDLL" xml:space="preserve">
    <value>Não é possível especificar /main se criar um módulo ou uma biblioteca</value>
  </data>
  <data name="WRN_Experimental_Title" xml:space="preserve">
    <value>O tipo destina-se somente para fins de avaliação e está sujeito a alterações ou remoções em atualizações futuras.</value>
  </data>
  <data name="ERR_QueryTypeInferenceFailedSelectMany" xml:space="preserve">
    <value>Uma expressão do tipo "{0}" não é permitida em um subsequente da cláusula em uma expressão de consulta com o tipo de origem "{1}". Inferência de tipos falhou na chamada para "{2}".</value>
  </data>
  <data name="IDS_FeatureNullPropagatingOperator" xml:space="preserve">
    <value>operador de propagação nula</value>
  </data>
  <data name="ERR_AssemblySpecifiedForLinkAndRef" xml:space="preserve">
    <value>Assemblies "{0}" e "{1}" referem-se aos mesmos metadados, mas somente um é uma referência vinculada (especificada usando a opção /link); considere remover uma das referências.</value>
  </data>
  <data name="IDS_Covariant" xml:space="preserve">
    <value>covariant</value>
  </data>
  <data name="ERR_FixedNotInStruct" xml:space="preserve">
    <value>Campos de buffer de tamanho fixo só podem ser membros de structs</value>
  </data>
  <data name="ERR_ExpressionTreeContainsTupleConversion" xml:space="preserve">
    <value>Uma árvore de expressão não pode conter uma conversão de tupla.</value>
  </data>
  <data name="ERR_CantReadConfigFile" xml:space="preserve">
    <value>Não é possível ler o arquivo de configuração "{0}" -- "{1}"</value>
  </data>
  <data name="ERR_BadAsyncExpressionTree" xml:space="preserve">
    <value>As expressões lambda assíncronas não podem ser convertidas em árvores de expressões</value>
  </data>
  <data name="ERR_ConWithValCon" xml:space="preserve">
    <value>O parâmetro de tipo "{1}" tem a restrição "struct" e, por isso, "{1}" não pode ser usado como uma restrição de "{0}"</value>
  </data>
  <data name="ERR_PredefinedValueTupleTypeNotFound" xml:space="preserve">
    <value>O tipo pré-definido "{0}" não foi definido ou importado</value>
  </data>
  <data name="TypeArgumentCannotBeNull" xml:space="preserve">
    <value>Argumento de tipo não pode ser nulo</value>
  </data>
  <data name="ERR_ExternAfterElements" xml:space="preserve">
    <value>Uma declaração de alias externa deve preceder todos os outros elementos definidos no namespace</value>
  </data>
  <data name="ERR_BadPlatformType" xml:space="preserve">
    <value>Opção inválida "{0}" para /platform; deve ser anycpu, x86, Itanium ou x64</value>
  </data>
  <data name="ERR_BadArgumentToAttribute" xml:space="preserve">
    <value>O argumento para o atributo "{0}" atributo deve ser um identificador válido</value>
  </data>
  <data name="WRN_CallerFilePathPreferredOverCallerMemberName" xml:space="preserve">
    <value>O CallerMemberNameAttribute aplicado ao parâmetro "{0}" não terá efeito. Ele é substituído pelo CallerFilePathAttribute.</value>
  </data>
  <data name="ERR_BadVisDelegateReturn" xml:space="preserve">
    <value>Acessibilidade inconsistente: tipo de retorno "{1}" é menos acessível do que "{0}" delegado</value>
  </data>
  <data name="ERR_SecurityCriticalOrSecuritySafeCriticalOnAsync" xml:space="preserve">
    <value>Atributo de segurança "{0}" não pode ser aplicado a um método Assíncrono.</value>
  </data>
  <data name="ERR_GlobalAttributesNotFirst" xml:space="preserve">
    <value>Os atributos assembly e module devem preceder todos os outros elementos definidos em um arquivo, exceto as cláusulas using e as declarações de alias externas</value>
  </data>
  <data name="WRN_ReferencedAssemblyReferencesLinkedPIA_Title" xml:space="preserve">
    <value>Foi criada uma referência ao assembly de interoperabilidade inserido devido a uma referência de assembly indireta</value>
  </data>
  <data name="ERR_MarshalUnmanagedTypeOnlyValidForFields" xml:space="preserve">
    <value>Tipo não gerenciado "{0}" é válido somente para campos.</value>
  </data>
  <data name="ERR_UnassignedThisAutoProperty" xml:space="preserve">
    <value>A propriedade '{0}' autoimplementada deve ser totalmente atribuída antes de o controle ser retornado ao chamador.</value>
  </data>
  <data name="ERR_BadUnOpArgs" xml:space="preserve">
    <value>Operador unário sobrecarregado "{0}" obtém um parâmetro</value>
  </data>
  <data name="ERR_UnsafeTypeInObjectCreation" xml:space="preserve">
    <value>O tipo não seguro "{0}" não pode ser usado na criação do objeto</value>
  </data>
  <data name="ERR_UseDefViolationOut" xml:space="preserve">
    <value>Uso do parâmetro out não atribuído "{0}"</value>
  </data>
  <data name="IDS_Contravariant" xml:space="preserve">
    <value>contravariant</value>
  </data>
  <data name="ERR_ConditionalOnInterfaceMethod" xml:space="preserve">
    <value>O atributo Conditional não é válido em membros de interface</value>
  </data>
  <data name="ERR_UnboxNotLValue" xml:space="preserve">
    <value>Não é possível modificar o resultado de uma conversão unboxing</value>
  </data>
  <data name="ERR_IllegalRefParam" xml:space="preserve">
    <value>ref e out não são válidos neste contexto</value>
  </data>
  <data name="XML_ElementTypeMatch" xml:space="preserve">
    <value>Marca de fim "{0}" não corresponde à marca de início "{1}".</value>
  </data>
  <data name="ERR_BadCastInFixed" xml:space="preserve">
    <value>É possível que o lado direito de uma atribuição de instrução fixed não seja uma expressão de conversão</value>
  </data>
  <data name="ERR_AssgReadonly2" xml:space="preserve">
    <value>Os membros do campo somente leitura "{0}" não podem ser modificados (exceto em um construtor ou inicializador de variável)</value>
  </data>
  <data name="WRN_UnifyReferenceBldRev" xml:space="preserve">
    <value>Presumindo que a referência de assembly "{0}" usada por "{1}" corresponde a identidade "{2}" de "{3}", talvez seja necessário fornecer a diretiva de tempo de execução</value>
  </data>
  <data name="ERR_SecurityAttributeInvalidActionAssembly" xml:space="preserve">
    <value>Valor SecurityAction "{0}" é inválido para atributos de segurança aplicados a um assembly</value>
  </data>
  <data name="ERR_QueryRangeVariableOverrides" xml:space="preserve">
    <value>A variável de intervalo "{0}" está em conflito com uma declaração anterior de "{0}"</value>
  </data>
  <data name="ERR_SingleTypeNameNotFound" xml:space="preserve">
    <value>O nome do tipo ou do namespace "{0}" não pode ser encontrado (está faltando uma diretiva using ou uma referência de assembly?)</value>
  </data>
  <data name="ERR_ExpectedContextualKeywordOn" xml:space="preserve">
    <value>Palavra-chave contextual esperada 'on'</value>
  </data>
  <data name="ERR_ExpectedContextualKeywordBy" xml:space="preserve">
    <value>Palavra-chave contextual esperada 'by'</value>
  </data>
  <data name="ERR_FeatureIsUnimplemented" xml:space="preserve">
    <value>O recurso '{0}' não é implementado nesse compilador.</value>
  </data>
  <data name="ERR_GenericConstraintNotSatisfiedValType" xml:space="preserve">
    <value>O tipo "{3}" não pode ser usado como parâmetro de tipo "{2}" no tipo ou método genérico "{0}". Não há conversão boxing de "{3}" em "{1}".</value>
  </data>
  <data name="ERR_BadExtensionMeth" xml:space="preserve">
    <value>O método de extensão deve ser estático</value>
  </data>
  <data name="WRN_BadXMLRefReturnType" xml:space="preserve">
    <value>Tipo de retorno inválido no atributo cref do comentário XML</value>
  </data>
  <data name="WRN_DeprecatedSymbolStr" xml:space="preserve">
    <value>"{0}" é obsoleto: "{1}"</value>
  </data>
  <data name="WRN_NoAnalyzerInAssembly" xml:space="preserve">
    <value>O assembly {0} não contém quaisquer analisadores.</value>
  </data>
  <data name="IDS_Covariantly" xml:space="preserve">
    <value>covariantly</value>
  </data>
  <data name="WRN_ReferencedAssemblyReferencesLinkedPIA" xml:space="preserve">
    <value>Foi criada uma referência ao assembly de interoperabilidade inserido "{0}" devido a uma referência indireta ao assembly criado pelo assembly "{1}". Considere alterar a propriedade "Inseir Tipos de Interoperabilidade" em qualquer assembly.</value>
  </data>
  <data name="WRN_TooManyLinesForDebugger" xml:space="preserve">
    <value>O arquivo de origem excedeu o limite de 16.707.565 linhas representáveis no PDB; as informações de depuração estarão incorretas</value>
  </data>
  <data name="IDS_Collection" xml:space="preserve">
    <value>coleção</value>
  </data>
  <data name="ERR_ExplicitDynamicAttr" xml:space="preserve">
    <value>Não use "System.Runtime.CompilerServices.ExtensionAttribute". Em vez disso, use a palavra-chave "dynamic".</value>
  </data>
  <data name="FTL_InputFileNameTooLong" xml:space="preserve">
    <value>Nome do arquivo "{0}" está vazio, contém caracteres inválidos, tem uma especificação de unidade sem um caminho absoluto ou é muito longo</value>
  </data>
  <data name="WRN_CLS_AssemblyNotCLS" xml:space="preserve">
    <value>"{0}" não pode ser marcado como em comformidade com CLS porque o assembly não tem um atributo CLSCompliant</value>
  </data>
  <data name="ERR_BadLanguageVersion" xml:space="preserve">
    <value>A versão de linguagem fornecida não tem suporte ou é inválida: '{0}'.</value>
  </data>
  <data name="ERR_InterfaceMemberHasBody" xml:space="preserve">
    <value>"{0}": membros de interface não podem ter uma definição</value>
  </data>
  <data name="ERR_ExpressionOrDeclarationExpected" xml:space="preserve">
    <value>Expressão ou declaração de instrução esperada.</value>
  </data>
  <data name="ERR_AssgReadonlyProp" xml:space="preserve">
    <value>A propriedade ou o indexador "{0}" não pode ser atribuído, pois é somente leitura</value>
  </data>
  <data name="ERR_MethodReturnCantBeRefAny" xml:space="preserve">
    <value>Método ou representante não pode retornar tipo "{0}"</value>
  </data>
  <data name="ERR_BadVisFieldType" xml:space="preserve">
    <value>Acessibilidade inconsistente: tipo de campo "{1}" é menos acessível do que o campo "{0}"</value>
  </data>
  <data name="ERR_MissingDebugSwitch" xml:space="preserve">
    <value>A opção /pdb requer que a opção /debug também seja usada</value>
  </data>
  <data name="WRN_IsAlwaysTrue_Title" xml:space="preserve">
    <value>A expressão 'is' determinada sempre é do tipo fornecido</value>
  </data>
  <data name="IDS_FeaturePragma" xml:space="preserve">
    <value>#pragma</value>
  </data>
  <data name="ERR_ResourceFileNameNotUnique" xml:space="preserve">
    <value>Cada módulo ou recurso vinculado devem ter um nome de arquivo exclusivo. Nome de arquivo "{0}" é especificado mais de uma vez neste assembly</value>
  </data>
  <data name="WRN_CA2000_DisposeObjectsBeforeLosingScope1_Title" xml:space="preserve">
    <value>Chame System.IDisposable.Dispose() na instância alocada antes que todas as referências a ele estejam fora do escopo</value>
  </data>
  <data name="ERR_ComRefCallInExpressionTree" xml:space="preserve">
    <value>Uma árvore de expressão da expressão lambda não pode conter uma chamada COM com a omissão de ref nos argumentos</value>
  </data>
  <data name="ERR_BadForeachDecl" xml:space="preserve">
    <value>Um tipo e um identificador são necessários em uma instrução foreach</value>
  </data>
  <data name="ERR_BadArgType" xml:space="preserve">
    <value>Argumento {0}: não é possível converter de "{1}" para "{2}"</value>
  </data>
  <data name="ERR_NamedArgumentSpecificationBeforeFixedArgument" xml:space="preserve">
    <value>As especificações de argumento nomeado devem aparecer depois que todos os argumentos fixos forem especificados</value>
  </data>
  <data name="ERR_ImplBadConstraints" xml:space="preserve">
    <value>As restrições para parâmetro de tipo "{0}" do método "{1}" deve coincidir com as restrições para o parâmetro de tipo "{2}" do método de interface "{3}". Ao invés disso, considere usar uma implementação de interface explícita.</value>
  </data>
  <data name="ERR_RefReturnRangeVariable" xml:space="preserve">
    <value>Não é possível retornar a variável de intervalo '{0}' por referência</value>
  </data>
  <data name="ERR_IllegalInnerUnsafe" xml:space="preserve">
    <value>Código sem segurança só pode aparecer em iteradores</value>
  </data>
  <data name="ERR_ArgsInvalid" xml:space="preserve">
    <value>O construtor __arglist só é válido dentro de um método de argumento variável</value>
  </data>
  <data name="ERR_AmbigQM" xml:space="preserve">
    <value>Tipo de expressão condicional não pode ser determinado porque "{0}" e "{1}" se convertem implicitamente um no outro</value>
  </data>
  <data name="ERR_NewWithTupleTypeSyntax" xml:space="preserve">
    <value>'new' não pode ser usado com o tipo da tupla. Use uma expressão literal da tupla no lugar.</value>
  </data>
  <data name="ERR_UnexpectedToken" xml:space="preserve">
    <value>Token inesperado '{0}'</value>
  </data>
  <data name="ERR_CantDeriveFromSealedType" xml:space="preserve">
    <value>"{0}": não é possível derivar do tipo sealed "{1}"</value>
  </data>
  <data name="ERR_DebugEntryPointNotSourceMethodDefinition" xml:space="preserve">
    <value>O ponto de entrada da depuração deve ser uma definição de um método declarado na compilação atual.</value>
  </data>
  <data name="WRN_SequentialOnPartialClass_Title" xml:space="preserve">
    <value>Não há nenhuma ordem definida entre os campos em várias declarações de estrutura parcial</value>
  </data>
  <data name="WRN_UnifyReferenceMajMin" xml:space="preserve">
    <value>Presumindo que a referência de assembly "{0}" usada por "{1}" corresponde a identidade "{2}" de "{3}", talvez seja necessário fornecer a diretiva de tempo de execução</value>
  </data>
  <data name="WRN_UnmatchedTypeParamTag" xml:space="preserve">
    <value>Comentário XML tem uma marga typeparam para "{0}", mas não há parâmetro de tipo por esse nome</value>
  </data>
  <data name="ERR_AttributeParameterRequired2" xml:space="preserve">
    <value>Parâmetro do atributo "{0}" ou "{1}" deve ser especificado.</value>
  </data>
  <data name="ERR_AttributeParameterRequired1" xml:space="preserve">
    <value>Parâmetro do atributo "{0}" deve ser especificado.</value>
  </data>
  <data name="IDS_FeatureExpressionBodiedMethod" xml:space="preserve">
    <value>método apto para expressão</value>
  </data>
  <data name="WRN_CallerFilePathParamForUnconsumedLocation_Title" xml:space="preserve">
    <value>O atributo CallerFilePathAttribute não terá efeito porque ele se aplica a um membro que é usado em contextos que não permitem o uso de argumentos opcionais</value>
  </data>
  <data name="ERR_NoNetModuleOutputWhenRefOutOrRefOnly" xml:space="preserve">
    <value>Não é possível compilar módulos de rede ao usar /refout ou /refonly.</value>
  </data>
  <data name="ERR_GenericConstraintNotSatisfiedNullableInterface" xml:space="preserve">
    <value>O tipo "{3}" não pode ser usado como parâmetro de tipo "{2}" no tipo ou método genérico "{0}". O tipo "{3}" que permite valores nulos não satisfaz a restrição de "{1}". Os tipos que permitem valores nulos não satisfazem as restrições de interface.</value>
  </data>
  <data name="WRN_XMLParseIncludeError_Title" xml:space="preserve">
    <value>XML malformado no arquivo de comentários incluído</value>
  </data>
  <data name="ERR_ConflictAliasAndMember" xml:space="preserve">
    <value>Namespace "{1}" contém uma definição em conflito com o alias "{0}"</value>
  </data>
  <data name="ERR_BadAssemblyName" xml:space="preserve">
    <value>Nome de assembly inválido: {0}</value>
  </data>
  <data name="ERR_ExpressionTreeContainsDiscard" xml:space="preserve">
    <value>Uma árvore de expressão não pode conter um descarte.</value>
  </data>
  <data name="WRN_IsDynamicIsConfusing_Title" xml:space="preserve">
    <value>Usar 'is' para testar a compatibilidade com 'dynamic' é essencialmente o mesmo que o teste de compatibilidade com 'Object'</value>
  </data>
  <data name="ERR_BadUsingNamespace" xml:space="preserve">
    <value>Uma diretiva de 'usando namespace' pode apenas ser aplicada a namespaces; '{0}' é um tipo, não um namespace. Considere uma diretiva 'usando estático'</value>
  </data>
  <data name="ERR_RefReadonly2" xml:space="preserve">
    <value>Os membros do campo somente leitura '{0}' não podem ser usados como um valor ref ou out (a não ser em um construtor)</value>
  </data>
  <data name="ERR_InvalidFormatForGuidForOption" xml:space="preserve">
    <value>Erro de sintaxe de linha de comando: Formato de Guid inválido "{0}" para a opção "{1}"</value>
  </data>
  <data name="WRN_UnqualifiedNestedTypeInCref" xml:space="preserve">
    <value>Em atributos cref, tipos aninhados de tipos genéricos devem ser qualificados.</value>
  </data>
  <data name="ERR_BadCallerLineNumberParamWithoutDefaultValue" xml:space="preserve">
    <value>O CallerLineNumberAttribute só pode ser aplicado a parâmetros com valores padrão</value>
  </data>
  <data name="WRN_NubExprIsConstBool2" xml:space="preserve">
    <value>O resultado da expressão é sempre '{0}', pois um valor do tipo '{1}' nunca é igual a "null" do tipo '{2}'</value>
  </data>
  <data name="ERR_ReturnInIterator" xml:space="preserve">
    <value>Não é possível retornar um valor de um iterador. Use a instrução yield return para retornar um valor ou yield break para finalizar a iteração.</value>
  </data>
  <data name="WRN_IllegalPPWarning" xml:space="preserve">
    <value>Restauração ou desabilitação esperada</value>
  </data>
  <data name="ERR_OptionMustBeAbsolutePath" xml:space="preserve">
    <value>A opção '{0}' deve ser um caminho absoluto.</value>
  </data>
  <data name="ERR_InvalidSubsystemVersion" xml:space="preserve">
    <value>Versão inválida {0} para /subsystemversion. A versão deve ser 6.02 ou posterior para ARM ou AppContainerExe e 4.00 ou superior</value>
  </data>
  <data name="ERR_InvalidInitializerElementInitializer" xml:space="preserve">
    <value>Declarador de membro de inicializador inválido</value>
  </data>
  <data name="ERR_InvalidPathMap" xml:space="preserve">
    <value>A opção pathmap foi formatada incorretamente.</value>
  </data>
  <data name="ERR_IllegalFixedType" xml:space="preserve">
    <value>Tipo de buffer de tamanho fixo deve ser um dos valores a seguir: bool, byte, short, int, long, char, sbyte, ushort, uint, ulong, float ou doublé</value>
  </data>
  <data name="ERR_ConstOutOfRange" xml:space="preserve">
    <value>O valor de constante "{0}" não pode ser convertido em "{1}"</value>
  </data>
  <data name="ERR_BadArgExtraRef" xml:space="preserve">
    <value>O argumento {0} não deve ser transmitido com a palavra-chave '{1}'</value>
  </data>
  <data name="ERR_InaccessibleGetter" xml:space="preserve">
    <value>A propriedade ou o indexador "{0}" não pode ser usado neste contexto porque o acessador get é inacessível</value>
  </data>
  <data name="IDS_FeatureLocalFunctions" xml:space="preserve">
    <value>funções locais</value>
  </data>
  <data name="IDS_FeatureTuples" xml:space="preserve">
    <value>tuplas</value>
  </data>
  <data name="IDS_SK_EXTERNALIAS" xml:space="preserve">
    <value>alias externo</value>
  </data>
  <data name="WRN_InvalidInclude" xml:space="preserve">
    <value>Elemento XML include inválido -- {0}</value>
  </data>
  <data name="WRN_AlignmentMagnitude_Title" xml:space="preserve">
    <value>O valor do alinhamento tem uma magnitude que pode resultar em uma grande cadeia de caracteres formatada</value>
  </data>
  <data name="ERR_BadExceptionType" xml:space="preserve">
    <value>O tipo caught ou thrown deve ser derivado de System.Exception</value>
  </data>
  <data name="WRN_NoSources_Title" xml:space="preserve">
    <value>Nenhum arquivo de origem especificado</value>
  </data>
  <data name="WRN_AttributeIgnoredWhenPublicSigning" xml:space="preserve">
    <value>O atributo '{0}' é ignorado quando a autenticação pública é especificada.</value>
  </data>
  <data name="ERR_FixedOverflow" xml:space="preserve">
    <value>Buffer de tamanho fixo de comprimento {0} e tipo "{1}" é muito grande</value>
  </data>
  <data name="ERR_BogusExplicitImpl" xml:space="preserve">
    <value>"{0}" não pode implementar "{1}" porque o idioma não dá suporte a ele</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion2" xml:space="preserve">
    <value>O recurso '{0}' não está disponível em C# 2. Use a versão de linguagem {1} ou superior.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion3" xml:space="preserve">
    <value>O recurso '{0}' não está disponível em C# 3. Use a versão de linguagem {1} ou superior.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion1" xml:space="preserve">
    <value>O recurso '{0}' não está disponível em C# 1. Use a versão de linguagem {1} ou superior.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion6" xml:space="preserve">
    <value>O recurso '{0}' não está disponível em C# 6. Use a versão de linguagem {1} ou superior.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion7" xml:space="preserve">
    <value>O recurso '{0}' não está disponível em C# 7. Use a versão de linguagem {1} ou superior.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion4" xml:space="preserve">
    <value>O recurso '{0}' não está disponível em C# 4. Use a versão de linguagem {1} ou superior.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion5" xml:space="preserve">
    <value>O recurso '{0}' não está disponível em C# 5. Use a versão de linguagem {1} ou superior.</value>
  </data>
  <data name="IDS_LIB_OPTION" xml:space="preserve">
    <value>opção /LIB</value>
  </data>
  <data name="ERR_ConditionalMustReturnVoid" xml:space="preserve">
    <value>O atributo Conditional não é válido em "{0}" porque seu tipo de retorno não é nulo</value>
  </data>
  <data name="ERR_DllImportOnGenericMethod" xml:space="preserve">
    <value>O atributo DllImport não pode ser aplicado a um método que seja genérico ou esteja contido em um tipo genérico.</value>
  </data>
  <data name="ERR_UseDefViolation" xml:space="preserve">
    <value>Uso de variável local não atribuída "{0}"</value>
  </data>
  <data name="ERR_RefProperty" xml:space="preserve">
    <value>Talvez uma propriedade ou um indexador não possa ser passado como um parâmetro out ou ref</value>
  </data>
  <data name="WRN_MultipleRuntimeOverrideMatches_Title" xml:space="preserve">
    <value>O membro substitui o membro base com vários candidatos à substituição no tempo de execução</value>
  </data>
  <data name="ERR_RefReturnReadonlyLocalCause" xml:space="preserve">
    <value>Não é possível retornar '{0}' por referência, porque ele é um '{1}'</value>
  </data>
  <data name="INF_UnableToLoadSomeTypesInAnalyzer_Title" xml:space="preserve">
    <value>Ignorar tipos de carregamento no assembly analisador que falharem devido a uma ReflectionTypeLoadException</value>
  </data>
  <data name="ERR_BadSpecialByRefLocal" xml:space="preserve">
    <value>Parâmetros ou locais do tipo "{0}" não podem ser declarados em métodos assíncronos ou expressões lambda.</value>
  </data>
  <data name="ERR_PartialMethodMustHaveLatent" xml:space="preserve">
    <value>Nenhuma declaração de definição encontrada para implementar a declaração de método parcial "{0}"</value>
  </data>
  <data name="ERR_MissingTypeInSource" xml:space="preserve">
    <value>Referência ao tipo "{0}" declara que ele está definido neste assembly, mas não está definido no código-fonte ou quaisquer módulo adicionados</value>
  </data>
  <data name="ERR_CannotPassNullForFriendAssembly" xml:space="preserve">
    <value>Não é possível passar null para nome de assembly amigável</value>
  </data>
  <data name="WRN_DefaultValueForUnconsumedLocation_Title" xml:space="preserve">
    <value>O valor padrão especificado não tem efeito porque ele se aplica a um membro que é usado em contextos que não aceitam argumentos opcionais</value>
  </data>
  <data name="WRN_EmptySwitch" xml:space="preserve">
    <value>Bloco switch vazio</value>
  </data>
  <data name="ERR_AbstractSealedStatic" xml:space="preserve">
    <value>"{0}": uma classe abstract não pode ser sealed ou static</value>
  </data>
  <data name="WRN_FinalizeMethod_Title" xml:space="preserve">
    <value>Apresentar um método 'Finalize' pode interferir na invocação do destruidor</value>
  </data>
  <data name="ERR_FixedMustInit" xml:space="preserve">
    <value>Forneça um inicializador em uma declaração de instrução fixed ou using</value>
  </data>
  <data name="ERR_BadIncDecRetType" xml:space="preserve">
    <value>O tipo de retorno para o operador ++ ou -- deve corresponder ao tipo de parâmetro ou ser derivado do tipo de parâmetro</value>
  </data>
  <data name="ERR_UnexpectedVariance" xml:space="preserve">
    <value>Variação inválida: O parâmetro do tipo "{1}" deve ser {3} válido em "{0}". "{1}" é {2}.</value>
  </data>
  <data name="ERR_BadDynamicConversion" xml:space="preserve">
    <value>"{0}": conversões definidas pelo usuário para ou do tipo dinâmico não são permitidas</value>
  </data>
  <data name="ERR_BadAppConfigPath" xml:space="preserve">
    <value>AppConfigPath deve ser absoluto.</value>
  </data>
  <data name="WRN_CallerLineNumberPreferredOverCallerFilePath" xml:space="preserve">
    <value>O CallerFilePathAttribute aplicado ao parâmetro "{0}" não terá efeito. Ele é substituído pelo CallerLineNumberAttribute.</value>
  </data>
  <data name="WRN_PossibleMistakenNullStatement_Title" xml:space="preserve">
    <value>Instrução empty possivelmente incorreta</value>
  </data>
  <data name="ERR_GenericConstraintNotSatisfiedTyVar" xml:space="preserve">
    <value>O tipo "{3}" não pode ser usado como parâmetro de tipo "{2}" no tipo ou método genérico "{0}". Não há conversão boxing ou conversão de parâmetro de tipo de "{3}" em "{1}".</value>
  </data>
  <data name="WRN_XMLParseIncludeError" xml:space="preserve">
    <value>XML mal formada no arquivo de comentários incluído -- "{0}"</value>
  </data>
  <data name="ERR_AutoPropertyMustOverrideSet" xml:space="preserve">
    <value>Propriedades autoimplementadas devem substituir todos os acessadores de propriedade substituída.</value>
  </data>
  <data name="ERR_SubexpressionNotInNameof" xml:space="preserve">
    <value>A subexpressão não pode ser usada em um argumento para nameof.</value>
  </data>
  <data name="ERR_FixedDimsRequired" xml:space="preserve">
    <value>Um campo de buffer de tamanho fixo deve ter especificador de tamanho de matriz após o nome do campo</value>
  </data>
  <data name="WRN_WarningDirective_Title" xml:space="preserve">
    <value>diretiva de #aviso</value>
  </data>
  <data name="ERR_BadArgCount" xml:space="preserve">
    <value>Nenhuma sobrecarga para o método "{0}" leva {1} argumentos</value>
  </data>
  <data name="ERR_BadIndexLHS" xml:space="preserve">
    <value>Não é possível aplicar a indexação com [] a uma expressão do tipo "{0}"</value>
  </data>
  <data name="ERR_BadBoundType" xml:space="preserve">
    <value>"{0}" não é uma restrição válida. Um tipo usado como uma restrição deve ser uma interface, uma classe não selada ou um parâmetro de tipo.</value>
  </data>
  <data name="WRN_AmbiguousXMLReference" xml:space="preserve">
    <value>Referência ambígua no atributo cref: "{0}". Supondo "{1}", mas também poderia ter correspondido a outras sobrecargas, incluindo "{2}".</value>
  </data>
  <data name="ERR_NoMultipleInheritance" xml:space="preserve">
    <value>Classe "{0}" não pode ter várias classes base: "{1}" e "{2}"</value>
  </data>
  <data name="WRN_EqualsWithoutGetHashCode" xml:space="preserve">
    <value>"{0}" substitui Object.Equals(object o), mas não substitui Object.GetHashCode()</value>
  </data>
  <data name="HDN_UnusedUsingDirective" xml:space="preserve">
    <value>Diretiva de uso desnecessária.</value>
  </data>
  <data name="ERR_NameNotInContext" xml:space="preserve">
    <value>O nome "{0}" não existe no contexto atual</value>
  </data>
  <data name="ERR_NoBreakOrCont" xml:space="preserve">
    <value>Nenhum loop delimitador a partir do qual quebrar ou continuar</value>
  </data>
  <data name="WRN_ExplicitImplCollision" xml:space="preserve">
    <value>Implementação de interface explícita "{0}" corresponde a mais de um membro de interface. Qual membro de interface é na verdade escolhido é dependente de implementação. Ao invés, considere o uso de uma implementação não explícita.</value>
  </data>
  <data name="XML_RefUndefinedEntity_1" xml:space="preserve">
    <value>Referência à entidade indefinida "{0}".</value>
  </data>
  <data name="WRN_XMLParseError" xml:space="preserve">
    <value>O comentário XML tem XML com formação incorreta -- "{0}"</value>
  </data>
  <data name="ERR_RefPropertyMustHaveGetAccessor" xml:space="preserve">
    <value>As propriedades que retornam por referência devem ter um acessador get</value>
  </data>
  <data name="ERR_BadVisBaseInterface" xml:space="preserve">
    <value>Acessibilidade inconsistente: interface base "{1}" é menos acessível do que interface "{0}"</value>
  </data>
  <data name="ERR_ExpressionTreeContainsAnonymousMethod" xml:space="preserve">
    <value>Uma árvore de expressão não pode conter uma expressão de método anônimo</value>
  </data>
  <data name="IDS_Lambda" xml:space="preserve">
    <value>expressão lambda</value>
  </data>
  <data name="ERR_EOFExpected" xml:space="preserve">
    <value>Definição de namespace ou tipo, ou final do arquivo esperado</value>
  </data>
  <data name="ERR_UnterminatedStringLit" xml:space="preserve">
    <value>Literal de cadeia de caracteres não finalizado</value>
  </data>
  <data name="ERR_BadConstraintType" xml:space="preserve">
    <value>Tipo de restrição inválido. Um tipo usado como restrição deve ser uma interface, uma classe não sealed ou um parâmetro de tipo.</value>
  </data>
  <data name="WRN_DotOnDefault_Title" xml:space="preserve">
    <value>A expressão sempre causa uma System.NullReferenceException porque o valor padrão do tipo é nulo</value>
  </data>
  <data name="ERR_PointerInAsOrIs" xml:space="preserve">
    <value>is' e 'as' não são válidos em tipos de ponteiro</value>
  </data>
  <data name="WRN_TypeParameterSameAsOuterTypeParameter_Title" xml:space="preserve">
    <value>O parâmetro de tipo tem o mesmo nome que o parâmetro de tipo do tipo externo</value>
  </data>
  <data name="WRN_CLS_BadInterfaceMember" xml:space="preserve">
    <value>"{0}": Interfaces em conformidade com CLS devem ter somente membros em conformidade com CLS</value>
  </data>
  <data name="ERR_AnonymousMethodToExpressionTree" xml:space="preserve">
    <value>Uma expressão de método anônimo não pode ser convertida em uma árvore de expressão</value>
  </data>
  <data name="WRN_FileAlreadyIncluded_Title" xml:space="preserve">
    <value>Arquivo de origem especificado várias vezes</value>
  </data>
  <data name="XML_IncorrectComment" xml:space="preserve">
    <value>Foi usada uma sintaxe incorreta em um comentário.</value>
  </data>
  <data name="ERR_ExtensionCollectionElementInitializerInExpressionTree" xml:space="preserve">
    <value>Não há suporte para um método de Adição de extensão para um inicializador de coleção em uma expressão lambda.</value>
  </data>
  <data name="ERR_BadIndexerNameAttr" xml:space="preserve">
    <value>O "{0}" atributo é válido somente em um indexador que não seja uma declaração de membro de interface explícita</value>
  </data>
  <data name="ERR_NotAnAttributeClass" xml:space="preserve">
    <value>"{0}" não é uma classe de atributo</value>
  </data>
  <data name="ERR_AnonymousTypeNotAvailable" xml:space="preserve">
    <value>Não é possível usar o tipo anônimo em uma expressão constante</value>
  </data>
  <data name="ERR_GlobalStatement" xml:space="preserve">
    <value>Expressões e instruções podem ocorrer somente em um corpo de método</value>
  </data>
  <data name="WRN_CLS_BadFieldPropType" xml:space="preserve">
    <value>Tipo de "{0}" não tem conformidade com CLS</value>
  </data>
  <data name="ERR_AmbigBinaryOpsOnDefault" xml:space="preserve">
    <value>O operador '{0}' é ambíguo nos operandos 'default' e 'default'</value>
  </data>
  <data name="WRN_CLS_BadArgType" xml:space="preserve">
    <value>Tipo de argumento "{0}" não tem conformidade com CLS</value>
  </data>
  <data name="ERR_ParamsMustBeArray" xml:space="preserve">
    <value>O parâmetro params deve ser uma matriz dimensional única</value>
  </data>
  <data name="WRN_MainIgnored" xml:space="preserve">
    <value>O ponto de entrada do programa é o código de script global; ignorando "{0}" ponto de entrada.</value>
  </data>
  <data name="ERR_AbstractBaseCall" xml:space="preserve">
    <value>Não é possível chamar o membro de base abstrata: '{0}'</value>
  </data>
  <data name="ERR_TypeVarCantBeNull" xml:space="preserve">
    <value>Não é possível converter um valor nulo no parâmetro de tipo "{0}" porque ele poderia ser um tipo de valor não nulo. É recomendável o uso de "default({0})".</value>
  </data>
  <data name="WRN_NonECMAFeature_Title" xml:space="preserve">
    <value>O recurso não faz parte da especificação de linguagem ISO C# padronizada e pode não ser aceito por outros compiladores</value>
  </data>
  <data name="ERR_RefReturnLocal2" xml:space="preserve">
    <value>Não é possível retornar um membro do '{0}' local por referência porque ele não é um local ref</value>
  </data>
  <data name="ERR_ObjectCallingBaseConstructor" xml:space="preserve">
    <value>"{0}" não tem classe base e não pode chamar um construtor base</value>
  </data>
  <data name="ERR_InitializerAddHasWrongSignature" xml:space="preserve">
    <value>A melhor correspondência de método sobrecarregado para "{0}" tem assinatura errada para o elemento do inicializador. O Add inicializável deve ser um método de instância acessível.</value>
  </data>
  <data name="ERR_PublicSignButNoKey" xml:space="preserve">
    <value>A autenticação pública foi especificada e requer uma chave pública, mas nenhuma chave pública foi especificada.</value>
  </data>
  <data name="ERR_CloseParenExpected" xml:space="preserve">
    <value>) esperado</value>
  </data>
  <data name="ERR_FileNotFound" xml:space="preserve">
    <value>Arquivo de origem "{0}" não pode ser encontrado.</value>
  </data>
  <data name="IDS_SK_PROPERTY" xml:space="preserve">
    <value>propriedade</value>
  </data>
  <data name="ERR_RefReturnReadonlyLocal" xml:space="preserve">
    <value>Não é possível retornar '{0}' por referência, porque ele é somente leitura</value>
  </data>
  <data name="ERR_RetNoObjectRequiredLambda" xml:space="preserve">
    <value>Função anônima convertida para um representante de retorno void não pode retornar um valor</value>
  </data>
  <data name="ERR_PatternDynamicType" xml:space="preserve">
    <value>É ilegal usar o tipo 'dinâmico' em um padrão.</value>
  </data>
  <data name="ERR_CallingFinalizeDeprecated" xml:space="preserve">
    <value>Destruidores e object.Finalize não podem ser chamados diretamente. Chame IDisposable.Dispose, se disponível.</value>
  </data>
  <data name="ERR_TooManyCharsInConst" xml:space="preserve">
    <value>Número excessivo de caracteres no literal de caractere</value>
  </data>
  <data name="WRN_ConflictingChecksum_Title" xml:space="preserve">
    <value>Valores de soma de verificação #pragma diferentes foram fornecidos</value>
  </data>
  <data name="ERR_PrincipalPermissionInvalidAction" xml:space="preserve">
    <value>Valor SecurityAction "{0}" é inválido para o atributo PrincipalPermission</value>
  </data>
  <data name="ERR_CStyleArray" xml:space="preserve">
    <value>Declarador de matriz incorreto: para declarar uma matriz gerenciada, o especificador de classificação antecede o identificador de variável. Para declarar um campo de buffer de tamanho fixo, use a palavra-chave fixed antes do tipo de campo.</value>
  </data>
  <data name="ERR_PartialWrongTypeParamsVariance" xml:space="preserve">
    <value>Declarações parciais de "{0}" devem ter os mesmos nomes de parâmetro de tipo e modificadores de variação na mesma ordem</value>
  </data>
  <data name="ERR_DeriveFromEnumOrValueType" xml:space="preserve">
    <value>"{0}" não pode derivar de classe especial "{1}"</value>
  </data>
  <data name="ERR_TaskRetNoObjectRequired" xml:space="preserve">
    <value>Como "{0}" é um método assíncrono que retorna "Task", uma palavra-chave return não deve ser seguida por uma expressão de objeto. Você pretendia retornar "Task&lt;T&gt;"?</value>
  </data>
  <data name="ERR_RefReadonlyLocal" xml:space="preserve">
    <value>Não é possível usar '{0}' como um valor ref ou out porque ele é somente leitura</value>
  </data>
  <data name="ERR_QueryNoProvider" xml:space="preserve">
    <value>Não foi possível encontrar uma implementação do padrão de consulta para o tipo de origem "{0}". "{1}" não encontrado.</value>
  </data>
  <data name="ERR_BadCallerMemberNameParamWithoutDefaultValue" xml:space="preserve">
    <value>O CallerMemberNameAttribute só pode ser aplicado a parâmetros com valores padrão</value>
  </data>
  <data name="WRN_SameFullNameThisAggNs_Title" xml:space="preserve">
    <value>Conflitos de tipo com o namespace importado</value>
  </data>
  <data name="WRN_UnmatchedParamTag" xml:space="preserve">
    <value>Comentário XML tem uma marga param para "{0}", mas não há parâmetro por esse nome</value>
  </data>
  <data name="WRN_MissingXMLComment_Title" xml:space="preserve">
    <value>O comentário XML ausente não foi encontrado para o tipo ou membro visível publicamente</value>
  </data>
  <data name="WRN_VacuousIntegralComp_Title" xml:space="preserve">
    <value>A comparação com constante integral é inútil. A constante está fora do intervalo do tipo</value>
  </data>
  <data name="WRN_EqualityOpWithoutGetHashCode_Title" xml:space="preserve">
    <value>O tipo define os operadores == ou !=, mas não substitui o Object.GetHashCode()</value>
  </data>
  <data name="WRN_AssemblyAttributeFromModuleIsOverridden_Title" xml:space="preserve">
    <value>O atributo será ignorado em prol da instância que aparece na fonte</value>
  </data>
  <data name="ERR_NoSourceFile" xml:space="preserve">
    <value>Arquivo de origem "{0}" não pode ser aberto -- {1}</value>
  </data>
  <data name="ERR_AttributeOnBadSymbolType" xml:space="preserve">
    <value>Atributo "{0}" não é válido neste tipo de declaração. Ele é válido somente em "{1}" declarações.</value>
  </data>
  <data name="ERR_LocalIllegallyOverrides" xml:space="preserve">
    <value>Um local ou um parâmetro denominado "{0}" não pode ser declarado neste escopo porque esse nome é usado em um escopo delimitador de local para definir um local ou parâmetro</value>
  </data>
  <data name="ERR_NotNullRefDefaultParameter" xml:space="preserve">
    <value>"{0}" é do tipo "{1}". Um valor de parâmetro padrão de um tipo de referência diferente de cadeia de caracteres pode somente ser inicializado com null</value>
  </data>
  <data name="ERR_NoPIAAssemblyMissingAttributes" xml:space="preserve">
    <value>Não é possível inserir tipos de interoperabilidade do assembly "{0}" porque ele está sem o atributo "{1}" ou o atributo "{2}".</value>
  </data>
  <data name="WRN_CLS_BadTypeVar" xml:space="preserve">
    <value>Tipo de restrição "{0}" não tem conformidade com CLS</value>
  </data>
  <data name="ERR_StaticMemberInObjectInitializer" xml:space="preserve">
    <value>Campo estático ou propriedade "{0}" não pode ser atribuído a um inicializador de objeto</value>
  </data>
  <data name="ERR_DuplicateAttribute" xml:space="preserve">
    <value>Duplicar atributo "{0}"</value>
  </data>
  <data name="ERR_AttributeUsageOnNonAttributeClass" xml:space="preserve">
    <value>Atributo "{0}" é somente válido em classes derivadas de System.Attribute</value>
  </data>
  <data name="WRN_CmpAlwaysFalse_Title" xml:space="preserve">
    <value>Comparação com nulo do tipo struct sempre produz 'false'</value>
  </data>
  <data name="ERR_CantUseRequiredAttribute" xml:space="preserve">
    <value>O atributo RequiredAttribute não é permitido em tipos C#</value>
  </data>
  <data name="ERR_TooManyLocals" xml:space="preserve">
    <value>São permitidos somente 65534 locais, incluindo os gerados pelo compilador</value>
  </data>
  <data name="WRN_VolatileByRef_Description" xml:space="preserve">
    <value>Um campo volátil não deve normalmente ser usado como um valor ref ou out, uma vez que ele não é tratado como volátil. Há exceções, como ao chamar uma API interligada.</value>
  </data>
  <data name="ERR_InteropTypesWithSameNameAndGuid" xml:space="preserve">
    <value>Não é possível inserir o tipo de interoperabilidade "{0}" encontrado em ambos os assemblies "{1}" e "{2}". Considere configurar a propriedade "Incorporar Tipos de Interoperabilidade" como falsa.</value>
  </data>
  <data name="IDS_DirectoryHasInvalidPath" xml:space="preserve">
    <value>o caminho é muito longo ou inválido</value>
  </data>
  <data name="ERR_BadRetType" xml:space="preserve">
    <value>"{1} {0}" tem o tipo de retorno incorreto</value>
  </data>
  <data name="WRN_PatternBadSignature_Title" xml:space="preserve">
    <value>O tipo não implementa o padrão de coleção; o membro possui a assinatura incorreta</value>
  </data>
  <data name="IDS_FeatureAsyncMain" xml:space="preserve">
    <value>assíncrono principal</value>
  </data>
  <data name="ERR_PredefinedTypeMemberNotFoundInAssembly" xml:space="preserve">
    <value>O membro '{0}' não foi encontrado no tipo '{1}' do assembly '{2}'.</value>
  </data>
  <data name="XML_EndTagNotExpected" xml:space="preserve">
    <value>Marca de fim não era esperada neste local.</value>
  </data>
  <data name="ERR_StaticBaseClass" xml:space="preserve">
    <value>"{1}": não pode derivar da classe static "{0}"</value>
  </data>
  <data name="WRN_CallOnNonAgileField" xml:space="preserve">
    <value>Acessar um membro em "{0}" pode causar uma exceção de tempo de execução porque é um campo de uma classe marshal por referência</value>
  </data>
  <data name="TypeMustBeVar" xml:space="preserve">
    <value>O tipo deve ser 'var'.</value>
  </data>
  <data name="ERR_ExpressionExpected" xml:space="preserve">
    <value>Expressão esperada</value>
  </data>
  <data name="ERR_FriendRefNotEqualToThis" xml:space="preserve">
    <value>O acesso Friend foi concedido por "{0}", mas a chave pública do assembly de saída não corresponde àquela especificada pelo atributo no assembly de concessão.</value>
  </data>
  <data name="ERR_BogusType" xml:space="preserve">
    <value>"{0}" é um tipo sem suporte no idioma</value>
  </data>
  <data name="ERR_InvalidDynamicCondition" xml:space="preserve">
    <value>A expressão deve ser implicitamente convertível em Booliano ou o tipo "{0}" deve definir o operador"{1}".</value>
  </data>
  <data name="WRN_CA2202_DoNotDisposeObjectsMultipleTimes_Title" xml:space="preserve">
    <value>O objeto pode ser descartado mais de uma vez</value>
  </data>
  <data name="WRN_CallerLineNumberPreferredOverCallerMemberName" xml:space="preserve">
    <value>O CallerMemberNameAttribute aplicado ao parâmetro "{0}" não terá efeito. Ele é substituído pelo CallerLineNumberAttribute.</value>
  </data>
  <data name="WRN_InvalidAssemblyName_Title" xml:space="preserve">
    <value>A referência de assembly é inválida e não pode ser resolvida</value>
  </data>
  <data name="ERR_BadIncDecSignature" xml:space="preserve">
    <value>O tipo de parâmetro para o operador ++ ou -- deve ser do tipo recipiente</value>
  </data>
  <data name="WRN_NoRuntimeMetadataVersion_Title" xml:space="preserve">
    <value>Nenhum valor de RuntimeMetadataVersion foi encontrado</value>
  </data>
  <data name="ERR_ObjectRequired" xml:space="preserve">
    <value>Uma referência de objeto é necessária para o campo, o método ou a propriedade "{0}" não estática</value>
  </data>
  <data name="ERR_InterfacesCannotContainTypes" xml:space="preserve">
    <value>"{0}": interfaces não podem declarar tipos</value>
  </data>
  <data name="WRN_CLS_AssemblyNotCLS_Title" xml:space="preserve">
    <value>O tipo ou membro não pode ser marcado como em comformidade com CLS porque o assembly não possui um atributo CLSCompliant</value>
  </data>
  <data name="ERR_CantChangeReturnTypeOnOverride" xml:space="preserve">
    <value>"{0}": tipo de retorno deve ser "{2}" para corresponder ao membro substituído "{1}"</value>
  </data>
  <data name="SubmissionCanHaveAtMostOne" xml:space="preserve">
    <value>Envio pode ter no máximo uma árvore de sintaxe.</value>
  </data>
  <data name="ERR_MethDelegateMismatch" xml:space="preserve">
    <value>Nenhuma sobrecarga de "{0}" corresponde ao representante "{1}"</value>
  </data>
  <data name="WRN_BadXMLRefParamType_Title" xml:space="preserve">
    <value>Tipo inválido para o parâmetro no atributo cref do comentário XML</value>
  </data>
  <data name="ERR_DefaultMemberOnIndexedType" xml:space="preserve">
    <value>Não é possível especificar o atributo DefaultMember em um tipo que contém um indexador</value>
  </data>
  <data name="ERR_BadWarningLevel" xml:space="preserve">
    <value>O nível de aviso deve estar no intervalo de 0-4</value>
  </data>
  <data name="IDS_FeatureExpressionBodiedIndexer" xml:space="preserve">
    <value>indexador apto para expressão</value>
  </data>
  <data name="ERR_DeriveFromDynamic" xml:space="preserve">
    <value>"{0}": não é possível derivar do tipo dinâmico</value>
  </data>
  <data name="TreeNotPartOfCompilation" xml:space="preserve">
    <value>árvore não faz parte da compilação</value>
  </data>
  <data name="ERR_ExpressionTreeContainsBadCoalesce" xml:space="preserve">
    <value>Uma árvore de expressão da expressão lambda não pode conter um operador de união com um lado esquerdo literal padrão ou nulo</value>
  </data>
  <data name="ERR_SyntaxError" xml:space="preserve">
    <value>Erro de sintaxe, "{0}" esperado</value>
  </data>
  <data name="WRN_InvalidAttributeLocation_Title" xml:space="preserve">
    <value>Este não é um local de atributo reconhecido</value>
  </data>
  <data name="ERR_EmptyElementInitializer" xml:space="preserve">
    <value>O inicializador de elemento não pode estar vazio</value>
  </data>
  <data name="ERR_QueryTypeInferenceFailed" xml:space="preserve">
    <value>O tipo da expressão na cláusula {0} está incorreto. Inferência de tipos falhou na chamada para "{1}".</value>
  </data>
  <data name="IDS_FeatureExceptionFilter" xml:space="preserve">
    <value>filtro de exceção</value>
  </data>
  <data name="ERR_PartialMethodInconsistentConstraints" xml:space="preserve">
    <value>As declarações de método parcial "{0}" têm restrições de parâmetro de tipo inconsistentes</value>
  </data>
</root>