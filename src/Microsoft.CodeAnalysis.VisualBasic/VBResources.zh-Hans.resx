<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ERR_OperatorRequiresBoolReturnType1" xml:space="preserve">
    <value>运算符“{0}”必须具有 Boolean 返回类型。</value>
  </data>
  <data name="ERR_LocalNamedSameAsParamInLambda1" xml:space="preserve">
    <value>变量“{0}”已声明为此 lambda 表达式或某个封闭 lambda 表达式的参数。</value>
  </data>
  <data name="ERR_ElseNoMatchingIf" xml:space="preserve">
    <value>"Else" 前面必须是匹配的 "If" 或 "ElseIf"。</value>
  </data>
  <data name="INF_UnableToLoadSomeTypesInAnalyzer" xml:space="preserve">
    <value>正在跳过分析器程序集 {0} 中的某些类型，因为出现 ReflectionTypeLoadException: {1}。</value>
  </data>
  <data name="ERR_AnonymousTypeNameWithoutPeriod" xml:space="preserve">
    <value>匿名类型成员名前面必须有一个句点。</value>
  </data>
  <data name="ERR_CannotConvertValue2" xml:space="preserve">
    <value>值“{0}”无法转换为“{1}”。</value>
  </data>
  <data name="ERR_InvalidImplements" xml:space="preserve">
    <value>“Implements”在运算符声明上无效。</value>
  </data>
  <data name="WRN_SynthMemberShadowsMember5_Title" xml:space="preserve">
    <value>属性或事件隐式声明与基类型中的成员发生冲突的类型或成员</value>
  </data>
  <data name="ERR_AccessMismatch6" xml:space="preserve">
    <value>“{0}”不能通过 {4}“{5}”在 {2}“{3}”中公开类型“{1}”。</value>
  </data>
  <data name="ERR_InvalidMultipleAttributeUsage1" xml:space="preserve">
    <value>属性“{0}”不能应用多次。</value>
  </data>
  <data name="ERR_InvalidOptionStrict" xml:space="preserve">
    <value>"Option Strict" 的后面只能跟 "On" 或 "Off"。</value>
  </data>
  <data name="WRN_NamespaceCaseMismatch3_Title" xml:space="preserve">
    <value>命名空间名称的大小写不匹配</value>
  </data>
  <data name="ERR_IndirectUnreferencedAssembly4" xml:space="preserve">
    <value>项目“{0}”间接引用包含“{2}”的程序集“{1}”。请在您的项目中添加对“{3}”的文件引用。 </value>
  </data>
  <data name="ERR_VarianceOutByRefDisallowed1" xml:space="preserve">
    <value>类型“{0}”不能用于此上下文，因为“In”和“Out”类型参数不能用于 ByRef 参数类型，且“{0}”是“Out”类型参数。</value>
  </data>
  <data name="FEATURE_WarningDirectives" xml:space="preserve">
    <value>warning 指令</value>
  </data>
  <data name="ERR_OverloadWithByref2" xml:space="preserve">
    <value>“{0}”和“{1}”的差异仅在于声明为“ByRef”或“ByVal”的参数，因此它们无法重载对方。</value>
  </data>
  <data name="ERR_BadModuleName" xml:space="preserve">
    <value>无效的模块名称: {0}</value>
  </data>
  <data name="ERR_IllegalXmlStartNameChar" xml:space="preserve">
    <value>XML 名称的开头不允许出现字符“{0}”({1})。</value>
  </data>
  <data name="IdentifierSyntaxNotWithinSyntaxTree" xml:space="preserve">
    <value>IdentifierSyntax 不在语法树中</value>
  </data>
  <data name="ERR_ConversionFromDerivedType" xml:space="preserve">
    <value>转换运算符不能从派生类型转换。</value>
  </data>
  <data name="ERR_InvalidAttributeUsage2" xml:space="preserve">
    <value>属性“{0}”不能应用于“{1}”，因为该属性在此声明类型中无效。</value>
  </data>
  <data name="ERR_IfNoType" xml:space="preserve">
    <value>无法推断通用类型。</value>
  </data>
  <data name="ERR_SubRequiresSingleStatement" xml:space="preserve">
    <value>单行语句 lambda 必须仅包含一个语句。</value>
  </data>
  <data name="ERR_BadPropertyAccessorFlags" xml:space="preserve">
    <value>不能将属性访问器声明为“{0}”。</value>
  </data>
  <data name="ERR_MetadataReferencesNotSupported" xml:space="preserve">
    <value>不支持元数据引用。</value>
  </data>
  <data name="ERR_NewArgsDisallowedForTypeParam" xml:space="preserve">
    <value>无法给类型形参上使用的 "New" 传递实参。</value>
  </data>
  <data name="ERR_BadDimFlags1" xml:space="preserve">
    <value>“{0}”在成员变量声明中无效。</value>
  </data>
  <data name="NodeIsNotWithinSyntaxTree" xml:space="preserve">
    <value>节点不在语法树中</value>
  </data>
  <data name="WRN_ArrayInitNoTypeObjectAssumed_Title" xml:space="preserve">
    <value>无法推断元素类型</value>
  </data>
  <data name="ERR_UnimplementedMember3" xml:space="preserve">
    <value>{0}“{1}”必须为接口“{3}”实现“{2}”。</value>
  </data>
  <data name="ERR_NoCallableOverloadCandidates2" xml:space="preserve">
    <value>重载决策失败，因为没有可使用这些参数调用的可访问“{0}”: {1}</value>
  </data>
  <data name="WRN_UnimplementedCommandLineSwitch_Title" xml:space="preserve">
    <value>命令行开关尚未实现</value>
  </data>
  <data name="ERR_AutoPropertyInitializedInStructure" xml:space="preserve">
    <value>如果没有将结构中包含的自动实现的属性标记为 "Shared"，这些属性就不能有初始值设定项。</value>
  </data>
  <data name="WRN_UnobservedAwaitableDelegate" xml:space="preserve">
    <value>从此 Async Function 返回的任务将被删除，并且忽略其中的任何异常。考虑将其更改为 Async Sub，以便传播其异常。</value>
  </data>
  <data name="ERR_MethodAlreadyImplemented2" xml:space="preserve">
    <value>“{0}.{1}”不能多次实现。</value>
  </data>
  <data name="ERR_NamedParamArrayArgument" xml:space="preserve">
    <value>命名实参不能匹配 ParamArray 形参。</value>
  </data>
  <data name="ERR_DuplicatePrefix" xml:space="preserve">
    <value>已声明 XML 命名空间前缀“{0}”。</value>
  </data>
  <data name="ERR_GotoIntoFor" xml:space="preserve">
    <value>“GoTo {0}”无效，因为“{0}”位于不包含此语句的“For”或“For Each”语句中。</value>
  </data>
  <data name="WRN_DefAsgUseNullRefStr_Title" xml:space="preserve">
    <value>在为变量赋值之前，变量已被使用</value>
  </data>
  <data name="ERR_ComClassRequiresPublicClass1" xml:space="preserve">
    <value>“Microsoft.VisualBasic.ComClassAttribute”未声明为“Public”，因此不能应用于“{0}”。</value>
  </data>
  <data name="ERR_ComClassRequiresPublicClass2" xml:space="preserve">
    <value>“Microsoft.VisualBasic.ComClassAttribute”的容器“{1}”未声明为“Public”，因此不能应用于“{0}”。</value>
  </data>
  <data name="WRN_UnreachableCode" xml:space="preserve">
    <value>检测到无法访问的代码。</value>
  </data>
  <data name="ERR_IterationVariableShadowLocal1" xml:space="preserve">
    <value>范围变量“{0}”隐藏封闭块中的某个变量或以前在查询表达式中定义的某个范围变量。</value>
  </data>
  <data name="ERR_IterationVariableShadowLocal2" xml:space="preserve">
    <value>范围变量“{0}”隐藏封闭块中的某个变量、以前定义的某个范围变量或者在查询表达式中隐式声明的某个变量。</value>
  </data>
  <data name="ERR_AmbiguousAcrossInterfaces3" xml:space="preserve">
    <value>“{0}”在继承接口“{1}”和“{2}”之间不明确。</value>
  </data>
  <data name="ERR_CantCallIIF" xml:space="preserve">
    <value>“If”运算符不能在“Call”语句中使用。</value>
  </data>
  <data name="ERR_LambdaNotCreatableDelegate1" xml:space="preserve">
    <value>Lambda 表达式无法转换为“{0}”，因为类型“{0}”被声明为“MustInherit”，无法创建。</value>
  </data>
  <data name="ERR_CaseNoSelect" xml:space="preserve">
    <value>“Case”只能出现在“Select Case”语句内。</value>
  </data>
  <data name="WRN_XMLDocCrefToTypeParameter" xml:space="preserve">
    <value>XML 注释中的一个标记具有绑定到类型参数的“cref”特性“{0}”。请改用 &lt;typeparamref&gt; 标记。</value>
  </data>
  <data name="WRN_DefAsgNoRetValPropVal1_Title" xml:space="preserve">
    <value>属性没有在所有代码路径上返回值</value>
  </data>
  <data name="ERR_InvInsideProc" xml:space="preserve">
    <value>语句在方法内部无效。</value>
  </data>
  <data name="ERR_InvInsideEnum" xml:space="preserve">
    <value>语句不能出现在枚举体内。</value>
  </data>
  <data name="ERR_IllegalOperandInIIFCount" xml:space="preserve">
    <value>“If”运算符需要两个或三个操作数。</value>
  </data>
  <data name="ERR_AmbiguousInNamespace2" xml:space="preserve">
    <value>“{1}”在命名空间中“{0}”不明确。</value>
  </data>
  <data name="WRN_XMLDocGenericParamTagWithoutName" xml:space="preserve">
    <value>XML 注释类型参数必须具有 "name" 属性。</value>
  </data>
  <data name="ERR_ModuleMemberCantImplement" xml:space="preserve">
    <value>模块中的成员无法实现接口成员。</value>
  </data>
  <data name="ERR_InvalidMultipleAttributeUsageInNetModule2" xml:space="preserve">
    <value>“{1}”中的属性“{0}”不能应用多次。</value>
  </data>
  <data name="ERR_ImportsMustBeFirst" xml:space="preserve">
    <value>“Imports”语句前面必须是声明。</value>
  </data>
  <data name="ERR_VarianceConversionFailedIn6" xml:space="preserve">
    <value>“{4}”不能转换为“{5}”，因为根据“{3}”中“In”泛型形参“{2}”的需要，“{0}”不是从“{1}”派生的。</value>
  </data>
  <data name="ERR_ExpectedXmlEndCData" xml:space="preserve">
    <value>应为 XML CDATA 部分的结束标记“]]&gt;”。</value>
  </data>
  <data name="WRN_RecursiveAddHandlerCall" xml:space="preserve">
    <value>语句以递归方式调用事件“{1}”的包含“{0}”。</value>
  </data>
  <data name="ERR_LoopDoubleCondition" xml:space="preserve">
    <value>"Loop" 和匹配的 "Do" 不能同时具有条件。</value>
  </data>
  <data name="ERR_CannotLiftStructureMeQuery" xml:space="preserve">
    <value>无法在结构中的查询表达式中使用实例成员和“Me”。</value>
  </data>
  <data name="ERR_SharedStructMemberCannotSpecifyNew" xml:space="preserve">
    <value>Structure 中的非共享成员不能声明为 "New"。</value>
  </data>
  <data name="WRN_XMLCannotWriteToXMLDocFile2_Title" xml:space="preserve">
    <value>无法创建 XML 文档文件</value>
  </data>
  <data name="ERR_MethodMustBeFirstStatementOnLine" xml:space="preserve">
    <value>方法声明语句必须是逻辑行上的第一条语句。</value>
  </data>
  <data name="ERR_NamespaceNotAtNamespace" xml:space="preserve">
    <value>"Namespace" 语句只能出现在文件级或命名空间级。</value>
  </data>
  <data name="ERR_CantReadRulesetFile" xml:space="preserve">
    <value>读取规则集文件 {0} 时出错 - {1}</value>
  </data>
  <data name="ERR_EmbeddedExpression" xml:space="preserve">
    <value>不能在此处使用嵌入式表达式。</value>
  </data>
  <data name="ERR_TypeMismatch2" xml:space="preserve">
    <value>类型“{0}”的值无法转换为“{1}”。</value>
  </data>
  <data name="ERR_ExpectedAs" xml:space="preserve">
    <value>应为 "As"。</value>
  </data>
  <data name="ERR_ExpectedEQ" xml:space="preserve">
    <value>应为 "="。</value>
  </data>
  <data name="ERR_ExpectedBy" xml:space="preserve">
    <value>应为 "By"。</value>
  </data>
  <data name="ERR_ExpectedIn" xml:space="preserve">
    <value>应为“In”。</value>
  </data>
  <data name="ERR_ExpectedLT" xml:space="preserve">
    <value>XML 标记前应有 "&lt;"。</value>
  </data>
  <data name="ERR_ExpectedOn" xml:space="preserve">
    <value>应为 "On"。</value>
  </data>
  <data name="ERR_WithEventsAsStruct" xml:space="preserve">
    <value>"WithEvents" 变量只能类型化为具有类约束的类、接口或类型参数。</value>
  </data>
  <data name="ERR_DuplicateReferenceStrong" xml:space="preserve">
    <value>导入了具有等效标识的多个程序集:“{0}”和“{1}”。请删除重复引用之一。</value>
  </data>
  <data name="WRN_XMLDocIllegalTagOnElement2_Title" xml:space="preserve">
    <value>语言元素中不允许出现 XML 注释标记</value>
  </data>
  <data name="ERR_OneOrTwoParametersRequired1" xml:space="preserve">
    <value>运算符“{0}”必须有一个两个参数。</value>
  </data>
  <data name="ERR_MissingRemoveHandlerDef1" xml:space="preserve">
    <value>缺少事件“{0}”的“RemoveHandler”定义。</value>
  </data>
  <data name="ERR_InvInsideBlock" xml:space="preserve">
    <value>语句在“{0}”块内部无效。</value>
  </data>
  <data name="ERR_MarshalUnmanagedTypeNotValidForFields" xml:space="preserve">
    <value>非托管类型“{0}”对于字段无效。</value>
  </data>
  <data name="WRN_UseOfObsoletePropertyAccessor3_Title" xml:space="preserve">
    <value>属性访问器已过时</value>
  </data>
  <data name="ERR_PublicKeyContainerFailure" xml:space="preserve">
    <value>从容器“{0}”中提取公钥时出错: {1}</value>
  </data>
  <data name="ERR_OverloadCandidate2" xml:space="preserve">
    <value>
  “{0}”: {1}</value>
  </data>
  <data name="ERR_OverloadCandidate1" xml:space="preserve">
    <value>
  {0}</value>
  </data>
  <data name="ERR_InheritanceAccessMismatch5" xml:space="preserve">
    <value>“{0}”将对基 {1} 的访问扩展到 {3}“{4}”，因此无法从 {1}“{2}”继承。</value>
  </data>
  <data name="ERR_XmlFeaturesNotAvailable" xml:space="preserve">
    <value>XML 文本和 XML 轴属性不可用。添加对 System.Xml、System.Xml.Linq 和 System.Core 的引用，或其他声明 System.Linq.Enumerable、System.Xml.Linq.XElement、System.Xml.Linq.XName、System.Xml.Linq.XAttribute 和 System.Xml.Linq.XNamespace 类型的程序集。</value>
  </data>
  <data name="ERR_LanguageVersion" xml:space="preserve">
    <value>Visual Basic {0} 不支持 {1}。</value>
  </data>
  <data name="ERR_ShadowingTypeOutsideClass1" xml:space="preserve">
    <value>“{0}”不能在类、结构或接口外声明为“Shadows”。</value>
  </data>
  <data name="ERR_GenericSubMainsFound1" xml:space="preserve">
    <value>在“{0}”中找到的带有适当签名的可访问“Main”方法要么都是泛型方法，要么嵌套在泛型类型中，因此均不能用作启动方法。</value>
  </data>
  <data name="WRN_ConstraintsFailedForInferredArgs2_Title" xml:space="preserve">
    <value>为方法推断的类型参数导致警告</value>
  </data>
  <data name="FEATURE_DigitSeparators" xml:space="preserve">
    <value>数字分隔符</value>
  </data>
  <data name="ERR_ObsoleteRedimAs" xml:space="preserve">
    <value>"ReDim" 语句不能再用于声明数组变量。</value>
  </data>
  <data name="ERR_ExtensionAttributeInvalid" xml:space="preserve">
    <value>编译器找到的“System.Runtime.CompilerServices.ExtensionAttribute”的自定义设计版本无效。必须将其特性用法标志设置为允许程序集、类和方法使用。</value>
  </data>
  <data name="TypeArgumentCannotBeNothing" xml:space="preserve">
    <value>类型参数不能是任何内容</value>
  </data>
  <data name="ERR_ConflictingMachineModule" xml:space="preserve">
    <value>程序集和模块“{0}”不能以不同处理器为目标。</value>
  </data>
  <data name="ERR_AnonymousTypeNeedField" xml:space="preserve">
    <value>匿名类型必须至少包含一个成员。</value>
  </data>
  <data name="ERR_InvInsideEndsEvent" xml:space="preserve">
    <value>语句不能出现在事件体内。假定为事件末尾。</value>
  </data>
  <data name="ERR_InitWithMultipleDeclarators" xml:space="preserve">
    <value>不允许通过用单个类型说明符声明多个变量来进行显式初始化。</value>
  </data>
  <data name="WRN_RequiredNonObsoleteNewCall4_Title" xml:space="preserve">
    <value>此 "Sub New" 的第一条语句必须是对 "MyBase.New" 或 "MyClass.New" 的显式调用，原因是基类中的构造函数被标为已过时</value>
  </data>
  <data name="FEATURE_CoContraVariance" xml:space="preserve">
    <value>方差</value>
  </data>
  <data name="ERR_InterfaceNoDefault1" xml:space="preserve">
    <value>无法为“{0}”编制索引，因为它没有默认属性。</value>
  </data>
  <data name="ERR_ConstraintClashIndirectDirect3" xml:space="preserve">
    <value>从类型参数约束“{1}”获得的间接约束“{0}”与约束“{2}”冲突。</value>
  </data>
  <data name="ERR_DuplicateResourceName1" xml:space="preserve">
    <value>资源名称“{0}”不能多次使用。</value>
  </data>
  <data name="ERR_MissingLibInDeclare" xml:space="preserve">
    <value>应为 "Lib"。</value>
  </data>
  <data name="ERR_AmbiguousInNamespaces2" xml:space="preserve">
    <value>“{0}”在命名空间“{1}”中的声明之间不明确。</value>
  </data>
  <data name="WRN_InvalidAssemblyName" xml:space="preserve">
    <value>程序集引用“{0}”无效，无法解析。</value>
  </data>
  <data name="ERR_DuplicateAccessCategoryUsed" xml:space="preserve">
    <value>Only one of 'Public', 'Private', 'Protected', 'Friend', 'Protected Friend', or 'Private Protected' can be specified.</value>
  </data>
  <data name="WRN_LambdaPassedToRemoveHandler_Title" xml:space="preserve">
    <value>Lambda 表达式将不会从此事件处理程序中删除</value>
  </data>
  <data name="ERR_DuplicateModifierCategoryUsed" xml:space="preserve">
    <value>只能指定 "NotOverridable"、"MustOverride" 或 "Overridable" 中的一个。</value>
  </data>
  <data name="ERR_InvalidFileAlignment" xml:space="preserve">
    <value>无效的文件节对齐方式“{0}”</value>
  </data>
  <data name="WRN_RecursivePropertyCall" xml:space="preserve">
    <value>表达式递归调用包含属性“{0}”。</value>
  </data>
  <data name="ERR_ReservedXmlNamespace" xml:space="preserve">
    <value>不能将前缀“{0}”绑定到为“{1}”保留的命名空间名称。</value>
  </data>
  <data name="ERR_ExpectedDotAfterMyBase" xml:space="preserve">
    <value>“MyBase”的后面必须跟有“.”和标识符。</value>
  </data>
  <data name="ERR_BadAsyncReturnOperand1" xml:space="preserve">
    <value>这是一个异步方法，因此返回表达式的类型必须为“{0}”而不是“Task(Of {0})”。</value>
  </data>
  <data name="ERR_SynthMemberClashesWithSynth7" xml:space="preserve">
    <value>{0}“{1}”隐式定义的“{2}”与为 {5}“{6}”中的 {3}“{4}”隐式声明的成员冲突。</value>
  </data>
  <data name="ERR_BadChecksumAlgorithm" xml:space="preserve">
    <value>不支持算法“{0}”</value>
  </data>
  <data name="ERR_NamedArgUsedTwice3" xml:space="preserve">
    <value>“{2}”中定义的扩展方法“{1}”的形参“{0}”已具有匹配的实参。</value>
  </data>
  <data name="ERR_NamedArgUsedTwice2" xml:space="preserve">
    <value>“{1}”的参数“{0}”已有匹配的参数。</value>
  </data>
  <data name="ERR_NamedArgUsedTwice1" xml:space="preserve">
    <value>形参“{0}”已具有匹配的实参。</value>
  </data>
  <data name="WRN_ConflictingMachineAssembly_Title" xml:space="preserve">
    <value>引用的程序集针对其他处理器</value>
  </data>
  <data name="ERR_HandlesSyntaxInClass" xml:space="preserve">
    <value>类中的“Handles”必须指定用单个标识符限定的“WithEvents”变量、“MyBase”、“MyClass”或“Me”。</value>
  </data>
  <data name="ERR_BinaryParamMustBeContainingType1" xml:space="preserve">
    <value>此二元运算符的至少一个参数必须属于包含类型“{0}”。</value>
  </data>
  <data name="ERR_ExtensionMethodNoParams" xml:space="preserve">
    <value>扩展方法必须至少声明一个参数。第一个参数指定要扩展的类型。</value>
  </data>
  <data name="FEATURE_AsyncExpressions" xml:space="preserve">
    <value>异步方法或 lambda</value>
  </data>
  <data name="ERR_BadFlagsOnNew1" xml:space="preserve">
    <value>“Sub New”不能声明为“{0}”。</value>
  </data>
  <data name="ERR_ExpectedSubOrFunction" xml:space="preserve">
    <value>“Delegate”后面应为“Sub”或“Function”。</value>
  </data>
  <data name="ERR_BadFlagsOnSharedMeth1" xml:space="preserve">
    <value>“Shared”不能与方法声明上的“{0}”组合。</value>
  </data>
  <data name="WRN_MissingAsClauseinOperator" xml:space="preserve">
    <value>运算符没有 "As" 子句；假定为 Object 类型。</value>
  </data>
  <data name="WRN_OverrideType5" xml:space="preserve">
    <value>{0}“{1}”与基 {3}“{4}”中的 {2}“{1}”冲突，应该声明为“Shadows”。</value>
  </data>
  <data name="WRN_ImplicitConversionSubst1" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="ERR_ContinueDoNotWithinDo" xml:space="preserve">
    <value>“Continue Do”只能出现在“Do”语句内。</value>
  </data>
  <data name="ERR_OverrideWithOptional2" xml:space="preserve">
    <value>“{0}”无法重写“{1}”，因为它们在可选参数上存在差异。</value>
  </data>
  <data name="ERR_InheritsTypeArgAccessMismatch7" xml:space="preserve">
    <value>“{0}”将对类型“{3}”的访问扩展到{4}“{5}”，因此无法从 {1}“{2}”继承。</value>
  </data>
  <data name="ERR_TooLongOrComplexExpression" xml:space="preserve">
    <value>表达式太长或者过于复杂，无法编译</value>
  </data>
  <data name="WRN_MutableGenericStructureInUsing" xml:space="preserve">
    <value>局部变量“{0}”是只读的。其类型为结构时，调用其成员或使用 ByRef 传递该类型不会更改其内容，并可能会导致意外的结果。考虑在“Using”块之外声明此变量。</value>
  </data>
  <data name="ERR_AmbiguousImplementsMember3" xml:space="preserve">
    <value>“{0}”存在于多个基接口中。请使用在“Implements”子句中声明“{0}”的接口的名称，而不要使用派生接口的名称。</value>
  </data>
  <data name="ERR_InvalidInstrumentationKind" xml:space="preserve">
    <value>无效的检测类型: {0}</value>
  </data>
  <data name="WRN_DefAsgNoRetValOpVal1" xml:space="preserve">
    <value>运算符“{0}”不会在所有代码路径上都返回值。是否缺少“Return”语句?</value>
  </data>
  <data name="WRN_DefAsgNoRetValOpRef1" xml:space="preserve">
    <value>运算符“{0}”不会在所有代码路径上都返回值。当使用结果时，可能会在运行时发生 null 引用异常。</value>
  </data>
  <data name="ERR_NamespaceNotAllowedInScript" xml:space="preserve">
    <value>不能在脚本代码中声明命名空间</value>
  </data>
  <data name="ERR_BadFlagsOnNewOverloads" xml:space="preserve">
    <value>“{0}”关键字用于重载继承的成员；重载“Sub New”时不要使用“{0}”关键字。</value>
  </data>
  <data name="ERR_QueryAnonTypeFieldXMLNameInference" xml:space="preserve">
    <value>无法根据不是有效 Visual Basic 标识符的 XML 标识符推断出范围变量名。</value>
  </data>
  <data name="ERR_XmlEndElementNoMatchingStart" xml:space="preserve">
    <value>XML 结束元素前面必须是匹配的开始元素。</value>
  </data>
  <data name="IDS_MSG_ADDLINKREFERENCE" xml:space="preserve">
    <value>正在添加嵌入程序集引用“{0}”</value>
  </data>
  <data name="WRN_AsyncLacksAwaits_Title" xml:space="preserve">
    <value>此异步方法缺少 "Await" 运算符，因此将以同步方式运行</value>
  </data>
  <data name="WRN_UseSwitchInsteadOfAttribute_Title" xml:space="preserve">
    <value>使用命令行选项 /keyfile、/keycontainer 或 /delaysign，而不要使用 AssemblyKeyFileAttribute、AssemblyKeyNameAttribute 或 AssemblyDelaySignAttribute</value>
  </data>
  <data name="ERR_NoAccessibleConstructorOnBase" xml:space="preserve">
    <value>类“{0}”没有可访问的“Sub New”，不能被继承。</value>
  </data>
  <data name="ERR_NoConstructorOnBase2" xml:space="preserve">
    <value>类“{0}”必须声明一个“Sub New”，原因是它的基类“{1}”没有不使用参数就可以调用的可访问“Sub New”。</value>
  </data>
  <data name="ERR_VarianceInterfaceNesting" xml:space="preserve">
    <value>无法在含有 "In" 或 "Out" 类型参数的接口中声明枚举、类和结构。</value>
  </data>
  <data name="WRN_RecursiveOperatorCall_Title" xml:space="preserve">
    <value>表达式递归调用包含运算符</value>
  </data>
  <data name="WRN_XMLDocBadGenericParamTag2_Title" xml:space="preserve">
    <value>XML 注释类型参数与相应的声明语句上的类型参数不匹配</value>
  </data>
  <data name="ERR_StructureNoDefault1" xml:space="preserve">
    <value>无法为结构“{0}”编制索引，因为它没有默认属性。</value>
  </data>
  <data name="ERR_TypeInferenceFailureNoBest1" xml:space="preserve">
    <value>无法从这些实参推断类型形参的数据类型，因为这些数据类型不会转换为同一类型。显式指定数据类型可更正此错误。</value>
  </data>
  <data name="ERR_TypeInferenceFailureNoBest3" xml:space="preserve">
    <value>无法从这些实参推断“{1}”中定义的扩展方法“{0}”中类型形参的数据类型，因为这些数据类型不会转换为同一类型。显式指定数据类型可更正此错误。</value>
  </data>
  <data name="ERR_TypeInferenceFailureNoBest2" xml:space="preserve">
    <value>无法从这些实参推断方法“{0}”中类型形参的数据类型，因为这些数据类型不会转换为同一类型。显式指定数据类型可更正此错误。</value>
  </data>
  <data name="ERR_BadIsCompletedOnCompletedGetResult2" xml:space="preserve">
    <value>“Await”要求“{1}.GetAwaiter()”的返回类型“{0}”包含适当的 IsCompleted、OnCompleted 和 GetResult 成员，并实现 INotifyCompletion 或 ICriticalNotifyCompletion</value>
  </data>
  <data name="ERR_AmbiguousWidestType3" xml:space="preserve">
    <value>“{0}”的类型不明确，因为循环边界和 step 子句不会转换为同一类型。</value>
  </data>
  <data name="WRN_DefAsgNoRetValFuncVal1" xml:space="preserve">
    <value>函数“{0}”不会在所有代码路径上都返回值。是否缺少“Return”语句?</value>
  </data>
  <data name="WRN_DefAsgNoRetValFuncRef1" xml:space="preserve">
    <value>函数“{0}”不会在所有代码路径上都返回值。当使用结果时，可能会在运行时发生 null 引用异常。</value>
  </data>
  <data name="ERR_UnsupportedConstant2" xml:space="preserve">
    <value>字段“{0}.{1}”具有无效常量值。</value>
  </data>
  <data name="ERR_DelegateBindingMismatch" xml:space="preserve">
    <value>方法没有与委托兼容的签名。</value>
  </data>
  <data name="ERR_ModuleCantUseEventSpecifier1" xml:space="preserve">
    <value>模块中的事件不能声明为“{0}”。</value>
  </data>
  <data name="ERR_VoidValue" xml:space="preserve">
    <value>表达式不产生值。</value>
  </data>
  <data name="ERR_CmdOptionConflictsSource" xml:space="preserve">
    <value>源文件中提供的特定“{0}”与选项“{1}”冲突。</value>
  </data>
  <data name="ERR_ArrayInitializerTooFewDimensions" xml:space="preserve">
    <value>数组初始值设定项的维数太少。</value>
  </data>
  <data name="ERR_RestrictedResumableType1" xml:space="preserve">
    <value>“{0}”不能用作 Iterator 或 Async 方法的参数类型。</value>
  </data>
  <data name="ERR_ConvertArrayMismatch4" xml:space="preserve">
    <value>类型“{0}”的值无法转换为“{1}”，因为“{2}”不是从“{3}”派生的。</value>
  </data>
  <data name="ERR_CannotLiftByRefParamLambda1" xml:space="preserve">
    <value>不能在 lambda 表达式中使用“ByRef”参数“{0}”。</value>
  </data>
  <data name="ERR_InheritsFrom2" xml:space="preserve">
    <value>
  “{0}”从“{1}”继承。</value>
  </data>
  <data name="ERR_DllImportNotLegalOnEventMethod" xml:space="preserve">
    <value>"System.Runtime.InteropServices.DllImportAttribute" 不能应用于 "AddHandler"、"RemoveHandler" 或 "RaiseEvent" 方法。</value>
  </data>
  <data name="WRN_LateBindingResolution_Title" xml:space="preserve">
    <value>后期绑定解决方案</value>
  </data>
  <data name="ERR_LinkedNetmoduleMetadataMustProvideFullPEImage" xml:space="preserve">
    <value>链接 netmodule 元数据必须提供完整 PE 映像:“{0}”。</value>
  </data>
  <data name="ERR_BadIteratorByRefParam" xml:space="preserve">
    <value>迭代器方法不能包含 ByRef 参数。</value>
  </data>
  <data name="ERR_VarianceOutPropertyDisallowed1" xml:space="preserve">
    <value>在此上下文中，类型“{0}”不能用作属性类型，因为“{0}”是“Out”类型参数，且该属性未标记为 ReadOnly。</value>
  </data>
  <data name="ERR_QuotedEmbeddedExpression" xml:space="preserve">
    <value>带引号的特性值内不能出现嵌入式表达式。请尝试移除引号。</value>
  </data>
  <data name="ERR_ExtensionOnlyAllowedOnModuleSubOrFunction" xml:space="preserve">
    <value>“Extension”特性只能应用于“Module”、“Sub”或“Function”声明。</value>
  </data>
  <data name="WRN_ArrayInitTooManyTypesObjectAssumed_Title" xml:space="preserve">
    <value>无法推断元素类型，原因是可能存在多个类型</value>
  </data>
  <data name="RangeVariableSyntaxNotWithinSyntaxTree" xml:space="preserve">
    <value>RangeVariableSyntax 不在语法树中</value>
  </data>
  <data name="WRN_RootNamespaceNotCLSCompliant1_Title" xml:space="preserve">
    <value>根命名空间不符合 CLS</value>
  </data>
  <data name="ERR_BadTypeArgForStructConstraintNull" xml:space="preserve">
    <value>类型“{0}”必须是一个被约束为“Structure”的值类型或类型参数，才能与“Nullable”或可以为 null 的修饰符“?”一起使用。</value>
  </data>
  <data name="ERR_DuplicateLocalTypes3" xml:space="preserve">
    <value>无法嵌入程序集“{1}”和“{2}”中找到的互操作类型“{0}”。请考虑禁用互操作类型的嵌入。</value>
  </data>
  <data name="HDN_UnusedImportClause" xml:space="preserve">
    <value>未使用导入子句。</value>
  </data>
  <data name="WRN_UseSwitchInsteadOfAttribute" xml:space="preserve">
    <value>请使用命令行选项“{0}”或适当的项目设置，而不是“{1}”。</value>
  </data>
  <data name="WRN_InheritedInterfaceNotCLSCompliant2" xml:space="preserve">
    <value>“{0}”不符合 CLS，因为它所继承的接口“{1}”不符合 CLS。</value>
  </data>
  <data name="WRN_XMLMissingFileOrPathAttribute1_Title" xml:space="preserve">
    <value>XML 注释标记 "include" 必须具有 "file" 和 "path" 特性</value>
  </data>
  <data name="ERR_UnsupportedField1" xml:space="preserve">
    <value>字段“{0}”的类型不受支持。</value>
  </data>
  <data name="ERR_BadDocumentationMode" xml:space="preserve">
    <value>提供的文档模式不受支持或无效:“{0}”。</value>
  </data>
  <data name="NotAVbSymbol" xml:space="preserve">
    <value>不是 VB 符号。</value>
  </data>
  <data name="WRN_RootNamespaceNotCLSCompliant2" xml:space="preserve">
    <value>根命名空间“{1}”中的名称“{0}”不符合 CLS。</value>
  </data>
  <data name="WRN_RootNamespaceNotCLSCompliant1" xml:space="preserve">
    <value>根命名空间“{0}”不符合 CLS。</value>
  </data>
  <data name="ERR_LoopControlMustNotAwait" xml:space="preserve">
    <value>循环控制变量不可包含 "Await"。</value>
  </data>
  <data name="WRN_DefAsgNoRetValWinRtEventVal1_Title" xml:space="preserve">
    <value>Windows 运行时事件的 AddHandler 没有在所有代码路径上返回值</value>
  </data>
  <data name="ERR_DuplicateRawGenericTypeImport1" xml:space="preserve">
    <value>不能多次导入泛型类型“{0}”。</value>
  </data>
  <data name="WRN_TupleLiteralNameMismatch_Title" xml:space="preserve">
    <value>由于分配目标指定了其他名称或未指定名称，因此元组元素名称被忽略。</value>
  </data>
  <data name="WRN_ReferencedAssemblyDoesNotHaveStrongName_Title" xml:space="preserve">
    <value>引用的程序集没有强名称</value>
  </data>
  <data name="ERR_PropertyNameConflictInMyCollection" xml:space="preserve">
    <value>“{0}”与“My”组中公开的类型“{1}”所使用的成员同名。请重命名该类型或其封闭命名空间。</value>
  </data>
  <data name="ERR_ExpectedNamedArgumentInAttributeList" xml:space="preserve">
    <value>Named argument expected.</value>
  </data>
  <data name="ERR_NameNotEvent2" xml:space="preserve">
    <value>“{0}”不是“{1}”的事件。</value>
  </data>
  <data name="ERR_ConstantStringTooLong" xml:space="preserve">
    <value>字符串常量的长度超出了当前内存限制。请尝试将字符串拆分成多个常量。</value>
  </data>
  <data name="ERR_ParamArrayIllegal1" xml:space="preserve">
    <value>“{0}”参数不能声明为“ParamArray”。</value>
  </data>
  <data name="WRN_ReferencedAssemblyDoesNotHaveStrongName" xml:space="preserve">
    <value>引用程序集“{0}”没有强名称。</value>
  </data>
  <data name="ERR_ImplementationMustBePrivate2" xml:space="preserve">
    <value>方法“{0}”必须声明为“Private”，以便实现分部方法“{1}”。</value>
  </data>
  <data name="ERR_BadPropertyAccessorFlagsRestrict" xml:space="preserve">
    <value>访问修饰符“{0}”无效。“Get”和“Set”的访问修饰符的限制性应该比属性访问级别更强。</value>
  </data>
  <data name="ERR_InheritsFromRestrictedType1" xml:space="preserve">
    <value>从“{0}”继承无效。</value>
  </data>
  <data name="ERR_IconFileAndWin32ResFile" xml:space="preserve">
    <value>不能同时指定 /win32icon 和 /win32resource</value>
  </data>
  <data name="FEATURE_AutoProperties" xml:space="preserve">
    <value>自动实现的属性</value>
  </data>
  <data name="FEATURE_PartialInterfaces" xml:space="preserve">
    <value>部分接口</value>
  </data>
  <data name="WRN_XMLDocBadParamTag2_Title" xml:space="preserve">
    <value>XML 注释参数与相应的声明语句上的参数不匹配</value>
  </data>
  <data name="ERR_VarianceOutParamDisallowed1" xml:space="preserve">
    <value>类型“{0}”不能用于此上下文，因为“{0}”是“Out”类型参数。</value>
  </data>
  <data name="ERR_InvalidDebugInfo" xml:space="preserve">
    <value>Unable to read debug information of method '{0}' (token 0x{1}) from assembly '{2}'</value>
  </data>
  <data name="ERR_DefaultMissingFromProperty2" xml:space="preserve">
    <value>“{0}”和“{1}”中只有一个声明为“Default”，因此它们无法相互重载。</value>
  </data>
  <data name="ERR_EncodinglessSyntaxTree" xml:space="preserve">
    <value>无法在不进行编码的情况下发出源文本的调试信息。</value>
  </data>
  <data name="ERR_BaseMismatchForPartialClass3" xml:space="preserve">
    <value>为类“{1}”指定的基类“{0}”不能与它的其他分部类型之一的基类“{2}”不同。</value>
  </data>
  <data name="ERR_DuplicateAggrMemberInit1" xml:space="preserve">
    <value>多次初始化“{0}”的。字段和属性只能在对象初始值设定项表达式中初始化一次。</value>
  </data>
  <data name="ERR_ExitSelectNotWithinSelect" xml:space="preserve">
    <value>"Exit Select" 只能出现在 "Select" 语句内。</value>
  </data>
  <data name="ERR_IfNoTypeObjectDisallowed" xml:space="preserve">
    <value>无法推断通用类型，且 Option Strict On 不允许假定“Object”。</value>
  </data>
  <data name="ERR_AmbiguousInUnnamedNamespace1" xml:space="preserve">
    <value>“{0}”不明确。</value>
  </data>
  <data name="ERR_LibNotFound" xml:space="preserve">
    <value>找不到库“{0}”</value>
  </data>
  <data name="WRN_MustOverloadBase4_Title" xml:space="preserve">
    <value>成员隐藏在基类型中声明的可重载的成员</value>
  </data>
  <data name="ERR_DefaultValueForNonOptionalParam" xml:space="preserve">
    <value>无法向未声明为 "Optional" 的参数提供默认值。</value>
  </data>
  <data name="ERR_DateToDoubleConversion" xml:space="preserve">
    <value>从“Date”到“Double”的转换需要调用“Date.ToOADate”方法。</value>
  </data>
  <data name="WRN_EventDelegateTypeNotCLSCompliant2_Title" xml:space="preserve">
    <value>事件的委托类型不符合 CLS</value>
  </data>
  <data name="ERR_CannotLiftStructureMeLambda" xml:space="preserve">
    <value>无法在结构中的 lambda 表达式内使用实例成员和“Me”。</value>
  </data>
  <data name="ERR_CannotLiftRestrictedTypeQuery" xml:space="preserve">
    <value>不能在查询表达式中使用受限类型“{0}”的实例。</value>
  </data>
  <data name="ERR_InvalidEndRaiseEvent" xml:space="preserve">
    <value>“End RaiseEvent”前面必须是匹配的“RaiseEvent”声明。</value>
  </data>
  <data name="ERR_QueryOperatorNotFound" xml:space="preserve">
    <value>方法“{0}”的定义在此上下文中不可访问。</value>
  </data>
  <data name="ERR_InaccessibleMember3" xml:space="preserve">
    <value>“{0}.{1}”是“{2}” ,因此它在此上下文中不可访问。</value>
  </data>
  <data name="WRN_UseOfObsoletePropertyAccessor2" xml:space="preserve">
    <value>“{1}”的“{0}”访问器已过时。</value>
  </data>
  <data name="WRN_UseOfObsoletePropertyAccessor3" xml:space="preserve">
    <value>“{1}”的“{0}”访问器已过时:“{2}”。</value>
  </data>
  <data name="ERR_VarianceInNullableDisallowed2" xml:space="preserve">
    <value>类型“{0}”不能用于“{1}”，因为“In”和“Out”类型参数不能设置为可以为 null，并且“{0}”是“In”类型参数。</value>
  </data>
  <data name="ERR_InValidSubMainsFound1" xml:space="preserve">
    <value>“{0}”中找不到带有适当签名的可访问“Main”方法。</value>
  </data>
  <data name="ERR_TypeFwdCycle2" xml:space="preserve">
    <value>程序集“{1}”中的“{0}”已被转发给自身，因此它是一种不受支持的类型。</value>
  </data>
  <data name="WRN_AssemblyGeneration0_Title" xml:space="preserve">
    <value>生成程序集时检测到可能的问题</value>
  </data>
  <data name="ERR_BadInterfacePropertyFlags1" xml:space="preserve">
    <value>“{0}”在接口属性声明中无效。</value>
  </data>
  <data name="ERR_ExtensionMethodOverloadCandidate2" xml:space="preserve">
    <value>
  “{1}”中定义的扩展方法“{0}”。</value>
  </data>
  <data name="ERR_ExtensionMethodOverloadCandidate3" xml:space="preserve">
    <value>
  “{1}”中定义的扩展方法“{0}”: {2}</value>
  </data>
  <data name="WRN_ObjectAssumedVar1_Title" xml:space="preserve">
    <value>变量声明没有 "As" 子句</value>
  </data>
  <data name="WRN_XMLDocOnAPartialType" xml:space="preserve">
    <value>XML 注释在分部 {0} 中不能应用多次。此 {0} 的 XML 注释将被忽略。</value>
  </data>
  <data name="IDS_MSG_ADDMODULE" xml:space="preserve">
    <value>正在添加模块引用“{0}”</value>
  </data>
  <data name="ERR_LambdaTooManyTypesObjectDisallowed" xml:space="preserve">
    <value>无法推断返回类型，因为可能存在多个类型。请考虑添加一个 "As" 子句来指定返回类型。</value>
  </data>
  <data name="WRN_UndefinedOrEmptyProjectNamespaceOrClass1_Title" xml:space="preserve">
    <value>在项目级别导入的命名空间或类型不包含任何公共成员或找不到公共成员</value>
  </data>
  <data name="ERR_ForwardedTypesConflict" xml:space="preserve">
    <value>转发到程序集“{1}”的类型“{0}”与转发到程序集“{3}”的类型“{2}”冲突。</value>
  </data>
  <data name="ERR_NoGetProperty1" xml:space="preserve">
    <value>属性“{0}”为“WriteOnly”。</value>
  </data>
  <data name="ERR_ComClassCantBeAbstract0" xml:space="preserve">
    <value>“Microsoft.VisualBasic.ComClassAttribute”不能应用于被声明为“MustInherit”的类。</value>
  </data>
  <data name="WRN_GenericConstraintNotCLSCompliant1" xml:space="preserve">
    <value>泛型形参约束类型“{0}”不符合 CLS。</value>
  </data>
  <data name="ERR_ParamArrayRank" xml:space="preserve">
    <value>ParamArray 参数必须是一维数组。</value>
  </data>
  <data name="ERR_NullPropagatingOpInExpressionTree" xml:space="preserve">
    <value>无法将 null 传播运算符转换为表达式树。</value>
  </data>
  <data name="ERR_DllImportOnInstanceMethod" xml:space="preserve">
    <value>"System.Runtime.InteropServices.DllImportAttribute" 不能应用于实例方法。</value>
  </data>
  <data name="ERR_EndOperatorExpected" xml:space="preserve">
    <value>应为 "End Operator"。</value>
  </data>
  <data name="WRN_XMLDocParseError1" xml:space="preserve">
    <value>XML 文档分析错误: {0} XML 注释将被忽略。</value>
  </data>
  <data name="ERR_OverridingPropertyKind2" xml:space="preserve">
    <value>“{0}”无法重写“{1}”，因为它们在是“ReadOnly”还是“WriteOnly”上不同。</value>
  </data>
  <data name="WRN_XMLDocParseError1_Title" xml:space="preserve">
    <value>XML 文档分析错误</value>
  </data>
  <data name="ERR_TypeInferenceFailureNoExplicit3" xml:space="preserve">
    <value>无法从这些实参推断“{1}”中定义的扩展方法“{0}”中类型形参的数据类型。</value>
  </data>
  <data name="ERR_TypeInferenceFailureNoExplicit2" xml:space="preserve">
    <value>无法从这些实参推断方法“{0}”中类型形参的数据类型。</value>
  </data>
  <data name="ERR_TypeInferenceFailureNoExplicit1" xml:space="preserve">
    <value>无法从这些实参推断类型形参的数据类型。</value>
  </data>
  <data name="ERR_MissingRaiseEventDef1" xml:space="preserve">
    <value>缺少事件“{0}”的“RaiseEvent”定义。</value>
  </data>
  <data name="ERR_PartialDeclarationImplements1" xml:space="preserve">
    <value>分部方法“{0}”不能使用“Implements”关键字。</value>
  </data>
  <data name="WRN_UndefinedOrEmptyNamespaceOrClass1_Title" xml:space="preserve">
    <value>在 Imports 语句中指定的命名空间或类型不包含任何公共成员或找不到公共成员</value>
  </data>
  <data name="ERR_NoPartialMethodInAddressOf1" xml:space="preserve">
    <value>“AddressOf”不能应用于“{0}”，因为“{0}”是不包含实现的分部方法。</value>
  </data>
  <data name="ERR_AttrAssignmentNotFieldOrProp1" xml:space="preserve">
    <value>“{0}”不是字段或属性(Property)，因此不能命名为属性(Attribute)说明符中的参数。</value>
  </data>
  <data name="ERR_OnlyOneImplementingMethodAllowed3" xml:space="preserve">
    <value>方法“{0}”无法实现分部方法“{1}”，因为它已经由“{2}”实现。分部方法只能由一个方法实现。</value>
  </data>
  <data name="ERR_AccessMismatchImplementedEvent4" xml:space="preserve">
    <value>“{0}”不能通过 {2}“{3}”公开它正在实现的事件的基础委托类型“{1}”。</value>
  </data>
  <data name="ERR_AccessMismatchImplementedEvent6" xml:space="preserve">
    <value>“{0}”不能通过 {4}“{5}”向 {2}“{3}”公开它正在实现的事件的基础委托类型“{1}”。</value>
  </data>
  <data name="ERR_StrictDisallowsObjectOperand1" xml:space="preserve">
    <value>Option Strict On 禁止将 Object 类型的操作数用于运算符“{0}”。</value>
  </data>
  <data name="ERR_ExpectedEndSelect" xml:space="preserve">
    <value>“Select Case”必须以匹配的“End Select”结束。</value>
  </data>
  <data name="ERR_AutoPropertyCantBeWriteOnly" xml:space="preserve">
    <value>自动实现的属性不能为 WriteOnly。</value>
  </data>
  <data name="ERR_DllImportOnGenericSubOrFunction" xml:space="preserve">
    <value>"System.Runtime.InteropServices.DllImportAttribute" 不能应用于属于泛型类型或者包含在泛型类型中的方法。</value>
  </data>
  <data name="ERR_InheritanceAccessMismatchOutside3" xml:space="preserve">
    <value>“{0}”将对基 {1} 的访问扩展到程序集之外，因此无法从 {1}“{2}”继承。</value>
  </data>
  <data name="WRN_MissingAsClauseinProperty_Title" xml:space="preserve">
    <value>属性没有 "As" 子句</value>
  </data>
  <data name="ERR_SxSIndirectRefHigherThanDirectRef3" xml:space="preserve">
    <value>项目当前包含对多个版本的“{0}”的引用、对版本 {2} 的直接引用和对版本 {1} 的间接引用。请将直接引用更改为使用 {0} 的版本 {1} (或更高版本)。</value>
  </data>
  <data name="ERR_EndFunctionExpected" xml:space="preserve">
    <value>应为 "End Function"。</value>
  </data>
  <data name="ERR_GotoIntoSyncLock" xml:space="preserve">
    <value>“GoTo {0}”无效，因为“{0}”位于不包含此语句的“SyncLock”语句中。</value>
  </data>
  <data name="ERR_ExpressionDoesntHaveName" xml:space="preserve">
    <value>该表达式不具有名称。</value>
  </data>
  <data name="WRN_IfTooManyTypesObjectAssumed" xml:space="preserve">
    <value>无法推断通用类型，因为可能存在多个类型；假定为 "Object"。</value>
  </data>
  <data name="FEATURE_LeadingDigitSeparator" xml:space="preserve">
    <value>leading digit separator</value>
  </data>
  <data name="ERR_ExpectedStringLiteral" xml:space="preserve">
    <value>应为字符串常量。</value>
  </data>
  <data name="ERR_UnsupportedEvent1" xml:space="preserve">
    <value>“{0}”是不受支持的事件。</value>
  </data>
  <data name="ERR_OperatorRequiresIntegerParameter1" xml:space="preserve">
    <value>运算符“{0}”必须有另一个“Integer”或“Integer?”类型的参数。</value>
  </data>
  <data name="ERR_BadAttributeUuid2" xml:space="preserve">
    <value>GUID“{1}”的格式不正确，因此无法应用“{0}”。</value>
  </data>
  <data name="ERR_UsingResourceVarCantBeArray" xml:space="preserve">
    <value>"Using" 资源变量类型不能是数组类型。</value>
  </data>
  <data name="ERR_MixingWinRTAndNETEvents" xml:space="preserve">
    <value>事件“{0}”无法实现 Windows 运行时事件“{1}”和常规 .NET 事件“{2}”</value>
  </data>
  <data name="ERR_LoopControlMustNotBeProperty" xml:space="preserve">
    <value>循环控制变量不能是属性或后期绑定索引数组。</value>
  </data>
  <data name="ERR_PropertyDoesntImplementAllAccessors" xml:space="preserve">
    <value>“{0}”无法由 {1} 属性实现。</value>
  </data>
  <data name="ERR_ImplementsGenericParam" xml:space="preserve">
    <value>“Implements”子句中不允许类型参数。</value>
  </data>
  <data name="ERR_FinallyNoMatchingTry" xml:space="preserve">
    <value>“Finally”不能出现在“Try”语句之外。</value>
  </data>
  <data name="ERR_EndWithWithoutWith" xml:space="preserve">
    <value>“End With”前面必须是匹配的“With”。</value>
  </data>
  <data name="WRN_XMLDocInvalidXMLFragment_Title" xml:space="preserve">
    <value>无法包含 XML 片段</value>
  </data>
  <data name="ERR_ExpectedEndRegion" xml:space="preserve">
    <value>"#Region" 语句必须以匹配的 "#End Region" 结束。</value>
  </data>
  <data name="ERR_LocalNamedSameAsParam1" xml:space="preserve">
    <value>“{0}”已声明为此方法的参数。</value>
  </data>
  <data name="ERR_ForwardedTypeConflictsWithDeclaration" xml:space="preserve">
    <value>转发的类型“{0}”与此程序集主模块中声明的类型冲突。</value>
  </data>
  <data name="ERR_ExpectedCase" xml:space="preserve">
    <value>位于 "Select Case" 与第一个 "Case" 之间的语句和标签无效。</value>
  </data>
  <data name="ERR_ExpectedInto" xml:space="preserve">
    <value>应为“Into”。</value>
  </data>
  <data name="ERR_ExpectedFrom" xml:space="preserve">
    <value>应为“From”。</value>
  </data>
  <data name="ERR_ExpectedLoop" xml:space="preserve">
    <value>"Do" 必须以匹配的 "Loop" 结束。</value>
  </data>
  <data name="ERR_ExpectedJoin" xml:space="preserve">
    <value>应为“Join”。</value>
  </data>
  <data name="ERR_ExpectedNext" xml:space="preserve">
    <value>"For" 必须以匹配的 "Next" 结束。</value>
  </data>
  <data name="ERR_MultipleExtends" xml:space="preserve">
    <value>"Inherits" 只能在 "Class" 语句中出现一次，并且只能指定一个类。</value>
  </data>
  <data name="ERR_IllegalXmlnsPrefix" xml:space="preserve">
    <value>元素名不能使用“xmlns”前缀。</value>
  </data>
  <data name="NoNoneSearchCriteria" xml:space="preserve">
    <value>需要 SearchCriteria。</value>
  </data>
  <data name="ERR_BadAttributePropertyType1" xml:space="preserve">
    <value>属性或字段“{0}”没有有效的特性类型。</value>
  </data>
  <data name="ERR_EncNoPIAReference" xml:space="preserve">
    <value>无法继续，因为编辑包括对嵌入类型的引用:“{0}”。</value>
  </data>
  <data name="WRN_UnobservedAwaitableExpression" xml:space="preserve">
    <value>由于此调用不会等待，因此在调用完成前将继续执行当前方法。请考虑对调用结果应用 Await 运算符。</value>
  </data>
  <data name="ERR_TypeNotExpression1" xml:space="preserve">
    <value>“{0}”是一个类型，不能用作表达式。</value>
  </data>
  <data name="SpeculatedSyntaxNodeCannotBelongToCurrentCompilation" xml:space="preserve">
    <value>要推断的语法节点不能属于来自当前编译的语法树。</value>
  </data>
  <data name="ERR_SecurityAttributeInvalidAction" xml:space="preserve">
    <value>安全属性“{0}”具有无效的 SecurityAction 值“{1}”。</value>
  </data>
  <data name="WRN_PdbLocalNameTooLong" xml:space="preserve">
    <value>本地名称“{0}”对于 PDB 太长。请考虑缩短或在不使用 /debug 的情况下编译。</value>
  </data>
  <data name="WRN_IgnoreModuleManifest_Title" xml:space="preserve">
    <value>/win32manifest 选项已忽略</value>
  </data>
  <data name="ERR_OmittedArgument2" xml:space="preserve">
    <value>没有为“{1}”的形参“{0}”指定实参。</value>
  </data>
  <data name="ERR_OmittedArgument3" xml:space="preserve">
    <value>没有为“{2}”中定义的扩展方法“{1}”的形参“{0}”指定实参。</value>
  </data>
  <data name="ERR_OmittedArgument1" xml:space="preserve">
    <value>没有为参数“{0}”指定参数。</value>
  </data>
  <data name="WRN_UnobservedAwaitableExpression_Title" xml:space="preserve">
    <value>在调用完成之前，会继续执行当前方法，原因是此调用不处于等待状态</value>
  </data>
  <data name="ERR_RefAndClassTypeConstrCombined" xml:space="preserve">
    <value>"Class" 约束不能与特定的类类型约束组合。</value>
  </data>
  <data name="ERR_ForEachAmbiguousIEnumerable1" xml:space="preserve">
    <value>类型“{0}”的“For Each”不明确，因为此类型实现了“System.Collections.Generic.IEnumerable(Of T)”的多个实例化。</value>
  </data>
  <data name="FEATURE_NullPropagatingOperator" xml:space="preserve">
    <value>空条件操作</value>
  </data>
  <data name="WRN_NonCLSMustOverrideInCLSType1_Title" xml:space="preserve">
    <value>在符合 CLS 的类型中不允许出现不符合 CLS 的 "Mustoverride" 成员</value>
  </data>
  <data name="ERR_MethodTypeArgsUnexpected" xml:space="preserve">
    <value>意外的方法类型参数。</value>
  </data>
  <data name="ERR_Merge_conflict_marker_encountered" xml:space="preserve">
    <value>遇到合并冲突标记</value>
  </data>
  <data name="ERR_PlatformDoesntSupport" xml:space="preserve">
    <value>当前项目类型不支持 {0}。</value>
  </data>
  <data name="NumberOfTypeParametersAndArgumentsMustMatch" xml:space="preserve">
    <value>类型形参和实参的数量应相同</value>
  </data>
  <data name="WRN_InvalidWarningId_Title" xml:space="preserve">
    <value>警告编号不可配置或无效</value>
  </data>
  <data name="ERR_StaticInLambda" xml:space="preserve">
    <value>无法在 lambda 表达式内声明静态局部变量。</value>
  </data>
  <data name="ERR_GenericArgsOnAttributeSpecifier" xml:space="preserve">
    <value>由于特性不能是泛型，因此类型参数无效。</value>
  </data>
  <data name="ERR_TooLongMetadataName" xml:space="preserve">
    <value>名称“{0}”超出元数据中允许的最大长度。</value>
  </data>
  <data name="ERR_PublicSignNetModule" xml:space="preserve">
    <value>netmodule 不支持公共签名。</value>
  </data>
  <data name="WRN_UseValueForXmlExpression3" xml:space="preserve">
    <value>无法将“{0}”转换为“{1}”。可使用“Value”属性来获取“{2}”的第一个元素的字符串值。</value>
  </data>
  <data name="ERR_BadStaticLocalInStruct" xml:space="preserve">
    <value>结构方法内部的局部变量不能声明为“Static”。</value>
  </data>
  <data name="ERR_StructLayoutAttributeNotAllowed" xml:space="preserve">
    <value>特性 "StructLayout" 不能应用于泛型类型。</value>
  </data>
  <data name="ERR_CantOverrideNotOverridable2" xml:space="preserve">
    <value>“{0}”无法重写“{1}”，因为后者已声明为“NotOverridable”。</value>
  </data>
  <data name="ChainingSpeculativeModelIsNotSupported" xml:space="preserve">
    <value>不支持链接推理语义模型。应从非推理 ParentModel 创建推理模型。</value>
  </data>
  <data name="ERR_GotoIntoUsing" xml:space="preserve">
    <value>“GoTo {0}”无效，因为“{0}”位于不包含此语句的“Using”语句中。</value>
  </data>
  <data name="ERR_LambdaNoTypeObjectDisallowed" xml:space="preserve">
    <value>无法推断返回类型。请考虑添加一个 "As" 子句来指定返回类型。</value>
  </data>
  <data name="ERR_BadAttribute1" xml:space="preserve">
    <value>特性“{0}”无效: 参数值不正确。</value>
  </data>
  <data name="ERR_ExpectedExitKind" xml:space="preserve">
    <value>“Exit”的后面必须跟有“Sub”、“Function”、“Property”、“Do”、“For”、“While”、“Select”或“Try”。</value>
  </data>
  <data name="ERR_RequiredNewCall2" xml:space="preserve">
    <value>“{1}”的基类“{0}”没有不使用参数就可以调用的可访问“Sub New”，因此该“Sub New”的第一个语句必须是对“MyBase.New”或“MyClass.New”的调用。</value>
  </data>
  <data name="ERR_ExportedTypesConflict" xml:space="preserve">
    <value>从模块“{1}”导出的类型“{0}”与从模块“{3}”导出的类型“{2}”冲突。</value>
  </data>
  <data name="ERR_DelegateCantImplement" xml:space="preserve">
    <value>委托无法实现接口方法。</value>
  </data>
  <data name="ERR_EndModuleNoModule" xml:space="preserve">
    <value>"End Module" 前面必须是匹配的 "Module"。</value>
  </data>
  <data name="ERR_NeedModule" xml:space="preserve">
    <value>只有在生成“module”类型的目标时才能指定 /moduleassemblyname 选项</value>
  </data>
  <data name="WRN_InvalidWarningId" xml:space="preserve">
    <value>选项“{1}”的警告编号“{0}”不可配置或无效</value>
  </data>
  <data name="ERR_InterfaceUnifiesWithBase3" xml:space="preserve">
    <value>无法继承接口“{0}”，因为对于某些类型参数，该接口与接口“{2}”继承的接口“{1}”相同。</value>
  </data>
  <data name="ERR_OfExpected" xml:space="preserve">
    <value>在指定泛型类型或方法的类型参数时需要 "Of"。</value>
  </data>
  <data name="ERR_ResumableLambdaInExpressionTree" xml:space="preserve">
    <value>无法将带 "Async" 或 "Iterator" 修饰符的 lambda 转换为表达式树。</value>
  </data>
  <data name="ERR_InvalidOverrideDueToReturn2" xml:space="preserve">
    <value>“{0}”无法重写“{1}”，因为它们的返回类型不同。</value>
  </data>
  <data name="ERR_BadGetAwaiterMethod1" xml:space="preserve">
    <value>“Await”要求类型“{0}”包含适当的 GetAwaiter 方法。</value>
  </data>
  <data name="ERR_TypeInferenceFailureAmbiguous1" xml:space="preserve">
    <value>无法从这些实参推断类型形参的数据类型，因为可能会存在多个类型。显式指定数据类型可更正此错误。</value>
  </data>
  <data name="ERR_TypeInferenceFailureAmbiguous2" xml:space="preserve">
    <value>无法从这些实参推断方法“{0}”中类型形参的数据类型，因为可能会存在多个类型。显式指定数据类型可更正此错误。</value>
  </data>
  <data name="ERR_TypeInferenceFailureAmbiguous3" xml:space="preserve">
    <value>无法从这些实参推断“{0}”中定义的扩展方法“{1}”中类型形参的数据类型，因为可能会存在多个类型。显式指定数据类型可更正此错误。</value>
  </data>
  <data name="ERR_TypeInferenceFailureNoExplicitAmbiguous3" xml:space="preserve">
    <value>无法从这些实参推断“{0}”中定义的扩展方法“{1}”中类型形参的数据类型，因为可能会存在多个类型。</value>
  </data>
  <data name="ERR_TypeInferenceFailureNoExplicitAmbiguous2" xml:space="preserve">
    <value>无法从这些实参推断方法“{0}”中类型形参的数据类型，因为可能会存在多个类型。</value>
  </data>
  <data name="ERR_TypeInferenceFailureNoExplicitAmbiguous1" xml:space="preserve">
    <value>无法从这些实参推断类型形参的数据类型，因为可能会存在多个类型。</value>
  </data>
  <data name="ERR_TryAndOnErrorDoNotMix" xml:space="preserve">
    <value>方法不能既包含 "Try" 语句，又包含 "On Error" 或 "Resume" 语句。</value>
  </data>
  <data name="ERR_IsNotOperatorGenericParam1" xml:space="preserve">
    <value>类型“{0}”是没有类约束的类型参数，因此类型“{0}”的“Isnot”操作数只能与“Nothing”比较。</value>
  </data>
  <data name="ERR_StartupCodeNotFound1" xml:space="preserve">
    <value>“{0}”中找不到“Sub Main”。</value>
  </data>
  <data name="ERR_AgnosticToMachineModule" xml:space="preserve">
    <value>不可知的程序集不能具有特定于处理器的模块“{0}”。</value>
  </data>
  <data name="WRN_ConstraintsFailedForInferredArgs2" xml:space="preserve">
    <value>为方法“{0}”推断的类型参数导致以下警告:{1}</value>
  </data>
  <data name="ERR_RecordCycle2" xml:space="preserve">
    <value>结构“{0}”不能包含自身的实例: {1}</value>
  </data>
  <data name="ERR_ReturnWithoutValue" xml:space="preserve">
    <value>Function、Get 或 Operator 中的 "Return" 语句必须返回值。</value>
  </data>
  <data name="WRN_XMLDocReturnsOnWriteOnlyProperty_Title" xml:space="preserve">
    <value>"WriteOnly" 属性中不允许出现 XML 注释标记 "returns"</value>
  </data>
  <data name="ERR_RequiredConstExpr" xml:space="preserve">
    <value>要求常量表达式。</value>
  </data>
  <data name="ERR_DuplicateResourceFileName1" xml:space="preserve">
    <value>每个链接的资源和模块都必须有唯一的文件名。此程序集中多次指定了文件名“{0}”。</value>
  </data>
  <data name="ERR_CantCombineInitializers" xml:space="preserve">
    <value>不能将对象初始值设定项与集合初始值设定项组合到同一个初始化过程中。</value>
  </data>
  <data name="ERR_InaccessibleSymbol2" xml:space="preserve">
    <value>“{0}”是“{1}”,因此它在此上下文中不可访问。</value>
  </data>
  <data name="ERR_StrictDisallowImplicitObject" xml:space="preserve">
    <value>Option Strict On 要求所有变量声明都有 "As" 子句。</value>
  </data>
  <data name="WRN_CannotFindStandardLibrary1_Title" xml:space="preserve">
    <value>找不到标准库</value>
  </data>
  <data name="ERR_IllegalCondTypeInIIF" xml:space="preserve">
    <value>二进制“If”表达式中的第一个操作数必须是可以为 null 的类型或引用类型。</value>
  </data>
  <data name="ERR_ConstraintCycle2" xml:space="preserve">
    <value>类型参数“{0}”不能约束为自身: {1}</value>
  </data>
  <data name="ERR_TypeConflict6" xml:space="preserve">
    <value>{0}“{1}”和 {2}“{3}”在 {4}“{5}”中冲突。</value>
  </data>
  <data name="ERR_BadEventFlags1" xml:space="preserve">
    <value>“{0}”在事件声明中无效。</value>
  </data>
  <data name="WRN_ProcTypeNotCLSCompliant1_Title" xml:space="preserve">
    <value>函数的返回类型不符合 CLS</value>
  </data>
  <data name="ERR_DllImportOnResumableMethod" xml:space="preserve">
    <value>"System.Runtime.InteropServices.DllImportAttribute" 不能应用于异步方法或迭代器方法。</value>
  </data>
  <data name="ERR_StrictDisallowsImplicitArgs" xml:space="preserve">
    <value>Option Strict On 要求所有方法参数都有 "As" 子句。</value>
  </data>
  <data name="ERR_StrictDisallowsImplicitProc" xml:space="preserve">
    <value>Option Strict On 要求所有函数、属性和运算符声明都有 "As" 子句。</value>
  </data>
  <data name="ERR_IsNestedIn2" xml:space="preserve">
    <value>
  “{0}”嵌套在“{1}”中。</value>
  </data>
  <data name="ERR_BadOverloadCandidates2" xml:space="preserve">
    <value>重载决策失败，原因是没有可访问的“{0}”可以进行调用:{1}</value>
  </data>
  <data name="ERR_ReferenceDirectiveOnlyAllowedInScripts" xml:space="preserve">
    <value>仅在脚本中允许 #R</value>
  </data>
  <data name="WRN_ObjectMath1_Title" xml:space="preserve">
    <value>为运算符使用的 Object 类型的操作数</value>
  </data>
  <data name="SyntaxTreeAlreadyPresent" xml:space="preserve">
    <value>语法树已存在</value>
  </data>
  <data name="AggregateSyntaxNotWithinSyntaxTree" xml:space="preserve">
    <value>AggregateSyntax 未在语法树内</value>
  </data>
  <data name="ERR_NoZeroCountArgumentInitCandidates1" xml:space="preserve">
    <value>无法在对象初始值设定项表达式中初始化属性“{0}”，因为所有可访问的重载都需要参数。</value>
  </data>
  <data name="ERR_InvalidOutputName" xml:space="preserve">
    <value>无效输出名: {0}</value>
  </data>
  <data name="ERR_ExpectedXmlWhiteSpace" xml:space="preserve">
    <value>缺少必需的空白。</value>
  </data>
  <data name="ERR_CantSpecifyTypeCharacterOnIIF" xml:space="preserve">
    <value>与“If”表达式一起使用的表达式不能包含类型字符。</value>
  </data>
  <data name="ERR_BadPdbData" xml:space="preserve">
    <value>读取“{0}”的调试信息时出错</value>
  </data>
  <data name="ERR_ExpectedSubFunction" xml:space="preserve">
    <value>应为“Sub”或“Function”。</value>
  </data>
  <data name="ERR_BinaryOperands3" xml:space="preserve">
    <value>没有为类型“{1}”和“{2}”定义运算符“{0}”。</value>
  </data>
  <data name="WRN_MissingAsClauseinVarDecl" xml:space="preserve">
    <value>变量声明没有 "As" 子句；假定为 Object 类型。</value>
  </data>
  <data name="ERR_OptionalsCantBeStructGenericParams" xml:space="preserve">
    <value>用作可选参数类型的泛型参数必须受类约束。</value>
  </data>
  <data name="ERR_ObsoleteLetSetNotNeeded" xml:space="preserve">
    <value>不再支持 "Let" 和 "Set" 赋值语句。</value>
  </data>
  <data name="ERR_TypeInItsInheritsClause1" xml:space="preserve">
    <value>类“{0}”不能在 Inherits 子句中引用自己。</value>
  </data>
  <data name="ERR_EndRegionNoRegion" xml:space="preserve">
    <value>"#End Region" 前面必须是匹配的 "#Region"。</value>
  </data>
  <data name="ERR_EndWhileNoWhile" xml:space="preserve">
    <value>“End While”前面必须是匹配的“While”。</value>
  </data>
  <data name="ERR_BadNullTypeInCCExpression" xml:space="preserve">
    <value>在条件编译表达式中不允许有可以为 null 的类型。</value>
  </data>
  <data name="WRN_CannotFindStandardLibrary1" xml:space="preserve">
    <value>未能找到标准库“{0}”。</value>
  </data>
  <data name="ERR_TooManyArgs" xml:space="preserve">
    <value>参数太多。</value>
  </data>
  <data name="ERR_ImplementsOnNew" xml:space="preserve">
    <value>“Sub New”无法实现接口成员。</value>
  </data>
  <data name="ERR_DuplicateDefaultProps1" xml:space="preserve">
    <value>“Default”只可应用于“{0}”中的一个属性名称。</value>
  </data>
  <data name="ERR_ClassInheritsBaseUnifiesWithInterfaces3" xml:space="preserve">
    <value>无法实现接口“{0}”，因为对于某些类型参数，它所继承的接口“{1}”可能与实现的接口“{2}”相同。</value>
  </data>
  <data name="WRN_AsyncSubCouldBeFunction" xml:space="preserve">
    <value>此处某些重载使用的是 Async Function 而不是 Async Sub。请考虑使用 Async Function 或将此 Async Sub 显式强制转换为所需类型。</value>
  </data>
  <data name="WRN_MutableStructureInUsing_Title" xml:space="preserve">
    <value>Using 语句声明的局部变量是只读的，它的类型是一种结构</value>
  </data>
  <data name="ERR_BadAttributeNonPublicContType2" xml:space="preserve">
    <value>类型“{0}”的容器“{1}”未声明为“Public”，因此不能用在特性中。</value>
  </data>
  <data name="ERR_TupleDuplicateElementName" xml:space="preserve">
    <value>元组元素名称必须是唯一的。</value>
  </data>
  <data name="WRN_BadUILang_Title" xml:space="preserve">
    <value>/preferreduilang 的语言名称无效</value>
  </data>
  <data name="ERR_FunctionResultCannotBeIndexed1" xml:space="preserve">
    <value>“{0}”没有任何参数，并且无法对它的返回类型进行索引。</value>
  </data>
  <data name="ERR_ComClassDuplicateGuids1" xml:space="preserve">
    <value>“{0}”上“Microsoft.VisualBasic.ComClassAttribute”的“InterfaceId”和“EventsId”参数的值不能相同。</value>
  </data>
  <data name="ERR_MissingNetModuleReference" xml:space="preserve">
    <value>缺少对“{0}”netmodule 的引用。</value>
  </data>
  <data name="ERR_NewIfNullOnGenericParam" xml:space="preserve">
    <value>不能在没有 "New" 约束的类型参数上使用 "New"。</value>
  </data>
  <data name="ERR_ReferenceComparison3" xml:space="preserve">
    <value>没有为类型“{1}”和“{2}”定义运算符“{0}”。请使用“Is”运算符比较两个引用的类型。</value>
  </data>
  <data name="FEATURE_LineContinuation" xml:space="preserve">
    <value>隐式行继续符</value>
  </data>
  <data name="ERR_NoUniqueConstructorOnBase2" xml:space="preserve">
    <value>类“{0}”必须声明一个“Sub New”，因它的基类“{1}”有多个不使用参数就可以调用的可访问“Sub New”。</value>
  </data>
  <data name="WRN_ImplicitConversionCopyBack" xml:space="preserve">
    <value>将“ByRef”形参“{0}”的值复制回匹配实参时，发生从“{1}”到“{2}”的隐式转换。</value>
  </data>
  <data name="WRN_DefAsgUseNullRefByRefStr" xml:space="preserve">
    <value>变量“{0}”在赋值前按引用传递。可能会在运行时导致 null 引用异常。请确保结构或所有引用成员在使用前已经初始化</value>
  </data>
  <data name="ERR_ObsoleteArgumentsNeedParens" xml:space="preserve">
    <value>方法参数必须括在括号中。</value>
  </data>
  <data name="WRN_IndirectRefToLinkedAssembly2_Title" xml:space="preserve">
    <value>已创建对嵌入的互操作程序集的引用，因为间接引用了该程序集</value>
  </data>
  <data name="WRN_LiftControlVariableQuery_Title" xml:space="preserve">
    <value>在查询表达式中使用迭代变量可能会产生意外的结果</value>
  </data>
  <data name="ERR_CannotUseGenericTypeAcrossAssemblyBoundaries" xml:space="preserve">
    <value>无法跨程序集边界使用类型“{0}”，因为它有身为嵌入的互操作类型的泛型类型参数。</value>
  </data>
  <data name="ERR_CannotLinkClassWithNoPIA1" xml:space="preserve">
    <value>当类“{0}”的程序集配置为嵌入互操作类型时，不允许使用对该类的引用。</value>
  </data>
  <data name="ERR_VarianceInPropertyDisallowed1" xml:space="preserve">
    <value>在此上下文中，类型“{0}”不能用作属性类型，因为“{0}”是“In”类型参数，且该属性未标记为 WriteOnly。</value>
  </data>
  <data name="WRN_DefaultnessShadowed4_Title" xml:space="preserve">
    <value>默认属性与基类型中的默认属性发生冲突</value>
  </data>
  <data name="ERR_ExitTryNotWithinTry" xml:space="preserve">
    <value>"Exit Try" 只能出现在 "Try" 语句内。</value>
  </data>
  <data name="ERR_ExitPropNot" xml:space="preserve">
    <value>“Exit Property”在函数或 Sub 中无效。</value>
  </data>
  <data name="ERR_PermissionSetAttributeInvalidFile" xml:space="preserve">
    <value>无法解析为 PermissionSet 属性的命名参数“{1}”指定的文件路径“{0}”。</value>
  </data>
  <data name="WRN_RefCultureMismatch" xml:space="preserve">
    <value>引用程序集“{0}”具有不同区域性设置“{1}”。</value>
  </data>
  <data name="WRN_XMLCannotWriteToXMLDocFile2" xml:space="preserve">
    <value>无法创建 XML 文档文件“{0}”: {1}</value>
  </data>
  <data name="ERR_NextForMismatch1" xml:space="preserve">
    <value>Next 控制变量与 For 循环控制变量“{0}”不匹配。</value>
  </data>
  <data name="ERR_ForLoopType1" xml:space="preserve">
    <value>“For”循环控制变量的类型不能是“{0}”，因为该类型不支持所需的运算符。</value>
  </data>
  <data name="ERR_DuplicateProcDefWithDifferentTupleNames2" xml:space="preserve">
    <value>“{0}”具有多个带不同元组元素名称却有相同签名的定义，包括“{1}”。</value>
  </data>
  <data name="FEATURE_SubLambdas" xml:space="preserve">
    <value>“Sub”lambda 表达式</value>
  </data>
  <data name="WRN_BadSwitch_Title" xml:space="preserve">
    <value>无法识别的命令行选项</value>
  </data>
  <data name="Trees0" xml:space="preserve">
    <value>树({0})</value>
  </data>
  <data name="ERR_VarianceTypeDisallowedForGeneric4" xml:space="preserve">
    <value>类型“{0}”不能在此上下文中用于“{3}”中的“{2}”，因为此上下文和“{0}”的定义均嵌套在接口“{1}”内，而“{1}”含有“In”或“Out”类型参数。考虑将“{0}”的定义移出“{1}”。</value>
  </data>
  <data name="ERR_UnableToOpenResourceFile1" xml:space="preserve">
    <value>无法打开资源文件“{0}”: {1}</value>
  </data>
  <data name="WRN_SharedMemberThroughInstance" xml:space="preserve">
    <value>通过实例访问共享成员、常量成员、枚举成员或嵌套类型；将不计算限定表达式。</value>
  </data>
  <data name="WRN_IfNoTypeObjectAssumed" xml:space="preserve">
    <value>无法推断通用类型；假定为“Object”。</value>
  </data>
  <data name="ERR_ReadOnlyProperty1" xml:space="preserve">
    <value>“ReadOnly”属性“{0}”不能作为赋值目标。</value>
  </data>
  <data name="ThereAreNoPointerTypesInVB" xml:space="preserve">
    <value>VB 中没有任何指针属性。</value>
  </data>
  <data name="ERR_ArgumentSyntax" xml:space="preserve">
    <value>应为逗号、")" 或有效的表达式继续符。</value>
  </data>
  <data name="ERR_DllImportOnNonEmptySubOrFunction" xml:space="preserve">
    <value>"System.Runtime.InteropServices.DllImportAttribute" 不能应用于带有非空体的 Sub、Function 或 Operator。</value>
  </data>
  <data name="WRN_XMLDocStartTagWithNoEndTag_Title" xml:space="preserve">
    <value>XML 文档分析错误: 开始标记没有匹配的结束标记</value>
  </data>
  <data name="ERR_PropertyOrFieldNotDefined1" xml:space="preserve">
    <value>找不到字段或属性“{0}”。</value>
  </data>
  <data name="WRN_SelectCaseInvalidRange" xml:space="preserve">
    <value>为 "Case" 语句指定的范围无效。请确保下限小于或等于上限。</value>
  </data>
  <data name="ERR_RedimNoSizes" xml:space="preserve">
    <value>"ReDim" 语句需要一个带括号的列表，该列表列出数组每个维度的新界限。</value>
  </data>
  <data name="ERR_BadNonTrailingNamedArgument" xml:space="preserve">
    <value>Named argument '{0}' is used out-of-position but is followed by an unnamed argument</value>
  </data>
  <data name="ERR_InvalidAttributeUsageOnAccessor" xml:space="preserve">
    <value>属性“{0}”不能应用于“{2}”的“{1}”，因为该属性在此声明类型中无效。</value>
  </data>
  <data name="ERR_CannotLiftRestrictedTypeResumable1" xml:space="preserve">
    <value>不能在异步方法或迭代器方法中声明受限类型“{0}”的变量。</value>
  </data>
  <data name="WRN_PrefixAndXmlnsLocalName" xml:space="preserve">
    <value>建议不要将特性命名为 xmlns。是否有意编写“xmlns:{0}”以定义名为“{0}”的前缀?</value>
  </data>
  <data name="ElementsCannotBeNull" xml:space="preserve">
    <value>元素不能为 Null。</value>
  </data>
  <data name="ERR_ExportedTypeConflictsWithDeclaration" xml:space="preserve">
    <value>从模块“{1}”导出的类型“{0}”与此程序集主模块中声明的类型冲突。</value>
  </data>
  <data name="ERR_InvalidVersionFormat" xml:space="preserve">
    <value>指定的版本字符串不符合所需格式 - major[.minor[.build|*[.revision|*]]]</value>
  </data>
  <data name="ERR_AddRemoveParamNotEventType" xml:space="preserve">
    <value>“AddHandler”和“RemoveHandler”方法参数必须与包含事件具有相同的委托类型。</value>
  </data>
  <data name="WRN_AmbiguousCastConversion2" xml:space="preserve">
    <value>从“{0}”到“{1}”的转换可能不明确。</value>
  </data>
  <data name="ERR_EventTypeNotDelegate" xml:space="preserve">
    <value>用 "As" 子句声明的事件必须有委托类型。</value>
  </data>
  <data name="ERR_ConversionToDerivedType" xml:space="preserve">
    <value>转换运算符不能从某一类型转换为它的派生类型。</value>
  </data>
  <data name="ERR_ExpectedIdentifier" xml:space="preserve">
    <value>应为标识符。</value>
  </data>
  <data name="ERR_QueryStrictDisallowImplicitObject" xml:space="preserve">
    <value>无法推断范围变量的类型，且 Option Strict on 不允许后期绑定。请使用“As”子句来指定类型。</value>
  </data>
  <data name="WRN_RootNamespaceNotCLSCompliant2_Title" xml:space="preserve">
    <value>根命名空间的一部分不符合 CLS</value>
  </data>
  <data name="ERR_FriendAssemblyBadAccessOverride2" xml:space="preserve">
    <value>成员“{0}”无法重写另一个程序集/项目中定义的成员“{1}”，因为访问修饰符“Protected Friend”扩展了可访问性。请改用“Protected”。</value>
  </data>
  <data name="ERR_ParamArrayMustBeByVal" xml:space="preserve">
    <value>ParamArray 参数必须声明为 "ByVal"。</value>
  </data>
  <data name="WRN_RefCultureMismatch_Title" xml:space="preserve">
    <value>引用的程序集拥有不同的区域性设置</value>
  </data>
  <data name="ERR_InvalidEndAddHandler" xml:space="preserve">
    <value>“End AddHandler”前面必须是匹配的“AddHandler”声明。</value>
  </data>
  <data name="ERR_TypeArgsUnexpected" xml:space="preserve">
    <value>不应为类型参数。</value>
  </data>
  <data name="ERR_CannotLiftByRefParamQuery1" xml:space="preserve">
    <value>不能在查询表达式中使用“ByRef”参数“{0}”。</value>
  </data>
  <data name="ERR_InvalidLambdaModifier" xml:space="preserve">
    <value>仅“Async”或“Iterator”修饰符在 lambda 上有效。</value>
  </data>
  <data name="ERR_UndefinedXmlPrefix" xml:space="preserve">
    <value>未定义 XML 命名空间前缀“{0}”。</value>
  </data>
  <data name="ERR_TypeForwardedToMultipleAssemblies" xml:space="preserve">
    <value>程序集“{1}”中的模块“{0}”将类型“{2}”转发到多个程序集: “{3}”和“{4}”。</value>
  </data>
  <data name="WRN_XMLDocReturnsOnADeclareSub" xml:space="preserve">
    <value>declare sub 语言元素中不允许有 XML 注释标记 "returns"。</value>
  </data>
  <data name="ERR_SecurityAttributeInvalidActionTypeOrMethod" xml:space="preserve">
    <value>SecurityAction 值“{0}”对应用于类型或方法的安全属性无效。</value>
  </data>
  <data name="ERR_PartialMethodMustBeEmpty" xml:space="preserve">
    <value>分部方法必须具有空方法体。</value>
  </data>
  <data name="WRN_MissingAsClauseinOperator_Title" xml:space="preserve">
    <value>运算符没有 "As" 子句</value>
  </data>
  <data name="WRN_RelDelegatePassedToRemoveHandler" xml:space="preserve">
    <value>"AddressOf" 表达式在此上下文中不起作用，因为 "AddressOf" 的方法参数需要到该事件的委托类型的宽松转换。将 "AddressOf' 表达式赋给变量，并使用变量将该方法作为处理程序进行添加或移除。</value>
  </data>
  <data name="CantReferenceCompilationFromTypes" xml:space="preserve">
    <value>无法从 {1} 编译引用类型为“{0}”的编译。</value>
  </data>
  <data name="ERR_BadInterfaceDelegateSpecifier1" xml:space="preserve">
    <value>接口中的委托不能声明为“{0}”。</value>
  </data>
  <data name="ERR_LocalTypeNameClash2" xml:space="preserve">
    <value>嵌入来自程序集“{1}”中的互操作类型“{0}”会导致当前程序集中发生名称冲突。请考虑禁用互操作类型的嵌入。</value>
  </data>
  <data name="WRN_XMLDocNotFirstOnLine_Title" xml:space="preserve">
    <value>XML 注释必须是一行上的第一条语句</value>
  </data>
  <data name="ERR_StandaloneAttribute" xml:space="preserve">
    <value>特性说明符不是一个完整的语句。请使用行继续符将该特性应用于下列语句。</value>
  </data>
  <data name="ERR_SignButNoPrivateKey" xml:space="preserve">
    <value>密钥文件“{0}”缺少进行签名所需的私钥。</value>
  </data>
  <data name="ERR_VarianceConversionFailedOut6" xml:space="preserve">
    <value>“{4}”不能转换为“{5}”，因为根据“{3}”中“Out”泛型形参“{2}”的需要，“{0}”不是从“{1}”派生的。</value>
  </data>
  <data name="WRN_AmbiguousCastConversion2_Title" xml:space="preserve">
    <value>转换可能不明确</value>
  </data>
  <data name="ERR_WithEventsRequiresClass" xml:space="preserve">
    <value>"WithEvents" 变量必须有 "As" 子句。</value>
  </data>
  <data name="WRN_UseOfObsoleteSymbol2_Title" xml:space="preserve">
    <value>类型或成员已过时</value>
  </data>
  <data name="ERR_MetaDataIsNotAssembly" xml:space="preserve">
    <value>“{0}”是一个模块，不能作为程序集引用。</value>
  </data>
  <data name="ERR_EndStructureNoStructure" xml:space="preserve">
    <value>"End Structure" 前面必须是匹配的 "Structure"。</value>
  </data>
  <data name="WRN_DefAsgNoRetValFuncVal1_Title" xml:space="preserve">
    <value>函数没有在所有代码路径上返回值</value>
  </data>
  <data name="ERR_ExpectedDotAfterGlobalNameSpace" xml:space="preserve">
    <value>“Global”的后面必须跟有“.”和标识符。</value>
  </data>
  <data name="ERR_ArgumentRequired" xml:space="preserve">
    <value>选项“{0}”需要“{1}”</value>
  </data>
  <data name="ERR_ExpectedXmlName" xml:space="preserve">
    <value>应为 XML 名称。</value>
  </data>
  <data name="ERR_IllegalCharConstant" xml:space="preserve">
    <value>字符常量必须正好包含一个字符。</value>
  </data>
  <data name="ERR_AddressOfNotCreatableDelegate1" xml:space="preserve">
    <value>“AddressOf”表达式无法转换为“{0}”，因为类型“{0}”已声明为“MustInherit”，无法创建。</value>
  </data>
  <data name="ERR_CryptoHashFailed" xml:space="preserve">
    <value>创建哈希时加密失败。</value>
  </data>
  <data name="FEATURE_YearFirstDateLiterals" xml:space="preserve">
    <value>年份在最前面的日期文本</value>
  </data>
  <data name="ERR_BadLocalDimFlags1" xml:space="preserve">
    <value>“{0}”在局部变量声明中无效。</value>
  </data>
  <data name="ERR_BadLocalConstFlags1" xml:space="preserve">
    <value>“{0}”在局部常量声明中无效。</value>
  </data>
  <data name="ERR_CustomEventRequiresAs" xml:space="preserve">
    <value>“Custom”修饰符在未用显式委托类型声明的事件上无效。</value>
  </data>
  <data name="ERR_BadYieldInTryHandler" xml:space="preserve">
    <value>不能在“Catch”语句或“Finally”语句内使用“Yield”。</value>
  </data>
  <data name="WRN_RelDelegatePassedToRemoveHandler_Title" xml:space="preserve">
    <value>"AddressOf" 表达式在此上下文中不起作用，原因是 "AddressOf" 的方法参数需要到该事件的委托类型的宽松转换</value>
  </data>
  <data name="WRN_XMLDocParamTagWithoutName_Title" xml:space="preserve">
    <value>XML 注释参数必须具有 "name" 属性</value>
  </data>
  <data name="ERR_MyBaseAbstractCall1" xml:space="preserve">
    <value>“MyBase”不能用和方法“{0}”一起使用，因为它被声明为“MustOverride”。</value>
  </data>
  <data name="ERR_LbExpectedEndIf" xml:space="preserve">
    <value>"#If" 块必须以匹配的 "#End If" 结束。</value>
  </data>
  <data name="ERR_InvInsideEndsInterface" xml:space="preserve">
    <value>语句不能出现在接口体内。假定为接口末尾。</value>
  </data>
  <data name="ERR_NestedBase2" xml:space="preserve">
    <value>{0}“{1}”不能从嵌套在它里面的类型继承。</value>
  </data>
  <data name="ERR_ComClassAndReservedAttribute1" xml:space="preserve">
    <value>“Microsoft.VisualBasic.ComClassAttribute”和“{0}”不能同时应用于同一个类。</value>
  </data>
  <data name="WRN_XMLDocWithoutLanguageElement" xml:space="preserve">
    <value>XML 文档注释必须位于成员声明或类型声明之前。</value>
  </data>
  <data name="ERR_SubRequiresParenthesesBang" xml:space="preserve">
    <value>此单行语句 lambda 必须括在括号中。例如: (Sub() &lt;语句&gt;)!key</value>
  </data>
  <data name="ERR_ParameterNotValidForType" xml:space="preserve">
    <value>参数对于指定非托管类型无效。</value>
  </data>
  <data name="ERR_FieldHasMultipleDistinctConstantValues" xml:space="preserve">
    <value>字段具有多个不同的常量值。</value>
  </data>
  <data name="IDS_LogoLine1" xml:space="preserve">
    <value>{0} 版本 {1}</value>
  </data>
  <data name="IDS_LogoLine2" xml:space="preserve">
    <value>版权所有(C) Microsoft Corporation。保留所有权利。</value>
  </data>
  <data name="ERR_NoTypeArgumentCountOverloadCand1" xml:space="preserve">
    <value>重载决策失败，因为没有可访问的“{0}”接受此数量的类型参数。</value>
  </data>
  <data name="ERR_SecurityAttributeInvalidTarget" xml:space="preserve">
    <value>安全特性“{0}”对此声明类型无效。安全特性仅对程序集、类型和方法声明有效。</value>
  </data>
  <data name="ERR_AddParamWrongForWinRT" xml:space="preserve">
    <value>“AddHandler”方法的参数的类型必须与事件的类型相同。</value>
  </data>
  <data name="ERR_EncReferenceToAddedMember" xml:space="preserve">
    <value>在当前调试会话期间添加的成员“{0}”只能从其声明的程序集“{1}”中访问。</value>
  </data>
  <data name="ERR_PIAHasNoAssemblyGuid1" xml:space="preserve">
    <value>无法嵌入来自程序集“{0}”的互操作类型，因为它缺少“{1}”特性。</value>
  </data>
  <data name="WRN_NamespaceCaseMismatch3" xml:space="preserve">
    <value>命名空间名“{0}”的大小写与“{2}”中命名空间名“{1}”的大小写不匹配。</value>
  </data>
  <data name="WrongNumberOfTypeArguments" xml:space="preserve">
    <value>类型参数的数目不正确</value>
  </data>
  <data name="HDN_UnusedImportStatement" xml:space="preserve">
    <value>未使用导入语句。</value>
  </data>
  <data name="ERR_InitializerExpected" xml:space="preserve">
    <value>应为初始值设定项。</value>
  </data>
  <data name="WRN_DefAsgNoRetValWinRtEventVal1" xml:space="preserve">
    <value>Windows 运行时事件“{0}”的 AddHandler 不会在所有代码路径上都返回值。是否缺少“Return”语句?</value>
  </data>
  <data name="HDN_UnusedImportStatement_Title" xml:space="preserve">
    <value>未使用 import 语句</value>
  </data>
  <data name="ERR_TypeOrMemberNotGeneric2" xml:space="preserve">
    <value>“{1}”中定义的扩展方法“{0}”不是泛型方法(或没有可用的类型形参)，因此无法拥有类型实参。</value>
  </data>
  <data name="ERR_TypeOrMemberNotGeneric1" xml:space="preserve">
    <value>“{0}”没有类型形参，因此不能有类型实参。</value>
  </data>
  <data name="ERR_NoResponseFile" xml:space="preserve">
    <value>无法打开响应文件“{0}”</value>
  </data>
  <data name="ERR_FriendRefSigningMismatch" xml:space="preserve">
    <value>友元访问权限由“{0}”授予，但是输出程序集的强名称签名状态与授予程序集的强名称签名状态不匹配。</value>
  </data>
  <data name="ERR_BadNamespaceName1" xml:space="preserve">
    <value>“{0}”不是有效名称，不能用作根命名空间名称。</value>
  </data>
  <data name="ERR_ExpectedQualifiedNameInInit" xml:space="preserve">
    <value>正在对象初始值设定项中初始化的字段或属性的名称必须以 "."开头。</value>
  </data>
  <data name="ERR_ProtectedTypeOutsideClass" xml:space="preserve">
    <value>受保护的类型只能在类内部声明。</value>
  </data>
  <data name="FEATURE_PartialModules" xml:space="preserve">
    <value>部分模块</value>
  </data>
  <data name="WRN_MemberShadowsSynthMember6_Title" xml:space="preserve">
    <value>成员与为基类型中的属性或事件隐式声明的成员冲突</value>
  </data>
  <data name="ERR_InvInsideEndsEnum" xml:space="preserve">
    <value>语句不能出现在枚举体内。假定已到达枚举末尾。</value>
  </data>
  <data name="ERR_InvInsideEndsProc" xml:space="preserve">
    <value>语句不能出现在方法体内。假定为方法末尾。</value>
  </data>
  <data name="ERR_XmlEndCDataNotAllowedInContent" xml:space="preserve">
    <value>元素内容中不允许使用字符串“]]&gt;”。</value>
  </data>
  <data name="ERR_InterfaceMemberSyntax" xml:space="preserve">
    <value>接口成员必须是方法、属性、事件或类型定义。</value>
  </data>
  <data name="ERR_AmbiguousInImports2" xml:space="preserve">
    <value>“{0}”不明确，从命名空间或类型“{1}”导入。</value>
  </data>
  <data name="WRN_UnimplementedCommandLineSwitch" xml:space="preserve">
    <value>命令行开关“{0}”尚未实现，已忽略。</value>
  </data>
  <data name="ERR_ExpectedXmlEndPI" xml:space="preserve">
    <value>应为 XML 处理器指令的结束标记“?&gt;”。</value>
  </data>
  <data name="ERR_VarianceInParamDisallowedHere2" xml:space="preserve">
    <value>在此上下文中，类型“{0}”不能用于“{1}”，因为“{0}”是“In”类型参数。</value>
  </data>
  <data name="WRN_UseValueForXmlExpression3_Title" xml:space="preserve">
    <value>无法将 IEnumerable(Of XElement) 转换为字符串</value>
  </data>
  <data name="ERR_BadWithEventsFlags1" xml:space="preserve">
    <value>“{0}”在 WithEvents 声明中无效。</value>
  </data>
  <data name="ERR_InheritsTypeArgAccessMismatchOutside5" xml:space="preserve">
    <value>“{0}”将对类型“{3}”的访问扩展到程序集之外，因此无法从 {1}“{2}”继承。</value>
  </data>
  <data name="WRN_XMLDocMoreThanOneCommentBlock_Title" xml:space="preserve">
    <value>每个语言元素只能有一个 XML 注释块</value>
  </data>
  <data name="ERR_AddressOfNullableMethod" xml:space="preserve">
    <value>“System.Nullable(Of T)”的方法不能用作“AddressOf”运算符的操作数。</value>
  </data>
  <data name="WRN_RecursiveAddHandlerCall_Title" xml:space="preserve">
    <value>语句递归调用事件包含的 AddHandler</value>
  </data>
  <data name="WRN_ArrayInitTooManyTypesObjectAssumed" xml:space="preserve">
    <value>无法推断元素类型，因为可能存在多个类型；假定为 "Object"。</value>
  </data>
  <data name="ERR_TypeParamNameFunctionNameCollision" xml:space="preserve">
    <value>类型参数不能与其定义函数同名。</value>
  </data>
  <data name="ERR_LbNoMatchingIf" xml:space="preserve">
    <value>"#ElseIf"、"#Else" 或 "#End If" 前面必须是匹配的 "#If"。</value>
  </data>
  <data name="WRN_DelaySignButNoKey_Title" xml:space="preserve">
    <value>指定了延迟签名，这需要公钥，但是未指定任何公钥</value>
  </data>
  <data name="ERR_VBCoreNetModuleConflict" xml:space="preserve">
    <value>/vbruntime* 选项不能与 /target:module 选项组合。</value>
  </data>
  <data name="WRN_DuplicateCatch_Title" xml:space="preserve">
    <value>永远不会到达 "Catch" 块；异常类型已在上面同一个 Try 语句中处理</value>
  </data>
  <data name="ERR_CannotEmbedInterfaceWithGeneric" xml:space="preserve">
    <value>无法嵌入类型“{0}”，因为它有泛型参数。请考虑禁用互操作类型嵌入。</value>
  </data>
  <data name="SyntaxTreeIsNotASubmission" xml:space="preserve">
    <value>应从提交创建语法树。</value>
  </data>
  <data name="ERR_IdentNotMemberOfInterface4" xml:space="preserve">
    <value>“{0}”无法实现“{1}”，因为接口“{3}”上不存在匹配的 {2}。</value>
  </data>
  <data name="ERR_MethodBodyNotAtLineStart" xml:space="preserve">
    <value>方法体的第一条语句和方法声明不能位于同一行。</value>
  </data>
  <data name="WRN_EqualToLiteralNothing" xml:space="preserve">
    <value>此表达式的计算结果始终为 Nothing (由于来自等于运算符的 null 传播)。若要检查值是否为 null，请考虑使用 "Is Nothing"。</value>
  </data>
  <data name="WRN_MemberShadowsSynthMember6" xml:space="preserve">
    <value>{0}“{1}”与为基 {4}“{5}”中 {2}“{3}”隐式声明的成员冲突，应将它声明为“Shadows”。</value>
  </data>
  <data name="ERR_SetHasOnlyOneParam" xml:space="preserve">
    <value>"Set" 方法不能有一个以上的参数。</value>
  </data>
  <data name="ERR_HandlesInvalidOnGenericMethod" xml:space="preserve">
    <value>泛型方法不能使用“Handles”子句。</value>
  </data>
  <data name="ERR_NullableDisallowedForStructConstr1" xml:space="preserve">
    <value>“System.Nullable”不满足类型参数“{0}”的“Structure”约束。仅允许不可为 null 的“Structure”类型。</value>
  </data>
  <data name="ERR_AttributeOrder" xml:space="preserve">
    <value>XML 特性“{0}”必须出现在 XML 特性“{1}”之前。</value>
  </data>
  <data name="FEATURE_ImplementingReadonlyOrWriteonlyPropertyWithReadwrite" xml:space="preserve">
    <value>使用读写属性实现只读或只写属性</value>
  </data>
  <data name="ERR_TupleReservedElementNameAnyPosition" xml:space="preserve">
    <value>任何位置都不允许使用元组元素名称“{0}”。</value>
  </data>
  <data name="ERR_BadModuleFile1" xml:space="preserve">
    <value>无法加载模块文件“{0}”: {1}</value>
  </data>
  <data name="ERR_InvalidUseOfKeyword" xml:space="preserve">
    <value>关键字作为标识符无效。</value>
  </data>
  <data name="ERR_QueryNameNotDeclared" xml:space="preserve">
    <value>名称“{0}”未声明或不在当前作用域中。</value>
  </data>
  <data name="ERR_Overflow" xml:space="preserve">
    <value>溢出。</value>
  </data>
  <data name="WRN_ComClassInterfaceShadows5_Title" xml:space="preserve">
    <value>类上的 "Microsoft.VisualBasic.ComClassAttribute" 隐式声明与同名成员发生冲突的成员</value>
  </data>
  <data name="ERR_InvalidPreprocessorConstantType" xml:space="preserve">
    <value>不支持“{1}”类型的预处理器常数“{0}”，仅允许使用基元类型。</value>
  </data>
  <data name="ERR_TypeInferenceArrayRankMismatch1" xml:space="preserve">
    <value>无法推断“{0}”的数据类型，因为数组维数不匹配。</value>
  </data>
  <data name="WRN_XMLDocInsideMethod_Title" xml:space="preserve">
    <value>XML 注释不能在方法或属性内出现</value>
  </data>
  <data name="ERR_BadSourceCodeKind" xml:space="preserve">
    <value>提供的源代码类型不受支持或无效:“{0}”</value>
  </data>
  <data name="WRN_CLSMemberInNonCLSType3_Title" xml:space="preserve">
    <value>无法将成员标记为符合 CLS，原因是它的包含类型不符合 CLS</value>
  </data>
  <data name="WRN_AsyncSubCouldBeFunction_Title" xml:space="preserve">
    <value>此处的一些重载采用的是 Async Function，而不是 Async Sub</value>
  </data>
  <data name="ERR_UnaryParamMustBeContainingType1" xml:space="preserve">
    <value>此一元运算符的参数必须属于包含类型“{0}”。</value>
  </data>
  <data name="ERR_MultipleNewConstraints" xml:space="preserve">
    <value>"New" 约束不能为同一类型参数指定多次。</value>
  </data>
  <data name="ERR_ForwardedTypeConflictsWithExportedType" xml:space="preserve">
    <value>转发到程序集“{1}”的类型“{0}”与从模块“{3}”导出的类型“{2}”冲突。</value>
  </data>
  <data name="WRN_XMLDocReturnsOnADeclareSub_Title" xml:space="preserve">
    <value>"declare sub" 语言元素中不允许出现 XML 注释标记 "returns"</value>
  </data>
  <data name="ERR_BlockLocalShadowing1" xml:space="preserve">
    <value>变量“{0}”在封闭块中隐藏变量。</value>
  </data>
  <data name="ERR_BadTypeInCCExpression" xml:space="preserve">
    <value>在条件编译表达式中不允许有非内部的类型名。</value>
  </data>
  <data name="ERR_CircularInference1" xml:space="preserve">
    <value>无法从包含“{0}”的表达式中推断“{0}”的类型。</value>
  </data>
  <data name="ERR_ConstraintIsRestrictedType1" xml:space="preserve">
    <value>“{0}”不能用作类型约束。</value>
  </data>
  <data name="ERR_NoMostSpecificOverload2" xml:space="preserve">
    <value>重载决策失败，因为没有可访问的“{0}”最适合这些参数: {1}</value>
  </data>
  <data name="ERR_InvalidEndProperty" xml:space="preserve">
    <value>“End Property”前面必须是匹配的“Property”。</value>
  </data>
  <data name="ERR_EndDisallowedInDllProjects" xml:space="preserve">
    <value>在类库项目中不能使用 "End" 语句。</value>
  </data>
  <data name="WRN_OverlappingCatch_Title" xml:space="preserve">
    <value>永远不会到达 "Catch" 块；异常类型的基类型已在上面同一个 Try 语句中处理</value>
  </data>
  <data name="WRN_TypeInferenceAssumed3_Title" xml:space="preserve">
    <value>无法推断数据类型</value>
  </data>
  <data name="ERR_NegativeArraySize" xml:space="preserve">
    <value>数组维数的大小不能为负。</value>
  </data>
  <data name="ERR_ErrorCreatingWin32ResourceFile" xml:space="preserve">
    <value>创建 Win32 资源时出错: {0}</value>
  </data>
  <data name="ERR_LibAnycpu32bitPreferredConflict" xml:space="preserve">
    <value>/platform:anycpu32bitpreferred 只能与 /t:exe、/t:winexe 和 /t:appcontainerexe 一起使用。</value>
  </data>
  <data name="ERR_LambdaBindingMismatch1" xml:space="preserve">
    <value>嵌套函数与委托“{0}”的签名不相同。</value>
  </data>
  <data name="ERR_LambdaBindingMismatch2" xml:space="preserve">
    <value>嵌套 Sub 的签名与委托“{0}”不兼容。</value>
  </data>
  <data name="ERR_InvalidEndEvent" xml:space="preserve">
    <value>“End Event”前面必须是匹配的“Custom Event”。</value>
  </data>
  <data name="WRN_NoNonObsoleteConstructorOnBase4_Title" xml:space="preserve">
    <value>类应声明 "Sub New"，原因是它的基类中的构造函数被标记为已过时</value>
  </data>
  <data name="ERR_InitializerTooManyElements1" xml:space="preserve">
    <value>数组初始值设定项拥有的元素太多({0}个)。</value>
  </data>
  <data name="WRN_ComClassNoMembers1" xml:space="preserve">
    <value>为类“{0}”指定了“Microsoft.VisualBasic.ComClassAttribute”，但“{0}”没有可以向 COM 公开的公共成员；因此不生成 COM 接口。</value>
  </data>
  <data name="ERR_InvalidNameOfSubExpression" xml:space="preserve">
    <value>此子表达式不能在 NameOf 参数中使用。</value>
  </data>
  <data name="ERR_VariancePreventsSynthesizedEvents2" xml:space="preserve">
    <value>在“{0}”这样的含有“In”或“Out”类型参数的接口中，不允许带参数的事件定义。考虑使用不在“{0}”中定义的委托类型来声明事件。例如，“Event {1} As Action(Of ...)”。</value>
  </data>
  <data name="ERR_MetaDataIsNotModule" xml:space="preserve">
    <value>“{0}”是一个程序集，不能作为模块引用。</value>
  </data>
  <data name="ERR_InvalidEndGet" xml:space="preserve">
    <value>“End Get”前面必须是匹配的“Get”。</value>
  </data>
  <data name="ERR_InvalidEndSub" xml:space="preserve">
    <value>“End Sub”前面必须是匹配的“Sub”。</value>
  </data>
  <data name="ERR_InvalidEndSet" xml:space="preserve">
    <value>“End Set”前面必须是匹配的“Set”。</value>
  </data>
  <data name="ERR_CannotEmbedWithoutPdb" xml:space="preserve">
    <value>/embed switch is only supported when emitting a PDB.</value>
  </data>
  <data name="WRN_VarianceDeclarationAmbiguous3" xml:space="preserve">
    <value>“{2}”中的“In”和“Out”参数导致接口“{0}”与另一个已实现的接口“{1}”一起使用时目的不明确。</value>
  </data>
  <data name="ERR_OverloadWithReturnType2" xml:space="preserve">
    <value>“{0}”和“{1}”的差异仅在于返回类型，因此它们无法重载对方。</value>
  </data>
  <data name="FEATURE_CObjInAttributeArguments" xml:space="preserve">
    <value>属性参数中的 CObj</value>
  </data>
  <data name="ERR_VarianceConversionFailedTryIn4" xml:space="preserve">
    <value>“{0}”不能转换为“{1}”。考虑在“{3}”的定义中将“{2}”改为 In 类型参数“In {2}”。</value>
  </data>
  <data name="ERR_UnreferencedAssembly3" xml:space="preserve">
    <value>需要对程序集“{0}”(包含类型“{1}”)的引用。请在项目中添加一个。</value>
  </data>
  <data name="ERR_StructCantUseVarSpecifier1" xml:space="preserve">
    <value>结构中的成员不能声明为“{0}”。</value>
  </data>
  <data name="ERR_TupleElementNamesAttributeMissing" xml:space="preserve">
    <value>由于找不到编译器必需的类型“{0}”，因此无法使用元组来定义类或成员。是否缺少引用?</value>
  </data>
  <data name="ERR_PublicKeyFileFailure" xml:space="preserve">
    <value>从文件“{0}”中提取公钥时出错: {1}</value>
  </data>
  <data name="WRN_ArrayInitNoTypeObjectAssumed" xml:space="preserve">
    <value>无法推断元素类型；假定为 "Object"。</value>
  </data>
  <data name="ERR_ParameterizedPropertyInAggrInit1" xml:space="preserve">
    <value>无法在对象初始值设定项表达式中初始化属性“{0}”，因为它需要参数。</value>
  </data>
  <data name="FEATURE_GlobalNamespace" xml:space="preserve">
    <value>声明全局命名空间</value>
  </data>
  <data name="ERR_DuplicatePropertyGet" xml:space="preserve">
    <value>已声明 "Get"。</value>
  </data>
  <data name="ERR_DuplicatePropertySet" xml:space="preserve">
    <value>已声明 "Set"。</value>
  </data>
  <data name="FEATURE_Tuples" xml:space="preserve">
    <value>元组</value>
  </data>
  <data name="ERR_ConflictingManifestSwitches" xml:space="preserve">
    <value>嵌入 Win32 清单时出错: 选项 /win32manifest 与 /nowin32manifest 冲突。</value>
  </data>
  <data name="ERR_VarianceInParamDisallowed1" xml:space="preserve">
    <value>类型“{0}”不能用于此上下文，因为“{0}”是“In”类型参数。</value>
  </data>
  <data name="WRN_QueryMissingAsClauseinVarDecl_Title" xml:space="preserve">
    <value>范围变量被假设为 Object 类型，原因是无法推断它的类型</value>
  </data>
  <data name="ERR_SharedOnProcThatImpl" xml:space="preserve">
    <value>实现接口成员的方法或事件不能声明为 "Shared"。</value>
  </data>
  <data name="WRN_GenericConstraintNotCLSCompliant1_Title" xml:space="preserve">
    <value>泛型参数约束类型不符合 CLS</value>
  </data>
  <data name="WRN_AnalyzerCannotBeCreated" xml:space="preserve">
    <value>无法从 {1} 创建分析器 {0} 的实例: {2}。</value>
  </data>
  <data name="ERR_OnlyOnePartialMethodAllowed2" xml:space="preserve">
    <value>方法“{0}”不能声明为“Partial”，因为只有一个方法“{1}”可以标记为“Partial”。</value>
  </data>
  <data name="WRN_DefAsgNoRetValPropVal1" xml:space="preserve">
    <value>属性“{0}”不会在所有代码路径上都返回值。是否缺少“Return”语句?</value>
  </data>
  <data name="ERR_ExplicitTupleElementNamesAttribute" xml:space="preserve">
    <value>无法显式引用 "System.Runtime.CompilerServices.TupleElementNamesAttribute"。请使用元组语法指定元组名称。</value>
  </data>
  <data name="WRN_DefAsgNoRetValPropRef1" xml:space="preserve">
    <value>属性“{0}”不会在所有代码路径上都返回值。当使用结果时，可能会在运行时发生 null 引用异常。</value>
  </data>
  <data name="ERR_ExpectedDotAfterMyClass" xml:space="preserve">
    <value>“MyClass”的后面必须跟有“.”和标识符。</value>
  </data>
  <data name="ERR_EventDelegatesCantBeFunctions" xml:space="preserve">
    <value>事件不能用具有返回类型的委托类型声明。</value>
  </data>
  <data name="ERR_RuntimeMemberNotFound2" xml:space="preserve">
    <value>类“{1}”中找不到成员“{0}”。此情况通常是由于不匹配的“Microsoft.VisualBasic.dll”造成的。</value>
  </data>
  <data name="ERR_PartialMethodsMustBeSub1" xml:space="preserve">
    <value>“{0}”不能声明为“Partial”，因为分部方法必须为 Subs。</value>
  </data>
  <data name="ERR_ConversionToObject" xml:space="preserve">
    <value>转换运算符不能转换为 Object。</value>
  </data>
  <data name="ERR_OptionStmtWrongOrder" xml:space="preserve">
    <value>"Option" 语句必须位于任何声明或 "Imports" 语句之前。</value>
  </data>
  <data name="ERR_OnlyNullLowerBound" xml:space="preserve">
    <value>数组的下限只能是“0”。</value>
  </data>
  <data name="ERR_CannotInferNullableForVariable1" xml:space="preserve">
    <value>对于变量“{0}”不能推断可以为 null 的类型。</value>
  </data>
  <data name="ERR_ConditionalCompilationConstantNotValid" xml:space="preserve">
    <value>条件编译常数“{1}”无效: {0}</value>
  </data>
  <data name="ERR_OnlyPrivatePartialMethods1" xml:space="preserve">
    <value>必须将分部方法声明为“Private”，而不是“{0}”。</value>
  </data>
  <data name="ERR_ConversionToSameType" xml:space="preserve">
    <value>转换运算符不能从某一类型转换为相同的类型。</value>
  </data>
  <data name="ERR_ObsoleteOnGotoGosub" xml:space="preserve">
    <value>不再支持 "On GoTo" 和 "On GoSub" 语句。</value>
  </data>
  <data name="ERR_SourceLinkRequiresPdb" xml:space="preserve">
    <value>只在发出 PDB 时才支持 /sourcelink 开关。</value>
  </data>
  <data name="ERR_VoidArrayDisallowed" xml:space="preserve">
    <value>此表达式中不允许使用 "System.Void" 类型的数组。</value>
  </data>
  <data name="ERR_SecurityAttributeMissingAction" xml:space="preserve">
    <value>安全属性的第一个参数必须是有效的 SecurityAction。</value>
  </data>
  <data name="ERR_PartialMethodsMustNotBeAsync1" xml:space="preserve">
    <value>“{0}”不能声明为“Partial”，因为它具有“Async”修饰符。</value>
  </data>
  <data name="WRN_LambdaNoTypeObjectAssumed_Title" xml:space="preserve">
    <value>无法推断返回类型</value>
  </data>
  <data name="ERR_ArrayRankLimit" xml:space="preserve">
    <value>数组超过了 32 维数限制。</value>
  </data>
  <data name="IDS_FunctionReturnType" xml:space="preserve">
    <value>函数返回类型</value>
  </data>
  <data name="ERR_ValueAndClassTypeConstrCombined" xml:space="preserve">
    <value>"Structure" 约束不能与特定的类类型约束组合。</value>
  </data>
  <data name="ERR_AmbiguousImplements3" xml:space="preserve">
    <value>无法实现与此签名匹配的成员“{0}.{1}”，因为接口“{2}”包含多个具有此相同名称和签名的成员:
  '{3}'
  '{4}'</value>
  </data>
  <data name="WRN_TypeNotCLSCompliant1" xml:space="preserve">
    <value>类型“{0}”不符合 CLS。</value>
  </data>
  <data name="ERR_AttributeOnLambdaReturnType" xml:space="preserve">
    <value>特性不能应用于 lambda 表达式的返回类型。</value>
  </data>
  <data name="ERR_ConversionFromInterfaceType" xml:space="preserve">
    <value>转换运算符不能从接口类型转换。</value>
  </data>
  <data name="ERR_InvalidEndOperator" xml:space="preserve">
    <value>“End Operator”前面必须是匹配的“Operator”。</value>
  </data>
  <data name="ERR_DuplicateWriteabilityCategoryUsed" xml:space="preserve">
    <value>"ReadOnly" 不能与 "WriteOnly" 组合。</value>
  </data>
  <data name="ERR_ConstructorNotFound1" xml:space="preserve">
    <value>类型“{0}”没有构造函数。</value>
  </data>
  <data name="ERR_CharToIntegralTypeMismatch1" xml:space="preserve">
    <value>“Char”值不能转换为“{0}”。请使用“Microsoft.VisualBasic.AscW”将字符解释为 Unicode 值，或者使用“Microsoft.VisualBasic.Val”将字符解释为数字。</value>
  </data>
  <data name="ERR_AddressOfOperandNotMethod" xml:space="preserve">
    <value>“AddressOf”操作数必须是某个方法的名称(不带圆括号)。</value>
  </data>
  <data name="ERR_XmlPrefixNotExpression" xml:space="preserve">
    <value>“{0}”是 XML 前缀，不能用作表达式。请使用 GetXmlNamespace 运算符创建命名空间对象。</value>
  </data>
  <data name="ERR_UnableToCreateTempFile" xml:space="preserve">
    <value>无法创建临时文件: {0}</value>
  </data>
  <data name="ERR_EndSyncLockNoSyncLock" xml:space="preserve">
    <value>“End SyncLock”前面必须是匹配的“SyncLock”。</value>
  </data>
  <data name="ERR_TupleInferredNamesNotAvailable" xml:space="preserve">
    <value>推断出元组元素名称“{0}”。请使用语言版本 {1} 或更高版本按推断名称访问元素。</value>
  </data>
  <data name="ERR_ExpectedIdentifierOrGroup" xml:space="preserve">
    <value>应为“Group”或标识符。</value>
  </data>
  <data name="WRN_UseOfObsoleteSymbolNoMessage1_Title" xml:space="preserve">
    <value>类型或成员已过时</value>
  </data>
  <data name="ERR_EndNamespaceNoNamespace" xml:space="preserve">
    <value>"End Namespace" 前面必须是匹配的 "Namespace"。</value>
  </data>
  <data name="WRN_FieldNotCLSCompliant1" xml:space="preserve">
    <value>成员“{0}”的类型不符合 CLS。</value>
  </data>
  <data name="WRN_ComClassInterfaceShadows5" xml:space="preserve">
    <value>类“{0}”上的“Microsoft.VisualBasic.ComClassAttribute”隐式声明的 {1}“{2}”与 {3}“{4}”中的同名成员冲突。如果要隐藏基 {4} 上的名称，请使用“Microsoft.VisualBasic.ComClassAttribute(InterfaceShadows:=True)”。</value>
  </data>
  <data name="ERR_VarianceInReturnDisallowed1" xml:space="preserve">
    <value>类型“{0}”不能用作返回类型，因为“{0}”是“In”类型参数。</value>
  </data>
  <data name="ERR_ReservedAssemblyName" xml:space="preserve">
    <value>程序集名“{0}”保留名称，不能在交互会话中用作引用</value>
  </data>
  <data name="ERR_ExpectedProcedure" xml:space="preserve">
    <value>表达式不是方法。</value>
  </data>
  <data name="WRN_UnusedLocal_Title" xml:space="preserve">
    <value>未使用的本地变量</value>
  </data>
  <data name="ERR_NoAddMethod1" xml:space="preserve">
    <value>无法用集合初始值设定项初始化类型“{0}”，因为该类型没有可访问的“Add”方法。</value>
  </data>
  <data name="ERR_StrictDisallowImplicitObjectLambda" xml:space="preserve">
    <value>Option Strict On 要求使用 "As" 子句来声明其类型无法推断的每个 lambda 表达式参数。</value>
  </data>
  <data name="ERR_ExpectedEndOfExpression" xml:space="preserve">
    <value>应为表达式结尾。</value>
  </data>
  <data name="WRN_UnusedLocalConst_Title" xml:space="preserve">
    <value>未使用的局部常量</value>
  </data>
  <data name="ERR_MoreThanOneValidMainWasFound2" xml:space="preserve">
    <value>在“{0}”中多次声明了“Sub Main”: {1}</value>
  </data>
  <data name="WRN_XMLDocCrefAttributeNotFound1" xml:space="preserve">
    <value>XML 注释中的一个标记具有未能解析的“cref”特性“{0}”。</value>
  </data>
  <data name="ERR_CantThrowNonException" xml:space="preserve">
    <value>“Throw”操作数必须从“System.Exception”派生。</value>
  </data>
  <data name="ERR_PropertyAccessIgnored" xml:space="preserve">
    <value>属性访问必须分配给属性或使用属性值。</value>
  </data>
  <data name="ERR_FieldOfValueFieldOfMarshalByRef3" xml:space="preserve">
    <value>“{0}”，是使用“System.MarshalByRefObject”作为基类的类“{2}”的值类型字段“{1}”的成员，无法引用。</value>
  </data>
  <data name="ERR_LocalsCannotHaveAttributes" xml:space="preserve">
    <value>特性不能应用于局部变量。</value>
  </data>
  <data name="ERR_InvalidParameterSyntax" xml:space="preserve">
    <value>应为逗号或 ")"。</value>
  </data>
  <data name="ERR_BadAttributeSharedProperty1" xml:space="preserve">
    <value>“Shared”特性属性“{0}”不能作为赋值的目标。</value>
  </data>
  <data name="ERR_CatchNotException1" xml:space="preserve">
    <value>“Catch”无法捕捉类型“{0}”，因为该类型既不是“System.Exception”也不是从“System.Exception”继承的类。</value>
  </data>
  <data name="ERR_NullableParameterMustSpecifyType" xml:space="preserve">
    <value>可以为 null 的参数必须指定一个类型。</value>
  </data>
  <data name="ERR_CantSpecifyArraysOnBoth" xml:space="preserve">
    <value>不能在变量及其类型上同时指定数组修饰符。</value>
  </data>
  <data name="WRN_DefAsgUseNullRefStr" xml:space="preserve">
    <value>变量“{0}”在赋值前被使用。可能会在运行时导致 null 引用异常。请确保结构或所有引用成员在使用前已经初始化</value>
  </data>
  <data name="ERR_CantSpecifyParamsOnLambdaParamNoType" xml:space="preserve">
    <value>不能在 lambda 表达式的参数名中指定数组修饰符。数组修饰符必须在其类型中指定。</value>
  </data>
  <data name="ERR_CircularBaseDependencies4" xml:space="preserve">
    <value>此继承将导致在 {0}“{1}”及其嵌套类型或基类型“{2}”之间产生循环依赖项。</value>
  </data>
  <data name="ERR_RequiredAttributeConstConversion2" xml:space="preserve">
    <value>在用作属性参数的常量表达式中不能发生从“{0}”到“{1}”的转换。</value>
  </data>
  <data name="WRN_VarianceConversionFailedTryIn4_Title" xml:space="preserve">
    <value>无法将类型转换为目标类型</value>
  </data>
  <data name="ERR_LbElseifAfterElse" xml:space="preserve">
    <value>"#ElseIf" 不能作为 "#If" 块的一部分跟在 "#Else" 之后。</value>
  </data>
  <data name="ERR_NoSources" xml:space="preserve">
    <value>未指定输入源</value>
  </data>
  <data name="ERR_SecurityCriticalAsync" xml:space="preserve">
    <value>安全属性“{0}”不能应用于 Async 或 Iterator 方法。</value>
  </data>
  <data name="ERR_ObsoleteOptionalWithoutValue" xml:space="preserve">
    <value>可选参数必须指定默认值。</value>
  </data>
  <data name="ERR_MultiplyDefinedEnumMember2" xml:space="preserve">
    <value>此 {1} 中已声明了“{0}”。</value>
  </data>
  <data name="WRN_ComClassPropertySetObject1_Title" xml:space="preserve">
    <value>无法将属性作为 "Let" 属性向 COM 公开</value>
  </data>
  <data name="ERR_UndefinedType1" xml:space="preserve">
    <value>未定义类型“{0}”。</value>
  </data>
  <data name="ERR_NullableTypeInferenceNotSupported" xml:space="preserve">
    <value>在该上下文中不支持可以为 null 的类型推理。</value>
  </data>
  <data name="ERR_EndTryNoTry" xml:space="preserve">
    <value>“End Try”前面必须是匹配的“Try”。</value>
  </data>
  <data name="ERR_DuplicateRemoveHandlerDef" xml:space="preserve">
    <value>已经声明 "RemoveHandler"。</value>
  </data>
  <data name="StatementOrExpressionIsNotAValidType" xml:space="preserve">
    <value>StatementOrExpression 不是 ExecutableStatementSyntax 或 ExpressionSyntax</value>
  </data>
  <data name="ERR_InvalidAssemblyName" xml:space="preserve">
    <value>“{0}”不是 /moduleassemblyname 的有效值。</value>
  </data>
  <data name="ERR_ExpectedResumeOrGoto" xml:space="preserve">
    <value>应为 "Resume" 或 "GoTo"。</value>
  </data>
  <data name="ERR_CopyBackTypeMismatch3" xml:space="preserve">
    <value>由于类型“{1}”不能转换为类型“{2}”，因此无法将“ByRef”参数“{0}”的值复制回匹配的参数。</value>
  </data>
  <data name="ERR_ObsoletePropertyGetLetSet" xml:space="preserve">
    <value>不再支持 Property Get/Let/Set；请使用新的 Property 声明语法。</value>
  </data>
  <data name="ERR_InvInsideInterface" xml:space="preserve">
    <value>语句不能出现在接口体内。</value>
  </data>
  <data name="ERR_NamedArgumentSpecificationBeforeFixedArgumentInLateboundInvocation" xml:space="preserve">
    <value>Named argument specifications must appear after all fixed arguments have been specified in a late bound invocation.</value>
  </data>
  <data name="ERR_NamedParamNotFound1" xml:space="preserve">
    <value>“{0}”不是方法参数。</value>
  </data>
  <data name="ERR_NamedParamNotFound2" xml:space="preserve">
    <value>“{0}”不是“{1}”的参数。</value>
  </data>
  <data name="ERR_NamedParamNotFound3" xml:space="preserve">
    <value>“{0}”不是“{2}”中定义的扩展方法“{1}”的参数。</value>
  </data>
  <data name="ERR_ExpectedConditionalDirective" xml:space="preserve">
    <value>应为“If”、“ElseIf”、“Else”、“Const”、“Region”、“ExternalSource”、“ExternalChecksum”、“Enable”、“Disable”、“End”或“R”。</value>
  </data>
  <data name="WRN_BadChecksumValExtChecksum_Title" xml:space="preserve">
    <value>错误的校验和值、非十六进制数字或奇数个十六进制数字</value>
  </data>
  <data name="ERR_UnaryOperand2" xml:space="preserve">
    <value>没有为类型“{1}”定义运算符“{0}”。</value>
  </data>
  <data name="ERR_OverriddenCandidate1" xml:space="preserve">
    <value>
  “{0}”</value>
  </data>
  <data name="WRN_ParamNotCLSCompliant1_Title" xml:space="preserve">
    <value>参数的类型不符合 CLS</value>
  </data>
  <data name="ERR_TypeInferenceFailure1" xml:space="preserve">
    <value>无法从这些实参推断类型形参的数据类型。显式指定该数据类型可更正此错误。</value>
  </data>
  <data name="ERR_TypeInferenceFailure2" xml:space="preserve">
    <value>无法从这些实参推断方法“{0}”中类型形参的数据类型。显式指定数据类型可更正此错误。</value>
  </data>
  <data name="ERR_TypeInferenceFailure3" xml:space="preserve">
    <value>无法从这些实参推断“{1}”中定义的扩展方法“{0}”中类型形参的数据类型。显式指定数据类型可更正此错误。</value>
  </data>
  <data name="ERR_ObsoleteStructureNotType" xml:space="preserve">
    <value>不再支持 "Type" 语句；请改用 "Structure" 语句。</value>
  </data>
  <data name="ERR_LValueRequired" xml:space="preserve">
    <value>表达式是一个值，因此不能作为赋值目标。</value>
  </data>
  <data name="AnonymousObjectCreationExpressionSyntaxNotWithinTree" xml:space="preserve">
    <value>AnonymousObjectCreationExpressionSyntax 未在语法树内</value>
  </data>
  <data name="ERR_ArrayOfRawGenericInvalid" xml:space="preserve">
    <value>不应为 "("。不允许非实例化泛型类型的数组。</value>
  </data>
  <data name="ERR_InvalidAssemblyCultureForExe" xml:space="preserve">
    <value>可执行文件不能是附属程序集；区域性应始终为空</value>
  </data>
  <data name="ERR_ObsoleteInvalidOnEventMember" xml:space="preserve">
    <value>“{0}”不能应用于“'AddHandler”、“RemoveHandler”或“'RaiseEvent”定义。如有必要，请将该属性直接应用于事件。</value>
  </data>
  <data name="ERR_BadAttributeConstructor1" xml:space="preserve">
    <value>特性构造函数具有“{0}”类型的参数，此参数不是整型、浮点型或枚举类型，也不是 Object、Char、String、Boolean、System.Type 之一或这些类型的一维数组。</value>
  </data>
  <data name="ERR_BadAttributeConstructor2" xml:space="preserve">
    <value>特性构造函数有一个“{0}”类型的“ByRef”参数；不能用带有 byref 参数的构造函数来应用特性。</value>
  </data>
  <data name="ERR_ClashWithReservedEnumMember1" xml:space="preserve">
    <value>“{0}”与在所有枚举中隐式声明的同名保留成员冲突。</value>
  </data>
  <data name="ERR_ExpectedExpression" xml:space="preserve">
    <value>应为表达式。</value>
  </data>
  <data name="WRN_XMLDocBadFormedXML_Title" xml:space="preserve">
    <value>无法包含 XML 片段</value>
  </data>
  <data name="IDS_TheSystemCannotFindThePathSpecified" xml:space="preserve">
    <value>系统无法找到指定路径</value>
  </data>
  <data name="ERR_HandlesSyntaxInModule" xml:space="preserve">
    <value>模块中的“Handles”必须指定用单个标识符限定的“WithEvents”变量。</value>
  </data>
  <data name="WRN_MissingAsClauseinFunction" xml:space="preserve">
    <value>函数没有 "As" 子句；假定返回类型为 Object。</value>
  </data>
  <data name="ERR_TryWithoutCatchOrFinally" xml:space="preserve">
    <value>Try 必须至少有一个 "Catch" 或 "Finally"。</value>
  </data>
  <data name="ERR_ReadOnlyHasSet" xml:space="preserve">
    <value>声明为 "ReadOnly" 的属性不能有 "Set"。</value>
  </data>
  <data name="WRN_ConditionalNotValidOnFunction" xml:space="preserve">
    <value>特性 "Conditional" 只在 "Sub" 声明中有效。</value>
  </data>
  <data name="ERR_InvalidDebugInformationFormat" xml:space="preserve">
    <value>无效的调试信息格式: {0}</value>
  </data>
  <data name="ERR_UnacceptableForLoopOperator2" xml:space="preserve">
    <value>“{0}”的返回类型和参数类型必须是“{1}”，才能在“For”语句中使用。</value>
  </data>
  <data name="ERR_BadConstFlags1" xml:space="preserve">
    <value>“{0}”在常量声明中无效。</value>
  </data>
  <data name="ERR_VarianceInReadOnlyPropertyDisallowed1" xml:space="preserve">
    <value>类型“{0}”不能用作 ReadOnly 属性类型，因为“{0}”是“In”类型参数。</value>
  </data>
  <data name="WRN_ObjectAssumedProperty1" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="ERR_CatchNoMatchingTry" xml:space="preserve">
    <value>“Catch”不能出现在“Try”语句之外。</value>
  </data>
  <data name="WRN_BaseClassNotCLSCompliant2_Title" xml:space="preserve">
    <value>类型不符合 CLS，原因是它从不符合 CLS 的基类型派生</value>
  </data>
  <data name="ERR_InteropMethodWithBody1" xml:space="preserve">
    <value>嵌入互操作方法“{0}”包含主体。</value>
  </data>
  <data name="ERR_EndIfNoMatchingIf" xml:space="preserve">
    <value>"End If" 前面必须是匹配的 "If"。</value>
  </data>
  <data name="ERR_MissingEndInterface" xml:space="preserve">
    <value>"Interface" 必须以匹配的 "End Interface" 结束。</value>
  </data>
  <data name="ERR_ClassNotExpression1" xml:space="preserve">
    <value>“{0}”是一个类类型，不能用作表达式。</value>
  </data>
  <data name="ERR_BaseTypeReferences2" xml:space="preserve">
    <value>
  “{0}”基类型需要解析“{1}”。</value>
  </data>
  <data name="WRN_ImplicitConversion2_Title" xml:space="preserve">
    <value>隐式转换</value>
  </data>
  <data name="ERR_NameNotMember2" xml:space="preserve">
    <value>“{0}”不是“{1}”的成员。</value>
  </data>
  <data name="ERR_WriteOnlyNoAccessorFlag" xml:space="preserve">
    <value>"WriteOnly" 属性在 "Set" 上不能有访问修饰符。</value>
  </data>
  <data name="ERR_ExpectedGreater" xml:space="preserve">
    <value>应为“&gt;”。</value>
  </data>
  <data name="ERR_BadTypeArgForStructConstraint2" xml:space="preserve">
    <value>类型实参“{0}”不满足类型形参“{1}”的“Structure”约束。</value>
  </data>
  <data name="WRN_DefAsgUseNullRefByRef" xml:space="preserve">
    <value>变量“{0}”在赋值前按引用传递。可能会在运行时导致 null 引用异常。</value>
  </data>
  <data name="ERR_EventSourceIsArray" xml:space="preserve">
    <value>“WithEvents”变量不能类型化为数组。</value>
  </data>
  <data name="ERR_CoClassMissing2" xml:space="preserve">
    <value>无法找到接口“{1}”的实现类“{0}”。</value>
  </data>
  <data name="WRN_BadGUIDFormatExtChecksum" xml:space="preserve">
    <value>错误的 GUID 格式。</value>
  </data>
  <data name="ERR_CannotGotoNonScopeBlocksWithClosure" xml:space="preserve">
    <value>“{0}{1}”无效，因为“{2}”所在的范围定义一个用在 lambda 表达式或查询表达式中的变量。</value>
  </data>
  <data name="ERR_IllegalOperandInIIFConversion2" xml:space="preserve">
    <value>无法推断二元“If”运算符的第一个和第二个操作数的通用类型。其中一个必须是另一个的扩大转换。</value>
  </data>
  <data name="ERR_ConstraintCycleLink2" xml:space="preserve">
    <value>
  “{0}”被约束为“{1}”。</value>
  </data>
  <data name="ERR_ExpectedOptional" xml:space="preserve">
    <value>应为 "Optional"。</value>
  </data>
  <data name="ERR_PartialMethodParamArrayMismatch2" xml:space="preserve">
    <value>方法“{0}”的参数在分部方法“{1}”的相应参数的 ParamArray 修饰符上存在差异。</value>
  </data>
  <data name="WRN_DefAsgNoRetValFuncRef1_Title" xml:space="preserve">
    <value>函数没有在所有代码路径上返回值</value>
  </data>
  <data name="ERR_MyClassAbstractCall1" xml:space="preserve">
    <value>无法用“MyClass”调用“MustOverride”方法“{0}”。</value>
  </data>
  <data name="ERR_BadTypeArgForRefConstraint2" xml:space="preserve">
    <value>类型实参“{0}”不满足类型形参“{1}”的“Class”约束。</value>
  </data>
  <data name="ERR_LambdaNoType" xml:space="preserve">
    <value>无法推断返回类型。请考虑添加一个“As”子句来指定返回类型。</value>
  </data>
  <data name="ERR_ExtraSpecifiers" xml:space="preserve">
    <value>说明符仅在声明的开始处有效。</value>
  </data>
  <data name="WRN_DefAsgUseNullRef" xml:space="preserve">
    <value>变量“{0}”在赋值前被使用。可能会在运行时导致 null 引用异常。</value>
  </data>
  <data name="ERR_DefaultEventNotFound1" xml:space="preserve">
    <value>由“DefaultEvent”属性指定的事件“{0}”不是该类的公共可访问事件。</value>
  </data>
  <data name="ERR_GenericClassCannotInheritAttr" xml:space="preserve">
    <value>属于泛型或包含在泛型类型中的类不能从特性类继承。</value>
  </data>
  <data name="ERR_UseOfKeywordFromStructure1" xml:space="preserve">
    <value>“{0}”在结构中无效。</value>
  </data>
  <data name="WRN_MustShadowOnMultipleInheritance2" xml:space="preserve">
    <value>{0}“{1}”与继承层次结构中的其他同名成员冲突，因此应声明为“Shadows”。</value>
  </data>
  <data name="ERR_ConstraintClashDirectIndirect3" xml:space="preserve">
    <value>约束“{0}”与从类型参数约束“{2}”获得的间接约束“{1}”冲突。</value>
  </data>
  <data name="ERR_ArrayInitializerTooManyDimensions" xml:space="preserve">
    <value>数组初始值设定项的维数太多。</value>
  </data>
  <data name="ERR_TypecharNoMatch2" xml:space="preserve">
    <value>类型字符“{0}”与声明的数据类型“{1}”不匹配。</value>
  </data>
  <data name="ERR_ExpressionTreeNotSupported" xml:space="preserve">
    <value>无法将表达式转换为表达式树。</value>
  </data>
  <data name="ERR_TypeParamMissingCommaOrRParen" xml:space="preserve">
    <value>应为逗号或 ")"。</value>
  </data>
  <data name="WRN_ConditionalNotValidOnFunction_Title" xml:space="preserve">
    <value>特性 "Conditional" 只在 "Sub" 声明中有效</value>
  </data>
  <data name="ERR_TupleReservedElementName" xml:space="preserve">
    <value>只允许位置 {1} 使用元组元素名称“{0}”。</value>
  </data>
  <data name="ERR_IllegalOperandInIIFName" xml:space="preserve">
    <value>“If”操作数不能是命名参数。</value>
  </data>
  <data name="ERR_NoWithEventsVarOnHandlesList" xml:space="preserve">
    <value>Handles 子句要求一个在包含类型或它的某个基类型中定义的 WithEvents 变量。</value>
  </data>
  <data name="ERR_AnonymousTypeDisallowsTypeChar" xml:space="preserve">
    <value>不能在匿名类型声明中使用类型字符。</value>
  </data>
  <data name="WRN_OptionalValueNotCLSCompliant1" xml:space="preserve">
    <value>可选参数“{0}”的可选值的类型不符合 CLS。</value>
  </data>
  <data name="ERR_UnterminatedStringLiteral" xml:space="preserve">
    <value>字符串常量必须以双引号结束。</value>
  </data>
  <data name="ERR_ReadOnlyInClosure" xml:space="preserve">
    <value>在构造函数内的 lambda 表达式中，"ReadOnly" 变量不能作为赋值的目标。</value>
  </data>
  <data name="ERR_EncUpdateFailedMissingAttribute" xml:space="preserve">
    <value>无法更新“{0}”；特性“{1}”缺失。</value>
  </data>
  <data name="ERR_BadPropertyFlags1" xml:space="preserve">
    <value>属性不能声明为“{0}”。</value>
  </data>
  <data name="ERR_InvalidOptionCompare" xml:space="preserve">
    <value>"Option Compare" 的后面必须跟有 "Text" 或 "Binary"。</value>
  </data>
  <data name="ERR_ForIndexInUse1" xml:space="preserve">
    <value>For 循环控制变量“{0}”已由封闭 For 循环使用。</value>
  </data>
  <data name="ERR_KeywordNotAllowedInScript" xml:space="preserve">
    <value>您不能使用顶级脚本代码中的“{0}”</value>
  </data>
  <data name="IDS_ToolName" xml:space="preserve">
    <value>Microsoft (R) Visual Basic 编译器</value>
  </data>
  <data name="ERR_ConvertArrayRankMismatch2" xml:space="preserve">
    <value>类型“{0}”的值无法转换为“{1}”，原因是数组类型的维数不同。</value>
  </data>
  <data name="ERR_ConstructorCannotBeDeclaredPartial" xml:space="preserve">
    <value>“Sub New”不能声明为“Partial”。</value>
  </data>
  <data name="ERR_BadEmptyEnum1" xml:space="preserve">
    <value>枚举“{0}”必须至少包含一个成员。</value>
  </data>
  <data name="ERR_ConversionToInterfaceType" xml:space="preserve">
    <value>转换运算符不能转换为接口类型。</value>
  </data>
  <data name="ERR_ExpectedArray1" xml:space="preserve">
    <value>“{0}”语句需要数组。</value>
  </data>
  <data name="TreeMustHaveARootNodeWithCompilationUnit" xml:space="preserve">
    <value>树必须具有带 SyntaxKind.CompilationUnit 的根节点</value>
  </data>
  <data name="ERR_InAccessibleCoClass3" xml:space="preserve">
    <value>接口“{1}”的实现类“{0}”是“{2}”，因此它在此上下文中不可访问。</value>
  </data>
  <data name="ERR_MutuallyExclusiveOptions" xml:space="preserve">
    <value>无法同时指定编译选项“{0}”和“{1}”。</value>
  </data>
  <data name="CannotRemoveCompilerSpecialTree" xml:space="preserve">
    <value>无法移除特定于编译器的树</value>
  </data>
  <data name="ERR_OverrideNotNeeded3" xml:space="preserve">
    <value>{0}“{1}”不能声明为“Overrides”，因为它不重写基类中的 {0}。</value>
  </data>
  <data name="ERR_BadAttributeReadOnlyProperty1" xml:space="preserve">
    <value>“ReadOnly”特性属性“{0}”不能作为赋值的目标。</value>
  </data>
  <data name="ERR_DocFileGen" xml:space="preserve">
    <value>写入 XML 文档文件时出错: {0}</value>
  </data>
  <data name="ERR_VarianceOutParamDisallowedHereForGeneric4" xml:space="preserve">
    <value>在此上下文中，类型“{0}”不能用于“{1}”中“{3}”的“{2}”，因为“{0}”是“Out”类型参数。</value>
  </data>
  <data name="WRN_EventDelegateTypeNotCLSCompliant2" xml:space="preserve">
    <value>事件“{1}”的委托类型“{0}”不符合 CLS。</value>
  </data>
  <data name="ERR_LocalSameAsFunc" xml:space="preserve">
    <value>局部变量不能与包含它的函数同名。</value>
  </data>
  <data name="ERR_NameSameAsMethodTypeParam1" xml:space="preserve">
    <value>“{0}”已声明为此方法的类型参数。</value>
  </data>
  <data name="ERR_VarianceInParamDisallowedHereForGeneric4" xml:space="preserve">
    <value>在此上下文中，类型“{0}”不能用于“{1}”中“{3}”的“{2}”，因为“{0}”是“In”类型参数。</value>
  </data>
  <data name="ERR_StructureNotExpression1" xml:space="preserve">
    <value>“{0}”是一个结构类型，不能用作表达式。</value>
  </data>
  <data name="WRN_UseOfObsoleteSymbolNoMessage1" xml:space="preserve">
    <value>“{0}”已过时。</value>
  </data>
  <data name="ERR_ContinueWhileNotWithinWhile" xml:space="preserve">
    <value>“Continue While”只能出现在“While”语句内。</value>
  </data>
  <data name="FEATURE_PrivateProtected" xml:space="preserve">
    <value>Private Protected</value>
  </data>
  <data name="ERR_TooManyArgs2" xml:space="preserve">
    <value>对“{1}”中定义的扩展方法“{0}”而言，参数太多。</value>
  </data>
  <data name="ERR_TooManyArgs1" xml:space="preserve">
    <value>“{0}”的参数太多。</value>
  </data>
  <data name="ERR_DuplicateConversionCategoryUsed" xml:space="preserve">
    <value>"Widening" 不能与 "Narrowing" 组合。</value>
  </data>
  <data name="ERR_BadMetaDataReference1" xml:space="preserve">
    <value>“{0}”不是有效程序集，因此无法引用它。</value>
  </data>
  <data name="ERR_IsNotOperatorNullable1" xml:space="preserve">
    <value>类型“{0}”是可以为 null 的类型，因此“{0}”的“IsNot”操作数只能与“Nothing”进行比较。</value>
  </data>
  <data name="WRN_AssemblyGeneration1" xml:space="preserve">
    <value>生成程序集“{0}”时检测到可能存在的问题: {1}</value>
  </data>
  <data name="WRN_AssemblyGeneration0" xml:space="preserve">
    <value>生成程序集时检测到可能存在的问题: {0}</value>
  </data>
  <data name="ERR_CollisionWithPublicTypeInModule" xml:space="preserve">
    <value>类型“{0}”与添加的模块“{1}”中定义的公共类型冲突。</value>
  </data>
  <data name="ERR_VarianceOutParamDisallowedHere2" xml:space="preserve">
    <value>在此上下文中，类型“{0}”不能用于“{1}”，因为“{0}”是“Out”类型参数。</value>
  </data>
  <data name="ERR_MustInheritEventNotOverridden" xml:space="preserve">
    <value>“{0}”是基类“{1}” 中的 MustOverride 事件。Visual Basic 不支持事件替代。必须提供基类中事件的实现或让类“{2}“成为 MustInherit。</value>
  </data>
  <data name="WRN_TypeInferenceAssumed3" xml:space="preserve">
    <value>未能推断“{1}”中“{0}”的数据类型。假定为“{2}”。</value>
  </data>
  <data name="ERR_EventAddRemoveByrefParamIllegal" xml:space="preserve">
    <value>“AddHandler”和“RemoveHandler”方法参数不能声明为“ByRef”。</value>
  </data>
  <data name="ERR_ExtraNextVariable" xml:space="preserve">
    <value>“Next”语句命名的变量比已有的匹配“For”语句多。</value>
  </data>
  <data name="ERR_ExpectedWarningKeyword" xml:space="preserve">
    <value>应为“Warning”。</value>
  </data>
  <data name="WRN_ObjectMath2_Title" xml:space="preserve">
    <value>为运算符使用的 Object 类型的操作数</value>
  </data>
  <data name="ERR_ExprTreeNoMultiDimArrayCreation" xml:space="preserve">
    <value>多维数组无法转换为表达式树。</value>
  </data>
  <data name="ERR_UnrecognizedTypeOrWith" xml:space="preserve">
    <value>应为类型或 "With"。</value>
  </data>
  <data name="ERR_InvalidEnumBase" xml:space="preserve">
    <value>枚举必须声明为整型。</value>
  </data>
  <data name="ERR_ParamNameFunctionNameCollision" xml:space="preserve">
    <value>参数不能与它的定义函数同名。</value>
  </data>
  <data name="WRN_ArrayOverloadsNonCLS2_Title" xml:space="preserve">
    <value>方法不符合 CLS，因为它重载仅在数组参数类型的数组或数组参数类型的秩方面与它不同的方法</value>
  </data>
  <data name="ERR_PropertySetParamCollisionWithValue" xml:space="preserve">
    <value>属性参数的名称不能为 "Value"。</value>
  </data>
  <data name="ERR_TypeCharOnGenericParam" xml:space="preserve">
    <value>在类型参数声明中不能使用类型字符。</value>
  </data>
  <data name="ERR_CannotUseOnErrorGotoWithClosure" xml:space="preserve">
    <value>方法不能同时包含“{0}”语句以及在 lambda 或查询表达式中使用的变量的定义。</value>
  </data>
  <data name="WRN_VarianceConversionFailedOut6" xml:space="preserve">
    <value>从“{4}”到“{5}”的隐式转换；此转换可能失败，因为根据“{3}”中“Out”泛型形参“{2}”的需要，“{0}”不是从“{1}”派生的。</value>
  </data>
  <data name="ERR_ModuleCantUseDLLDeclareSpecifier1" xml:space="preserve">
    <value>模块中的“Declare”语句不能声明为“{0}”。</value>
  </data>
  <data name="ERR_CantSpecifyAsNewAndNullable" xml:space="preserve">
    <value>在变量声明中不能用“As New”指定可以为 null 的修饰符。</value>
  </data>
  <data name="WRN_XMLDocGenericParamTagWithoutName_Title" xml:space="preserve">
    <value>XML 注释类型参数必须具有 "name" 属性</value>
  </data>
  <data name="WRN_XMLDocOnAPartialType_Title" xml:space="preserve">
    <value>XML 注释无法在一个分部类型上应用多次</value>
  </data>
  <data name="ERR_InvalidEndInterface" xml:space="preserve">
    <value>“End Interface”前面必须是匹配的“Interface”。</value>
  </data>
  <data name="ERR_ModuleCantUseVariableSpecifier1" xml:space="preserve">
    <value>模块中的变量不能声明为“{0}”。</value>
  </data>
  <data name="ERR_PartialMethodTypeParamNameMismatch3" xml:space="preserve">
    <value>类型参数“{0}”的名称与在分部方法声明“{2}”上定义的相应类型参数“{1}”不匹配。</value>
  </data>
  <data name="ERR_PDBWritingFailed" xml:space="preserve">
    <value>写入调试信息失败: {0}</value>
  </data>
  <data name="ERR_MetadataMembersAmbiguous3" xml:space="preserve">
    <value>“{0}”不明确，因为 {1}“{2}”中存在多种具有此名称的成员</value>
  </data>
  <data name="WRN_UnusedLocal" xml:space="preserve">
    <value>未使用的局部变量:“{0}”。</value>
  </data>
  <data name="ERR_MustOverridesInClass1" xml:space="preserve">
    <value>“{0}”包含声明为“MustOverride”的方法，因此它必须声明为“MustInherit”。</value>
  </data>
  <data name="WRN_XMLDocBadFormedXML" xml:space="preserve">
    <value>无法包括文件“{0}”的 XML 段落“{1}”。{2}</value>
  </data>
  <data name="ERR_ExpectedEndTry" xml:space="preserve">
    <value>“Try”必须以匹配的“End Try”结束。</value>
  </data>
  <data name="ERR_ImportAliasConflictsWithType2" xml:space="preserve">
    <value>Imports 别名“{0}”与根命名空间中声明的“{1}”冲突。</value>
  </data>
  <data name="ERR_InterfaceImplementedTwice1" xml:space="preserve">
    <value>接口“{0}”只能由此类型实现一次。</value>
  </data>
  <data name="WRN_ImplicitConversionCopyBack_Title" xml:space="preserve">
    <value>在把 "ByRef" 参数的值复制回匹配参数的过程中进行隐式转换</value>
  </data>
  <data name="ERR_UseOfKeywordNotInInstanceMethod1" xml:space="preserve">
    <value>“{0}”仅在实例方法中有效。</value>
  </data>
  <data name="ERR_EventHandlerSignatureIncompatible2" xml:space="preserve">
    <value>方法“{0}”无法处理事件“{1}”，因为它们的签名不兼容。</value>
  </data>
  <data name="ERR_ExpectedEquals" xml:space="preserve">
    <value>应为“Equals”。</value>
  </data>
  <data name="ERR_InvalidOptionalParameterUsage1" xml:space="preserve">
    <value>属性“{0}”不能应用于具有可选参数的方法。</value>
  </data>
  <data name="ERR_UnreferencedAssemblyEvent3" xml:space="preserve">
    <value>需要对程序集“{0}”(包含事件“{1}”的定义)的引用。请在项目中添加一个。</value>
  </data>
  <data name="ERR_InvalidCoClass1" xml:space="preserve">
    <value>类型“{0}”不能用作实现类。</value>
  </data>
  <data name="WrongSemanticModelType" xml:space="preserve">
    <value>应为 {0} SemanticModel。</value>
  </data>
  <data name="WRN_MissingAsClauseinFunction_Title" xml:space="preserve">
    <value>函数没有 "As" 子句</value>
  </data>
  <data name="ERR_DuplicateParamName1" xml:space="preserve">
    <value>已用名称“{0}”声明了参数。</value>
  </data>
  <data name="ERR_RestrictedType1" xml:space="preserve">
    <value>“{0}”不能设置为可以为 null，而且不能用作数组元素、字段、匿名类型成员、类型参数、“ByRef”参数或返回语句的数据类型。</value>
  </data>
  <data name="WRN_AttributeIgnoredWhenPublicSigning_Title" xml:space="preserve">
    <value>指定公共签名时，将忽略特性。</value>
  </data>
  <data name="ERR_InvalidEndRemoveHandler" xml:space="preserve">
    <value>“End RemoveHandler”前面必须是匹配的“RemoveHandler”声明。</value>
  </data>
  <data name="ERR_TooManyUserStrings" xml:space="preserve">
    <value>该程序所使用的用户字符串的合并后长度超出所允许的限制。请尝试减少字符串文本或 XML 文本的使用。</value>
  </data>
  <data name="ERR_OmittedParamArrayArgument" xml:space="preserve">
    <value>省略的实参不能匹配 ParamArray 形参。</value>
  </data>
  <data name="ERR_SharedConstructorWithParams" xml:space="preserve">
    <value>共享的 "Sub New" 不能具有任何参数。</value>
  </data>
  <data name="WRN_VarianceConversionFailedIn6_Title" xml:space="preserve">
    <value>隐式转换；此转换可能失败，原因是目标类型不是从源类型派生的，而这是 "In" 泛型参数所必需的</value>
  </data>
  <data name="WRN_FieldNotCLSCompliant1_Title" xml:space="preserve">
    <value>成员的类型不符合 CLS</value>
  </data>
  <data name="ERR_SharedConstructorIllegalSpec1" xml:space="preserve">
    <value>共享的“Sub New”不能声明为“{0}”。</value>
  </data>
  <data name="ERR_TypeMismatchForXml3" xml:space="preserve">
    <value>类型“{0}”的值无法转换为“{1}”。可使用“Value”属性来获取“{2}”的第一个元素的字符串值。</value>
  </data>
  <data name="ERR_UnableToReadUacManifest2" xml:space="preserve">
    <value>无法打开 Win32 清单文件“{0}”: {1}</value>
  </data>
  <data name="WRN_MutableGenericStructureInUsing_Title" xml:space="preserve">
    <value>Using 语句声明的局部变量是只读的，它的类型可能是一种结构</value>
  </data>
  <data name="WRN_NonCLSMustOverrideInCLSType1" xml:space="preserve">
    <value>在符合 CLS 的类型“{0}”中不允许出现不符合 CLS 的 "MustOverride" 成员。</value>
  </data>
  <data name="ERR_QueryInvalidControlVariableName1" xml:space="preserve">
    <value>范围变量名无法与 "Object" 类的成员名匹配。</value>
  </data>
  <data name="ERR_DelegateBindingIncompatible2" xml:space="preserve">
    <value>方法“{0}”没有与委托“{1}”兼容的签名。</value>
  </data>
  <data name="ERR_DelegateBindingIncompatible3" xml:space="preserve">
    <value>“{2}”中定义的扩展方法“{0}”没有与委托“{1}”兼容的签名。</value>
  </data>
  <data name="ERR_ClassInheritsInterfaceUnifiesWithBase3" xml:space="preserve">
    <value>无法实现接口“{0}”，因为对于某些类型参数，它可能与实现的接口“{2}”所继承的接口“{1}”相同。</value>
  </data>
  <data name="WRN_XMLDocExceptionTagWithoutCRef_Title" xml:space="preserve">
    <value>XML 注释异常必须具有 "cref" 属性</value>
  </data>
  <data name="ERR_DefaultPropertyWithNoParams" xml:space="preserve">
    <value>不带必选参数的属性不能声明为“Default”。</value>
  </data>
  <data name="WRN_RecursiveOperatorCall" xml:space="preserve">
    <value>表达式以递归方式调用包含运算符“{0}”。</value>
  </data>
  <data name="ERR_DllImportOnInterfaceMethod" xml:space="preserve">
    <value>"System.Runtime.InteropServices.DllImportAttribute" 不能应用于接口方法。</value>
  </data>
  <data name="ERR_DuplicateLocalStatic1" xml:space="preserve">
    <value>已声明静态局部变量“{0}”。</value>
  </data>
  <data name="WRN_FileAlreadyIncluded" xml:space="preserve">
    <value>源文件“{0}”指定了多次</value>
  </data>
  <data name="ERR_ReImplementingWinRTInterface4" xml:space="preserve">
    <value>“{0}.{1}”已由基类“{2}”实现。不允许重新实现 Windows Runtime 接口“{3}”</value>
  </data>
  <data name="ERR_ReImplementingWinRTInterface5" xml:space="preserve">
    <value>“实现 {2}”中的“{0}.{1}”已由基类“{3}”实现。不允许重新实现 Windows Runtime 接口“{4}”</value>
  </data>
  <data name="WRN_StaticLocalNoInference_Title" xml:space="preserve">
    <value>声明静态变量时未使用 "As" 子句</value>
  </data>
  <data name="WRN_XMLDocParamTagWithoutName" xml:space="preserve">
    <value>XML 注释参数必须具有 "name" 属性。</value>
  </data>
  <data name="ERR_InvalidEndEnum" xml:space="preserve">
    <value>“End Enum”前面必须是匹配的“Enum”。</value>
  </data>
  <data name="ERR_DelegateBindingMismatchStrictOff3" xml:space="preserve">
    <value>Option Strict On 不允许对“{2}”中定义的扩展方法“{0}”和委托“{1}”之间的隐式类型转换进行收缩。</value>
  </data>
  <data name="ERR_DelegateBindingMismatchStrictOff2" xml:space="preserve">
    <value>Option Strict On 不允许对方法“{0}”和委托“{1}”之间的隐式类型转换进行收缩。</value>
  </data>
  <data name="ERR_LambdaInSelectCaseExpr" xml:space="preserve">
    <value>Lambda 表达式在 "Select Case" 语句的第一个表达式中无效。</value>
  </data>
  <data name="WRN_BaseClassNotCLSCompliant2" xml:space="preserve">
    <value>“{0}”不符合 CLS，因为它是从不符合 CLS 的“{1}”派生的。</value>
  </data>
  <data name="ERR_DuplicateOption1" xml:space="preserve">
    <value>每个文件中只能出现一次“Option {0}”语句。</value>
  </data>
  <data name="ERR_InterfaceInheritedTwiceWithDifferentTupleNames3" xml:space="preserve">
    <value>接口“{0}”只能通过此接口继承一次，但已显示有不同的元组元素名称，如“{1}”(通过“{2}”)。</value>
  </data>
  <data name="ERR_InterfaceInheritedTwiceWithDifferentTupleNames2" xml:space="preserve">
    <value>接口“{0}”只能通过此接口继承一次，但已显示有不同的元组元素名称，如“{1}”。</value>
  </data>
  <data name="ERR_InterfaceInheritedTwiceWithDifferentTupleNames4" xml:space="preserve">
    <value>接口“{0}”只能通过此接口继承一次(通过“{1}”)，但已显示有不同的元组元素名称，如“{2}”(通过“{3}”)。</value>
  </data>
  <data name="ERR_ValueTupleTypeRefResolutionError1" xml:space="preserve">
    <value>预定义的类型“{0}”未定义或未导入。</value>
  </data>
  <data name="ERR_MissingEndRemoveHandler" xml:space="preserve">
    <value>"RemoveHandler" 声明必须以匹配的 "End RemoveHandler" 结束。</value>
  </data>
  <data name="NotWithinTree" xml:space="preserve">
    <value> 不在树中</value>
  </data>
  <data name="ERR_BadClassFlags1" xml:space="preserve">
    <value>类不能声明为“{0}”。</value>
  </data>
  <data name="WRN_VarianceConversionFailedIn6" xml:space="preserve">
    <value>从“{4}”到“{5}”的隐式转换；此转换可能失败，因为根据“{3}”中“In”泛型形参“{2}”的需要，“{0}”不是从“{1}”派生的。</value>
  </data>
  <data name="ERR_FriendAssemblyNameInvalid" xml:space="preserve">
    <value>友元声明“{0}”无效，且无法解析。</value>
  </data>
  <data name="ERR_ExtensionMethodParamArrayFirstArg" xml:space="preserve">
    <value>“ParamArray”无法应用于扩展方法的第一个参数。第一个参数指定要扩展哪个类型。</value>
  </data>
  <data name="ERR_StrictDisallowsLateBinding" xml:space="preserve">
    <value>Option Strict On 不允许后期绑定。</value>
  </data>
  <data name="ERR_BadFlagsOnSharedProperty1" xml:space="preserve">
    <value>“Shared”不能与属性声明上的“{0}”组合。</value>
  </data>
  <data name="ERR_ParamArrayNotArray" xml:space="preserve">
    <value>ParamArray 参数必须是一个数组。</value>
  </data>
  <data name="ERR_OperatorDeclaredInModule" xml:space="preserve">
    <value>运算符不能在模块中声明。</value>
  </data>
  <data name="ERR_ExpectedIntLiteral" xml:space="preserve">
    <value>应为整数常量。</value>
  </data>
  <data name="ERR_BadInterfaceInterfaceSpecifier1" xml:space="preserve">
    <value>接口中的接口不能声明为“{0}”。</value>
  </data>
  <data name="WRN_NonCLSMemberInCLSInterface1" xml:space="preserve">
    <value>在符合 CLS 的接口中不允许出现不符合 CLS 的“{0}”。</value>
  </data>
  <data name="ERR_DuplicateImport1" xml:space="preserve">
    <value>已导入命名空间或类型呢“{0}”。</value>
  </data>
  <data name="ERR_ExpectedInOrEq" xml:space="preserve">
    <value>应为“In”或“=”。</value>
  </data>
  <data name="ERR_WinRTEventWithoutDelegate" xml:space="preserve">
    <value>面向 WinMD 的事件声明必须指定委托类型。请在事件声明中添加一个 As 子句。</value>
  </data>
  <data name="WRN_SynthMemberShadowsSynthMember7" xml:space="preserve">
    <value>{0}“{1}”隐式声明的“{2}”与为基 {5}“{6}”中的 {3}“{4}”隐式声明的成员冲突。{0} 应声明为“Shadows”。</value>
  </data>
  <data name="ERR_RefReturningCallInExpressionTree" xml:space="preserve">
    <value>表达式树不能包含对引用所返回的方法或属性的调用。</value>
  </data>
  <data name="ERR_ExitSubOfFunc" xml:space="preserve">
    <value>"Exit Sub" 在函数或属性中无效。</value>
  </data>
  <data name="ERR_EventImplMismatch5" xml:space="preserve">
    <value>事件“{0}”无法实现接口“{2}”上的事件“{1}”，因为其委托类型“{3}”和“{4}”不匹配。</value>
  </data>
  <data name="ERR_LabelNotDefined1" xml:space="preserve">
    <value>未定义标签“{0}”。</value>
  </data>
  <data name="WRN_PdbUsingNameTooLong_Title" xml:space="preserve">
    <value>导入字符串对 PDB 而言太长</value>
  </data>
  <data name="WRN_ObjectAssumed1" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="ERR_UseOfObsoleteSymbolNoMessage1" xml:space="preserve">
    <value>“{0}”已过时。</value>
  </data>
  <data name="ERR_IllegalDefaultNamespace" xml:space="preserve">
    <value>带前缀的命名空间声明在 XML 文本中不能有空值。</value>
  </data>
  <data name="ERR_InReferencedAssembly" xml:space="preserve">
    <value>引用的程序集“{0}”中有错误。</value>
  </data>
  <data name="ERR_PartialMethodParamNamesMustMatch3" xml:space="preserve">
    <value>参数名“{0}”与在分部方法声明“{2}”上定义的相应参数的名称“{1}”不匹配。</value>
  </data>
  <data name="ERR_BadStaticInitializerInResumable" xml:space="preserve">
    <value>静态变量不能出现在异步方法或迭代器方法内。</value>
  </data>
  <data name="ERR_GotoIntoTryHandler" xml:space="preserve">
    <value>“GoTo {0}”语句无效，因为“{0}”位于不包含此语句的“Try”、“Catch”或“Finally”语句中。</value>
  </data>
  <data name="ERR_NewAndValueConstraintsCombined" xml:space="preserve">
    <value>"New" 约束不能与 "Structure" 约束组合。</value>
  </data>
  <data name="ERR_SetValueNotPropertyType" xml:space="preserve">
    <value>"Set" 参数必须与包含属性的类型相同。</value>
  </data>
  <data name="ERR_IllegalAttributeInXmlDecl" xml:space="preserve">
    <value>XML 声明不允许属性“{0}{1}{2}”。</value>
  </data>
  <data name="WRN_UnableToLoadAnalyzer_Title" xml:space="preserve">
    <value>无法加载分析器程序集</value>
  </data>
  <data name="ERR_NoNonIndexProperty1" xml:space="preserve">
    <value>无法找到不带参数的属性“{0}”。</value>
  </data>
  <data name="WRN_ComClassNoMembers1_Title" xml:space="preserve">
    <value>为类指定了 "Microsoft.VisualBasic.ComClassAttribute"，但类没有可向 COM 公开的公共成员</value>
  </data>
  <data name="ERR_MustBeInCatchToRethrow" xml:space="preserve">
    <value>"Throw" 语句在 "Catch" 语句外或 "Finally" 语句内不能省略操作数。</value>
  </data>
  <data name="ERR_BadAwaitInNonAsyncVoidMethod" xml:space="preserve">
    <value>“Await”只能用于异步方法中。请考虑用“Async”修饰符标记此方法，并将其返回类型更改为“Task”。</value>
  </data>
  <data name="WRN_ParamNotCLSCompliant1" xml:space="preserve">
    <value>参数“{0}”的类型不符合 CLS。</value>
  </data>
  <data name="WRN_NoConfigInResponseFile" xml:space="preserve">
    <value>/noconfig 选项是在响应文件中指定的，因此被忽略</value>
  </data>
  <data name="ERR_SpecifiersInvOnEventMethod" xml:space="preserve">
    <value>说明符在 "AddHandler"、"RemoveHandler" 和 "RaiseEvent" 方法上无效。</value>
  </data>
  <data name="ERR_ExpectedAssignmentOperatorInInit" xml:space="preserve">
    <value>应为 "="(对象初始值设定项)。</value>
  </data>
  <data name="ERR_UnrecognizedTypeKeyword" xml:space="preserve">
    <value>关键字没有指定类型。</value>
  </data>
  <data name="ERR_InitWithExplicitArraySizes" xml:space="preserve">
    <value>对于用显式界限声明的数组不允许进行显式初始化。</value>
  </data>
  <data name="ERR_ByRefParamInExpressionTree" xml:space="preserve">
    <value>对“ByRef”参数的引用无法转换为表达式树。</value>
  </data>
  <data name="FEATURE_Iterators" xml:space="preserve">
    <value>迭代器</value>
  </data>
  <data name="ERR_InAccessibleOverridingMethod5" xml:space="preserve">
    <value>类“{1}”中的“{0}”不能重写类“{3}”中的“{2}”，因为中间类“{4}”重写了类“{3}”中的“{2}”，但不可访问。</value>
  </data>
  <data name="WRN_CLSMemberInNonCLSType3" xml:space="preserve">
    <value>{0}“{1}”不能被标记为符合 CLS，因为它的包含类型“{2}”不符合 CLS。</value>
  </data>
  <data name="ERR_MissingNext" xml:space="preserve">
    <value>应为 "Next"。</value>
  </data>
  <data name="ERR_BaseOnlyClassesMustBeExplicit2" xml:space="preserve">
    <value>类“{0}”必须声明为“MustInherit”或重写以下继承的“MustOverride”成员: {1}。</value>
  </data>
  <data name="WRN_NoAnalyzerInAssembly_Title" xml:space="preserve">
    <value>程序集不包含任何分析器</value>
  </data>
  <data name="ERR_ModuleCantUseMethodSpecifier1" xml:space="preserve">
    <value>模块中的方法不能声明为“{0}”。</value>
  </data>
  <data name="ERR_UnexpectedExpressionStatement" xml:space="preserve">
    <value>只允许在交互提交结尾处使用表达式语句。</value>
  </data>
  <data name="ERR_InterpolationFormatWhitespace" xml:space="preserve">
    <value>格式说明符可能不包含尾随空格。</value>
  </data>
  <data name="ERR_AggrInitInvalidForObject" xml:space="preserve">
    <value>不能使用对象初始值设定项语法初始化“System.Object”的实例。</value>
  </data>
  <data name="ERR_NotOverridableRequiresOverrides" xml:space="preserve">
    <value>不能为不重写另一个方法的方法指定 "NotOverridable"。</value>
  </data>
  <data name="WRN_XMLDocDuplicateXMLNode1" xml:space="preserve">
    <value>具有相同特性的 XML 注释标记“{0}”在同一 XML 注释块中出现多次。</value>
  </data>
  <data name="ERR_SpecifiersInvalidOnInheritsImplOpt" xml:space="preserve">
    <value>说明符和特性在此语句上无效。</value>
  </data>
  <data name="ERR_AddressOfInSelectCaseExpr" xml:space="preserve">
    <value>“AddressOf”表达式在“Select Case”语句的第一个表达式中无效。</value>
  </data>
  <data name="WRN_Experimental" xml:space="preserve">
    <value>“{0}”仅用于评估，在将来的更新中可能会被更改或删除。</value>
  </data>
  <data name="PositionIsNotWithinSyntax" xml:space="preserve">
    <value>位置不在语法树中</value>
  </data>
  <data name="WRN_ObsoleteIdentityDirectCastForValueType" xml:space="preserve">
    <value>使用 DirectCast 运算符将值类型强制转换为同一类型的做法已过时。</value>
  </data>
  <data name="WRN_XMLDocBadParamTag2" xml:space="preserve">
    <value>XML 注释参数“{0}”和相应的“{1}”语句的参数不匹配。</value>
  </data>
  <data name="WRN_TypeConflictButMerged6" xml:space="preserve">
    <value>{0}“{1}”和分部 {2}“{3}”在 {4}“{5}”中冲突，但由于其中的一个被声明为 Partial，因此正在合并。</value>
  </data>
  <data name="ERR_ExpectedLbrace" xml:space="preserve">
    <value>应为 "{"。</value>
  </data>
  <data name="WRN_VarianceConversionFailedTryIn4" xml:space="preserve">
    <value>“{0}”不能转换为“{1}”。考虑在“{3}”的定义中将“{2}”改为 In 类型参数“In {2}”。</value>
  </data>
  <data name="ERR_BadMethodFlags1" xml:space="preserve">
    <value>“{0}”在方法声明中无效。</value>
  </data>
  <data name="ERR_RequiredNewCallTooMany2" xml:space="preserve">
    <value>“{1}”的基类“{0}”没有不使用参数就可以调用的可访问“Sub New”，因此该“Sub New”的第一个语句必须是对“MyBase.New”或“MyClass.New”的调用。</value>
  </data>
  <data name="ERR_CannotBeMadeNullable1" xml:space="preserve">
    <value>“{0}”不可以为 Null。</value>
  </data>
  <data name="ERR_TypeDisallowsElements" xml:space="preserve">
    <value>XML 元素不能从类型“{0}”中选择。</value>
  </data>
  <data name="ERR_MultipleEventImplMismatch3" xml:space="preserve">
    <value>事件“{0}”不能实现事件“{2}.{1}”，因为其委托类型与“{0}”实现的另一个事件的委托类型不匹配。</value>
  </data>
  <data name="ERR_InvalidDate" xml:space="preserve">
    <value>日期常量无效。</value>
  </data>
  <data name="ERR_InvalidOptionInfer" xml:space="preserve">
    <value>"Option Infer" 后面只能跟 "On" 或 "Off"。</value>
  </data>
  <data name="ERR_ExpectedLparen" xml:space="preserve">
    <value>应为“(”。</value>
  </data>
  <data name="ERR_InvalidAsyncIteratorModifiers" xml:space="preserve">
    <value>“Async”和“Iterator”修饰符不能一起使用。</value>
  </data>
  <data name="ThereIsNoDynamicTypeInVB" xml:space="preserve">
    <value>VB 中没有任何动态类型。</value>
  </data>
  <data name="ERR_OneParameterRequired1" xml:space="preserve">
    <value>运算符“{0}”必须有一个参数。</value>
  </data>
  <data name="ERR_TypeOfExprAlwaysFalse2" xml:space="preserve">
    <value>类型“{0}”的表达式永远不能为类型“{1}”。</value>
  </data>
  <data name="ERR_EnumNotExpression1" xml:space="preserve">
    <value>“{0}”是一个枚举类型，不能用作表达式。</value>
  </data>
  <data name="ERR_InvalidEndFunction" xml:space="preserve">
    <value>“End Function”前面必须是匹配的“Function”。</value>
  </data>
  <data name="WRN_LiftControlVariableLambda" xml:space="preserve">
    <value>在 lambda 表达式中使用迭代变量可能会产生意外的结果。应改为在循环中创建一个局部变量并将迭代变量的值赋给它。</value>
  </data>
  <data name="WRN_LateBindingResolution" xml:space="preserve">
    <value>后期绑定解决方案；可能会发生运行时错误。</value>
  </data>
  <data name="ERR_ConvMustBeWideningOrNarrowing" xml:space="preserve">
    <value>转换运算符必须声明为“Widening”或者“Narrowing”。</value>
  </data>
  <data name="ERR_SharedEventNeedsSharedHandler" xml:space="preserve">
    <value>共享 WithEvents 变量的事件不能由非共享方法处理。</value>
  </data>
  <data name="ERR_UnacceptableLogicalOperator3" xml:space="preserve">
    <value>“{0}”的返回类型和参数类型必须是“{1}”，才能在“{2}”表达式中使用。</value>
  </data>
  <data name="ERR_LineContWithCommentOrNoPrecSpace" xml:space="preserve">
    <value>行继续符 "_" 的前面必须至少有一个空白字符，而且必须是所在行中的最后一个字符。</value>
  </data>
  <data name="ERR_InterfaceEventCantUse1" xml:space="preserve">
    <value>接口中的事件无法声明为“{0}”。</value>
  </data>
  <data name="ERR_InvalidVersionFormat2" xml:space="preserve">
    <value>指定版本字符串不符合建议格式 - major.minor.build.revision</value>
  </data>
  <data name="WRN_RequiredNonObsoleteNewCall3" xml:space="preserve">
    <value>此“Sub New”中的第一条语句应为对“MyBase.New”或“MyClass.New”的显式调用，因为“{2}”的基类“{1}”中的“{0}”被标记为已过时。</value>
  </data>
  <data name="WRN_RequiredNonObsoleteNewCall4" xml:space="preserve">
    <value>此“Sub New”中的第一条语句应为对“MyBase.New”或“MyClass.New”的显式调用，因为“{2}”的基类“{1}”中的“{0}”被标记为已过时:“{3}”</value>
  </data>
  <data name="ERR_InterfaceCantUseEventSpecifier1" xml:space="preserve">
    <value>“{0}”在接口事件声明中无效。</value>
  </data>
  <data name="ERR_ExpressionOverflow1" xml:space="preserve">
    <value>常量表达式无法在类型“{0}”中表示。</value>
  </data>
  <data name="ERR_OverrideWithByref2" xml:space="preserve">
    <value>“{0}”无法重写“{1}”，因为它们在某个参数上存在差异，一个被标记为“ByRef”，而另一个被标记为“ByVal”。</value>
  </data>
  <data name="ERR_UnimplementedMustOverride" xml:space="preserve">
    <value>
  {0}: {1}</value>
  </data>
  <data name="ERR_NewOnAbstractClass" xml:space="preserve">
    <value>"New" 不能在声明为 "MustInherit" 的类上使用。</value>
  </data>
  <data name="ERR_MismatchedXmlEndTag" xml:space="preserve">
    <value>应为结束标记 &lt;/{0}{1}{2}&gt;。</value>
  </data>
  <data name="LocationMustBeProvided" xml:space="preserve">
    <value>必须提供位置才能提供最低程度的类型限定。</value>
  </data>
  <data name="WRN_InterfaceConversion2_Title" xml:space="preserve">
    <value>运行时错误可能在转换到或从接口类型转换时发生</value>
  </data>
  <data name="ERR_BinaryFile" xml:space="preserve">
    <value>文件“{0}”不是文本文件</value>
  </data>
  <data name="ERR_ReturnFromNonFunction" xml:space="preserve">
    <value>Sub 或 Set 中的 "Return" 语句不能返回值。</value>
  </data>
  <data name="ERR_DefaultMemberNotProperty1" xml:space="preserve">
    <value>“{0}”的默认成员不是属性。</value>
  </data>
  <data name="ERR_BranchOutOfFinally" xml:space="preserve">
    <value>从“Finally”中分支无效。</value>
  </data>
  <data name="ERR_CantOpenFileWrite" xml:space="preserve">
    <value>无法打开“{0}”进行写入: {1}</value>
  </data>
  <data name="ERR_CantSpecifyArrayAndNullableOnBoth" xml:space="preserve">
    <value>不能在变量及其类型上同时指定可为 null 的修饰符“?”和数组修饰符“(”/“)”。</value>
  </data>
  <data name="WRN_VarianceIEnumerableSuggestion3" xml:space="preserve">
    <value>“{0}”不能转换为“{1}”。考虑改用“{2}”。</value>
  </data>
  <data name="ERR_RequiredConstConversion2" xml:space="preserve">
    <value>常量表达式中不能发生从“{0}”到“{1}”的转换。</value>
  </data>
  <data name="ERR_MultipleReferenceConstraints" xml:space="preserve">
    <value>"Class" 约束不能为同一类型参数指定多次。</value>
  </data>
  <data name="ERR_ExpectedEndIf" xml:space="preserve">
    <value>“If”必须以匹配的“End If”结束。</value>
  </data>
  <data name="ERR_ExpectedComma" xml:space="preserve">
    <value>应为逗号。</value>
  </data>
  <data name="WRN_BadGUIDFormatExtChecksum_Title" xml:space="preserve">
    <value>错误的 GUID 格式</value>
  </data>
  <data name="ERR_NoSetProperty1" xml:space="preserve">
    <value>属性“{0}”为“ReadOnly”。</value>
  </data>
  <data name="ERR_ExpectedMinus" xml:space="preserve">
    <value>应为“-”。</value>
  </data>
  <data name="ERR_InterfaceImplementedTwiceWithDifferentTupleNamesReverse3" xml:space="preserve">
    <value>接口“{0}”只能通过此类型实现一次(通过“{1}”)，但已显示有不同的元组元素名称，如“{2}”。。</value>
  </data>
  <data name="ERR_ExpectedQuote" xml:space="preserve">
    <value>XML 特性值应有匹配的右双引号。</value>
  </data>
  <data name="ERR_NotACollection1" xml:space="preserve">
    <value>无法用集合初始值设定项初始化类型“{0}”，因为该类型不是集合类型。</value>
  </data>
  <data name="ERR_BadPropertyAccessorFlags1" xml:space="preserve">
    <value>属性访问器不能在“NotOverridable”属性中声明为“{0}”。</value>
  </data>
  <data name="ERR_BadPropertyAccessorFlags3" xml:space="preserve">
    <value>属性包含“Private”访问器，因此不能声明为“{0}”。</value>
  </data>
  <data name="ERR_BadPropertyAccessorFlags2" xml:space="preserve">
    <value>属性访问器不能在“Default”属性中声明为“{0}”。</value>
  </data>
  <data name="ERR_AsyncSubMain" xml:space="preserve">
    <value>"Main" 方法不能标记为 "Async"。</value>
  </data>
  <data name="ERR_NamespaceNotExpression1" xml:space="preserve">
    <value>“{0}”是一个命名空间，不能用作表达式。</value>
  </data>
  <data name="ERR_ExpectedXmlns" xml:space="preserve">
    <value>命名空间声明必须以“xmlns”开头。</value>
  </data>
  <data name="WRN_ShadowingGenericParamWithParam1_Title" xml:space="preserve">
    <value>类型参数与封闭类型的类型参数具有相同的名称</value>
  </data>
  <data name="ERR_MatchingOperatorExpected2" xml:space="preserve">
    <value>“{1}”需要匹配“{0}”运算符。</value>
  </data>
  <data name="ERR_NewInInterface" xml:space="preserve">
    <value>"Sub New" 不能在接口中声明。</value>
  </data>
  <data name="ERR_ExpectedEndWith" xml:space="preserve">
    <value>“With”必须以匹配的“End With”结束。</value>
  </data>
  <data name="ERR_WriteOnlyHasNoWrite" xml:space="preserve">
    <value>"WriteOnly" 属性必须提供 "Set"。</value>
  </data>
  <data name="WRN_XMLDocInsideMethod" xml:space="preserve">
    <value>XML 注释不能在方法或属性内出现。XML 注释将被忽略。</value>
  </data>
  <data name="ERR_VarianceInParamDisallowedForGeneric3" xml:space="preserve">
    <value>在此上下文中，类型“{0}”不能用于“{2}”中的“{1}”，因为“{0}”是“In”类型参数。</value>
  </data>
  <data name="ERR_MissingValuesForArraysInApplAttrs" xml:space="preserve">
    <value>必须有用作特性参数的数组才能显式指定所有元素的值。</value>
  </data>
  <data name="WRN_DelaySignButNoKey" xml:space="preserve">
    <value>指定了延迟签名，这需要公钥，但是未指定任何公钥。</value>
  </data>
  <data name="ERR_ParamArrayArgumentMismatch" xml:space="preserve">
    <value>参数不能匹配 ParamArray 参数。</value>
  </data>
  <data name="ERR_BadAttributeNonPublicType1" xml:space="preserve">
    <value>类型“{0}”未声明为“Public”，因此不能用在特性中。</value>
  </data>
  <data name="FEATURE_RegionsEverywhere" xml:space="preserve">
    <value>方法主体内的 region 指令或跨声明块边界的 region</value>
  </data>
  <data name="WRN_UseOfObsoletePropertyAccessor2_Title" xml:space="preserve">
    <value>属性访问器已过时</value>
  </data>
  <data name="WRN_SharedMemberThroughInstance_Title" xml:space="preserve">
    <value>通过实例访问共享成员、常量成员、枚举成员或嵌套类型</value>
  </data>
  <data name="WRN_NoNonObsoleteConstructorOnBase3" xml:space="preserve">
    <value>类“{0}”应该声明一个“Sub New”，因为其基类“{2}”中的“{1}”被标记为已过时。</value>
  </data>
  <data name="WRN_NoNonObsoleteConstructorOnBase4" xml:space="preserve">
    <value>类“{0}”应该声明一个“Sub New”，因为其基类“{2}”中的“{1}”被标记为已过时:“{3}”。</value>
  </data>
  <data name="ERR_VarianceOutParamDisallowedForGeneric3" xml:space="preserve">
    <value>在此上下文中，类型“{0}”不能用于“{2}”中的“{1}”，因为“{0}”是“Out”类型参数。</value>
  </data>
  <data name="ERR_BadAsyncInQuery" xml:space="preserve">
    <value>"Await" 只能在初始 "From" 子句的第一个集合表达式或 "Join" 子句的集合表达式的查询表达式中使用。</value>
  </data>
  <data name="ERR_InvalidOptionExplicit" xml:space="preserve">
    <value>"Option Explicit" 的后面只能跟 "On" 或 "Off"。</value>
  </data>
  <data name="ERR_AmbiguousInModules2" xml:space="preserve">
    <value>“{0}”在模块“{1}”中的声明之间不明确。</value>
  </data>
  <data name="WRN_LambdaTooManyTypesObjectAssumed" xml:space="preserve">
    <value>无法推断返回类型，因为可能存在多个类型；假定为 "Object"。</value>
  </data>
  <data name="WRN_DefAsgUseNullRefByRef_Title" xml:space="preserve">
    <value>在为变量赋值之前，变量已被引用传递</value>
  </data>
  <data name="ERR_InterfaceBaseUnifiesWithBase4" xml:space="preserve">
    <value>无法继承接口“{0}”，因为对于某些类型参数，继承的接口“{1}”可能与接口“{3}”继承的接口“{2}”相同。</value>
  </data>
  <data name="SemanticModelMustBeProvided" xml:space="preserve">
    <value>必须提供 SemanticModel 才能提供最低程度的类型限定。</value>
  </data>
  <data name="ERR_ExpectedAnd" xml:space="preserve">
    <value>应为 "And"。</value>
  </data>
  <data name="ERR_ExpectedEOS" xml:space="preserve">
    <value>应为语句结束。</value>
  </data>
  <data name="ERR_ExpectedDot" xml:space="preserve">
    <value>应为“.”。</value>
  </data>
  <data name="ERR_ExpectedDiv" xml:space="preserve">
    <value>应使用“/”作为 XML 结束标记。</value>
  </data>
  <data name="ERR_DuplicateReference2" xml:space="preserve">
    <value>项目已经具有对程序集“{0}”的引用。无法添加另一个对“{1}”的引用。</value>
  </data>
  <data name="ERR_DuplicateSpecifier" xml:space="preserve">
    <value>说明符重复。</value>
  </data>
  <data name="ERR_DuplicateNamedImportAlias1" xml:space="preserve">
    <value>已声明别名“{0}”。</value>
  </data>
  <data name="ERR_ModuleAsType1" xml:space="preserve">
    <value>模块“{0}”不能用作类型。</value>
  </data>
  <data name="ERR_NewCannotHandleEvents" xml:space="preserve">
    <value>"Sub New" 无法处理事件。</value>
  </data>
  <data name="ERR_ArrayInitInStruct" xml:space="preserve">
    <value>声明为结构成员的数组不能用初始大小声明。</value>
  </data>
  <data name="ERR_NestedInteropType" xml:space="preserve">
    <value>无法嵌入嵌套类型“{0}”。</value>
  </data>
  <data name="ERR_ExpectedAssignmentOperator" xml:space="preserve">
    <value>应为 "="。</value>
  </data>
  <data name="ERR_BadInterfaceStructSpecifier1" xml:space="preserve">
    <value>接口中的结构不能声明为“{0}”。</value>
  </data>
  <data name="IDS_MSG_ADDREFERENCE" xml:space="preserve">
    <value>正在添加程序集引用“{0}”</value>
  </data>
  <data name="FEATURE_NameOfExpressions" xml:space="preserve">
    <value>"nameof" 表达式</value>
  </data>
  <data name="WRN_ReturnTypeAttributeOnWriteOnlyProperty" xml:space="preserve">
    <value>应用于 WriteOnly 属性的返回类型的特性不起作用。</value>
  </data>
  <data name="WRN_DefAsgUseNullRef_Title" xml:space="preserve">
    <value>在为变量赋值之前，变量已被使用</value>
  </data>
  <data name="ERR_BadAnonymousTypeForExprTree" xml:space="preserve">
    <value>无法将匿名类型转换为表达式树，因为此类型的属性用于初始化其他属性。</value>
  </data>
  <data name="ERR_ModuleNotAtNamespace" xml:space="preserve">
    <value>"Module" 语句只能出现在文件级或命名空间级。</value>
  </data>
  <data name="ERR_VarianceConversionFailedTryOut4" xml:space="preserve">
    <value>“{0}”不能转换为“{1}”。考虑在“{3}”的定义中将“{2}”改为 Out 类型参数“Out {2}”。</value>
  </data>
  <data name="ERR_DelegateBindingTypeInferenceFails" xml:space="preserve">
    <value>未能从委托中推断类型参数。</value>
  </data>
  <data name="ERR_MissingGuidForOption" xml:space="preserve">
    <value>命令行语法错误: 选项“{1}”缺少 Guid</value>
  </data>
  <data name="WRN_ConflictingMachineAssembly" xml:space="preserve">
    <value>引用程序集“{0}”面向的是另一个处理器。</value>
  </data>
  <data name="WRN_InheritedInterfaceNotCLSCompliant2_Title" xml:space="preserve">
    <value>类型不符合 CLS，原因是它继承自的接口不符合 CLS</value>
  </data>
  <data name="ERR_PeWritingFailure" xml:space="preserve">
    <value>写入输出文件时出错: {0}</value>
  </data>
  <data name="ERR_NamedArgAlsoOmitted3" xml:space="preserve">
    <value>“{2}”中定义的扩展方法中的“{1}”形参“{0}”已具有匹配的省略实参。</value>
  </data>
  <data name="ERR_NamedArgAlsoOmitted2" xml:space="preserve">
    <value>“{1}”中的形参“{0}”已具有匹配的省略实参。</value>
  </data>
  <data name="ERR_NamedArgAlsoOmitted1" xml:space="preserve">
    <value>形参“{0}”已具有匹配的省略实参。</value>
  </data>
  <data name="WRN_InvalidVersionFormat_Title" xml:space="preserve">
    <value>指定的版本字符串不符合建议的格式</value>
  </data>
  <data name="ERR_ParamArrayWrongType" xml:space="preserve">
    <value>ParamArray 参数必须有数组类型。</value>
  </data>
  <data name="ERR_TooFewIndices" xml:space="preserve">
    <value>索引数少于索引数组的维数。</value>
  </data>
  <data name="ERR_SynthMemberShadowsMustOverride5" xml:space="preserve">
    <value>为 {1}“{2}”隐式声明的“{0}”不能隐藏基 {3}“{4}”中的“MustOverride”方法。</value>
  </data>
  <data name="ERR_EventNotFound1" xml:space="preserve">
    <value>找不到事件“{0}”。</value>
  </data>
  <data name="ERR_DTDNotSupported" xml:space="preserve">
    <value>不支持 XML DTD。</value>
  </data>
  <data name="ERR_DuplicateAddHandlerDef" xml:space="preserve">
    <value>已经声明 "AddHandler"。</value>
  </data>
  <data name="ERR_NoNonObsoleteConstructorOnBase4" xml:space="preserve">
    <value>类“{0}”必须声明一个“Sub New”，因为它的基类“{2}”中的“{1}”被标记为已过时:“{3}”。</value>
  </data>
  <data name="ERR_NoNonObsoleteConstructorOnBase3" xml:space="preserve">
    <value>类“{0}”必须声明一个“Sub New”，因为它的基类“{2}”中的“{1}”被标记为已过时。</value>
  </data>
  <data name="DeclarationSyntaxNotWithinTree" xml:space="preserve">
    <value>DeclarationSyntax 未在树内</value>
  </data>
  <data name="WRN_LambdaPassedToRemoveHandler" xml:space="preserve">
    <value>Lambda 表达式将不会从此事件处理程序中移除。将 lambda 表达式赋给变量，并使用该变量添加和移除事件。</value>
  </data>
  <data name="ERR_ConstructorFunction" xml:space="preserve">
    <value>构造函数必须声明为 Sub，而不是 Function。</value>
  </data>
  <data name="ERR_LbElseNoMatchingIf" xml:space="preserve">
    <value>"#Else" 前面必须是匹配的 "#If" 或 "#ElseIf"。</value>
  </data>
  <data name="ERR_BadIteratorExpressionLambda" xml:space="preserve">
    <value>单行 lambda 不能包含“Iterator”修饰符。请改用多行 lambda。</value>
  </data>
  <data name="ERR_EqualsOperandIsBad" xml:space="preserve">
    <value>“Equals”运算符的每一侧都必须至少引用一个范围变量。范围变量 {0} 必须出现在“Equals”运算符的一侧，范围变量 {1} 必须出现在另一侧。</value>
  </data>
  <data name="ERR_MultipleClassConstraints1" xml:space="preserve">
    <value>类型参数“{0}”只能有一个属于类的约束。</value>
  </data>
  <data name="ERR_NarrowingConversionCollection2" xml:space="preserve">
    <value>Option Strict On 不允许从“{0}”到“{1}”的隐式转换；Visual Basic 6.0 集合类型与 .NET Framework 集合类型不兼容。</value>
  </data>
  <data name="ERR_ObsoleteWhileWend" xml:space="preserve">
    <value>不再支持 "Wend" 语句；请改用 "End While" 语句。</value>
  </data>
  <data name="ERR_CantAssignToConst" xml:space="preserve">
    <value>常量不能作为赋值目标。</value>
  </data>
  <data name="WRN_DefAsgUseNullRefByRefStr_Title" xml:space="preserve">
    <value>在为变量赋值之前，变量已被引用传递</value>
  </data>
  <data name="ERR_AnonTypeFieldXMLNameInference" xml:space="preserve">
    <value>无法根据不是有效 Visual Basic 标识符的 XML 标识符推断出匿名类型成员名称。</value>
  </data>
  <data name="ERR_DelegateBindingFailure3" xml:space="preserve">
    <value>没有任何可访问的方法“{0}”具有与委托“{1}”兼容的签名: {2}</value>
  </data>
  <data name="ERR_EventMethodOptionalParamIllegal1" xml:space="preserve">
    <value>“AddHandler”、“RemoveHandler”和“RaiseEvent”方法参数不能声明为“{0}”。</value>
  </data>
  <data name="WRN_CLSAttrInvalidOnGetSet_Title" xml:space="preserve">
    <value>System.CLSCompliantAttribute 不能应用于属性 "Get" 或 "Set"</value>
  </data>
  <data name="ERR_NoGlobalExpectedIdentifier" xml:space="preserve">
    <value>此上下文中不允许 "Global"；应为标识符。</value>
  </data>
  <data name="ERR_VersionMustBeFirstInXmlDecl" xml:space="preserve">
    <value>XML 特性 "version" 必须是 XML 声明中的第一个特性。</value>
  </data>
  <data name="ERR_IsOperatorGenericParam1" xml:space="preserve">
    <value>类型“{0}”是没有类约束的类型参数，因此类型“{0}”的“Is”操作数只能与“Nothing”比较。</value>
  </data>
  <data name="ERR_EndSubExpected" xml:space="preserve">
    <value>应为 "End Sub"。</value>
  </data>
  <data name="ERR_BadInterfaceMethodFlags1" xml:space="preserve">
    <value>“{0}”在接口方法声明中无效。</value>
  </data>
  <data name="ERR_VarianceDisallowedHere" xml:space="preserve">
    <value>关键字 "Out" 和 "In" 只能在接口声明和委托声明中使用。</value>
  </data>
  <data name="ERR_BadStaticLocalInGenericMethod" xml:space="preserve">
    <value>泛型方法中的局部变量不能声明为“Static”。</value>
  </data>
  <data name="ERR_NewInStruct" xml:space="preserve">
    <value>结构不能声明没有参数的非共享 "Sub New"。</value>
  </data>
  <data name="ERR_UsingResourceVarNeedsInitializer" xml:space="preserve">
    <value>"Using" 资源变量必须有一个显式初始化。</value>
  </data>
  <data name="ERR_InvalidSignaturePublicKey" xml:space="preserve">
    <value>在 AssemblySignatureKeyAttribute 中指定的签名公钥无效。</value>
  </data>
  <data name="WRN_TupleLiteralNameMismatch" xml:space="preserve">
    <value>由于目标类型“{1}”指定了其他名称或未指定名称，因此元组元素名称“{0}”被忽略。</value>
  </data>
  <data name="ERR_MultipleValueConstraints" xml:space="preserve">
    <value>"Structure" 约束不能为同一类型参数指定多次。</value>
  </data>
  <data name="ERR_AnonymousTypeExpectedIdentifier" xml:space="preserve">
    <value>应为开头带有句点的标识符。</value>
  </data>
  <data name="ERR_CaseAfterCaseElse" xml:space="preserve">
    <value>在同一“Select”语句中，“Case”不能位于“Case Else”之后。</value>
  </data>
  <data name="ERR_UnreferencedModuleEvent3" xml:space="preserve">
    <value>需要对模块“{0}”(包含事件“{1}”的定义)的引用。请在项目中添加一个。</value>
  </data>
  <data name="ERR_NonFieldPropertyAggrMemberInit1" xml:space="preserve">
    <value>无法在对象初始值设定项表达式中初始化成员“{0}”，因为它不是一个字段或属性。</value>
  </data>
  <data name="WRN_LambdaTooManyTypesObjectAssumed_Title" xml:space="preserve">
    <value>无法推断返回类型，原因是可能存在多个类型</value>
  </data>
  <data name="ERR_TupleLiteralDisallowsTypeChar" xml:space="preserve">
    <value>类型字符无法用在元组文本中。</value>
  </data>
  <data name="ERR_InterpolatedStringFactoryError" xml:space="preserve">
    <value>向 {0}.{1} 发出调用时出现一个或多个错误。方法或其返回类型可能缺失或格式不正确。</value>
  </data>
  <data name="ERR_InheritsFromNonInterface" xml:space="preserve">
    <value>接口只能从其他接口继承。</value>
  </data>
  <data name="ERR_IfTooManyTypesObjectDisallowed" xml:space="preserve">
    <value>无法推断通用类型，因为可能存在多个类型。</value>
  </data>
  <data name="WRN_XMLDocWithoutLanguageElement_Title" xml:space="preserve">
    <value>XML 文档注释必须位于成员声明或类型声明之前</value>
  </data>
  <data name="ERR_ExpectedRparen" xml:space="preserve">
    <value>应为 ")"。</value>
  </data>
  <data name="ERR_ExpectedSQuote" xml:space="preserve">
    <value>XML 特性值应有匹配的右单引号。</value>
  </data>
  <data name="ERR_CaseElseNoSelect" xml:space="preserve">
    <value>“Case Else”只能出现在“Select Case”语句内。</value>
  </data>
  <data name="ERR_ExpectedRbrace" xml:space="preserve">
    <value>应为 "}"。</value>
  </data>
  <data name="ERR_CantAwaitAsyncSub1" xml:space="preserve">
    <value>“{0}”不返回 Task 且无法等待。请考虑将它更改为 Async Function。</value>
  </data>
  <data name="ERR_ExpectedSColon" xml:space="preserve">
    <value>应为 XML 实体的结束标记“;”。</value>
  </data>
  <data name="ERR_UnacceptableForLoopRelOperator2" xml:space="preserve">
    <value>“{0}”的参数类型必须是“{1}”，才能在“For”语句中使用。</value>
  </data>
  <data name="ERR_GenericParamsOnInvalidMember" xml:space="preserve">
    <value>在此声明上不能指定类型参数。</value>
  </data>
  <data name="WRN_InterfaceConversion2" xml:space="preserve">
    <value>将“{0}”转换为“{1}”时可能发生运行时错误。</value>
  </data>
  <data name="ERR_RequiredNonObsoleteNewCall4" xml:space="preserve">
    <value>此“Sub New”的第一条语句必须是对“MyBase.New”或“MyClass.New”的显式调用，因为“{2}”的基类“{1}”中的“{0}”被标为已过时:“{3}”。</value>
  </data>
  <data name="ERR_RequiredNonObsoleteNewCall3" xml:space="preserve">
    <value>此“Sub New”的第一条语句必须是对“MyBase.New”或“MyClass.New”的显式调用，因为“{2}”的基类“{1}”中的“{0}”被标为已过时。</value>
  </data>
  <data name="ERR_OverridesImpliesOverridable" xml:space="preserve">
    <value>声明为 "Overrides" 的方法是隐式可重写的，因此它们不能声明为 "Overridable"。</value>
  </data>
  <data name="ERR_NarrowingConversionDisallowed2" xml:space="preserve">
    <value>Option Strict On 不允许从“{0}”到“{1}”的隐式转换。</value>
  </data>
  <data name="ERR_BadResumableAccessReturnVariable" xml:space="preserve">
    <value>无法访问迭代器方法或异步方法的隐式返回变量。</value>
  </data>
  <data name="ERR_AttributeMustBeClassNotStruct1" xml:space="preserve">
    <value>“{0}”不是类，因此不能用作属性。</value>
  </data>
  <data name="ERR_InvalidNewInType" xml:space="preserve">
    <value>"New" 在此上下文中无效。</value>
  </data>
  <data name="ERR_PermissionSetAttributeFileReadError" xml:space="preserve">
    <value>读取为 PermissionSet 属性的命名参数“{1}”指定的文件“'{0}' ”时出错:“{2}”。</value>
  </data>
  <data name="ERR_InheritanceCycleInImportedType1" xml:space="preserve">
    <value>类型“{0}”直接或者间接从自身继承，因此不受支持。</value>
  </data>
  <data name="WRN_NameNotCLSCompliant1" xml:space="preserve">
    <value>名称“{0}”不符合 CLS。</value>
  </data>
  <data name="WRN_UndefinedOrEmptyNamespaceOrClass1" xml:space="preserve">
    <value>Imports“{0}”中指定的命名空间或类型不包含任何公共成员，或者找不到该命名空间或类型。确保定义了该命名空间或类型且其中至少包含一个公共成员。确保导入的元素名不使用任何别名。</value>
  </data>
  <data name="WRN_PdbUsingNameTooLong" xml:space="preserve">
    <value>导入字符串“{0}”对于 PDB 太长。请考虑缩短或在不使用 /debug 的情况下编译。</value>
  </data>
  <data name="ERR_ConversionFromObject" xml:space="preserve">
    <value>转换运算符不能从 Object 转换。</value>
  </data>
  <data name="ERR_NoViableOverloadCandidates1" xml:space="preserve">
    <value>重载决策失败，因为没有可访问的“{0}”。</value>
  </data>
  <data name="ERR_StructsCannotHandleEvents" xml:space="preserve">
    <value>结构中声明的方法不能有 "Handles" 子句。</value>
  </data>
  <data name="ERR_AutoPropertyCantHaveParams" xml:space="preserve">
    <value>自动实现的属性不能带有参数。</value>
  </data>
  <data name="ERR_ArrayInitNoType" xml:space="preserve">
    <value>无法推断元素类型。指定数组的类型可更正此错误。</value>
  </data>
  <data name="ERR_ClassInheritsInterfaceBaseUnifiesWithBase4" xml:space="preserve">
    <value>无法实现接口“{0}”，因为对于某些类型参数，它所继承的接口“{1}”可能与实现的接口“{3}”所继承的接口“{2}”相同。</value>
  </data>
  <data name="ERR_EventAddRemoveHasOnlyOneParam" xml:space="preserve">
    <value>“AddHandler”和“RemoveHandler”方法必须正好有一个参数。</value>
  </data>
  <data name="WRN_NotEqualToLiteralNothing" xml:space="preserve">
    <value>此表达式的计算结果始终为 Nothing (由于来自等于运算符的 null 传播)。若要检查值是否不为 null，请考虑使用 "IsNot Nothing"。</value>
  </data>
  <data name="WRN_ArrayOverloadsNonCLS2" xml:space="preserve">
    <value>“{0}”不符合 CLS，因为它重载仅在数组参数类型的数组或数组参数类型的秩方面与它不同的“{1}”。</value>
  </data>
  <data name="ERR_VarianceIEnumerableSuggestion3" xml:space="preserve">
    <value>“{0}”不能转换为“{1}”。考虑改用“{2}”。</value>
  </data>
  <data name="ERR_EndOperatorNotAtLineStart" xml:space="preserve">
    <value>“End Operator”必须是一行中的第一条语句。</value>
  </data>
  <data name="ERR_InvalidImplicitVar" xml:space="preserve">
    <value>由于“{1}”，隐式变量“{0}”无效。</value>
  </data>
  <data name="FEATURE_ArrayLiterals" xml:space="preserve">
    <value>数组文本表达式</value>
  </data>
  <data name="FEATURE_MultilineStringLiterals" xml:space="preserve">
    <value>多行字符串文本</value>
  </data>
  <data name="ERR_ParamDefaultValueDiffersFromAttribute" xml:space="preserve">
    <value>参数具有多个不同的默认值。</value>
  </data>
  <data name="ERR_FullWidthAsXmlDelimiter" xml:space="preserve">
    <value>全角字符不能用作 XML 分隔符。</value>
  </data>
  <data name="ERR_TypeClashesWithVbCoreType4" xml:space="preserve">
    <value>{0}“{1}”与 Visual Basic 运行时 {2}“{3}”冲突。</value>
  </data>
  <data name="ERR_InvalidNonSerializedUsage" xml:space="preserve">
    <value>"NonSerialized" 特性对此成员无效，因为它的包含类不作为 "Serializable" 公开。</value>
  </data>
  <data name="ERR_ModuleCantInherit" xml:space="preserve">
    <value>"Inherits" 在模块中无效。</value>
  </data>
  <data name="ERR_InterpolationAlignmentOutOfRange" xml:space="preserve">
    <value>对齐值不在支持的范围内。</value>
  </data>
  <data name="ERR_DuplicateRaiseEventDef" xml:space="preserve">
    <value>已经声明 "RaiseEvent"。</value>
  </data>
  <data name="WRN_UnreachableCode_Title" xml:space="preserve">
    <value>检测到无法访问的代码</value>
  </data>
  <data name="WRN_AsyncLacksAwaits" xml:space="preserve">
    <value>此异步方法缺少 "Await" 运算符，因此它将同步运行。请考虑使用 "Await" 运算符等待非阻止 API 调用，或使用 "Await Task.Run(...)" 利用后台线程执行占用大量 CPU 的工作。</value>
  </data>
  <data name="WRN_XMLMissingFileOrPathAttribute1" xml:space="preserve">
    <value>XML 注释标记“include”必须具有“{0}”特性。XML 注释将被忽略。</value>
  </data>
  <data name="ERR_ImplementsStmtWrongOrder" xml:space="preserve">
    <value>“Implements”语句在类中必须位于任何“Inherits”语句之后，所有声明之前。</value>
  </data>
  <data name="WRN_ExpectedInitComponentCall2_Title" xml:space="preserve">
    <value>设计器生成的类型中的构造函数应调用 InitializeComponent 方法</value>
  </data>
  <data name="WRN_OverrideType5_Title" xml:space="preserve">
    <value>成员与基类型中的成员发生冲突，因此应声明为 "Shadows"</value>
  </data>
  <data name="ERR_ExpectedSingleScript" xml:space="preserve">
    <value>需要一个脚本 (.vbx 文件)</value>
  </data>
  <data name="ERR_LambdasCannotHaveAttributes" xml:space="preserve">
    <value>特性不能应用于 lambda 表达式的参数。</value>
  </data>
  <data name="ERR_LambdaNotDelegate1" xml:space="preserve">
    <value>Lambda 表达式无法转换为“{0}”，因为“{0}”不是委托类型。</value>
  </data>
  <data name="ERR_NextNoMatchingFor" xml:space="preserve">
    <value>"Next" 前面必须是匹配的 "For"。</value>
  </data>
  <data name="ERR_ConstNotClassInterfaceOrTypeParam1" xml:space="preserve">
    <value>类型约束“{0}”必须是类、接口或类型参数。</value>
  </data>
  <data name="WRN_UnableToLoadAnalyzer" xml:space="preserve">
    <value>无法加载分析器程序集 {0}: {1}。</value>
  </data>
  <data name="ERR_ReadOnlyAssignment" xml:space="preserve">
    <value>"ReadOnly" 变量不能作为赋值目标。</value>
  </data>
  <data name="ERR_PartialTypeTypeParamNameMismatch3" xml:space="preserve">
    <value>类型参数名“{0}”与在“{2}”的某个其他分部类型上定义的相应类型参数的名称“{1}”不匹配。</value>
  </data>
  <data name="WRN_LiftControlVariableQuery" xml:space="preserve">
    <value>在查询表达式中使用迭代变量可能会产生意外的结果。应改为在循环中创建一个局部变量并将迭代变量的值赋给它。</value>
  </data>
  <data name="ERR_InvalidHandles" xml:space="preserve">
    <value>“Handles”在运算符声明上无效。</value>
  </data>
  <data name="ERR_ObjectReferenceNotSupplied" xml:space="preserve">
    <value>对非共享成员的引用要求对象引用。</value>
  </data>
  <data name="ERR_StrictDisallowsObjectComparison1" xml:space="preserve">
    <value>Option Strict On 不允许将类型 Object 的操作数用于运算符“{0}”。请使用“Is”运算符测试对象标识。</value>
  </data>
  <data name="ERR_OverloadWithArrayVsParamArray2" xml:space="preserve">
    <value>“{0}”和“{1}”的差异仅在于声明为“ParamArray”的参数，因此它们无法重载对方。</value>
  </data>
  <data name="ERR_EventImplRemoveHandlerParamWrong" xml:space="preserve">
    <value>事件“{0}”无法实现接口“{2}”上的事件“{1}”，因为其“RemoveHandler”方法的参数不匹配。</value>
  </data>
  <data name="ERR_UnrecognizedEnd" xml:space="preserve">
    <value>"End" 语句无效。</value>
  </data>
  <data name="ERR_ConvertObjectArrayMismatch3" xml:space="preserve">
    <value>类型“{0}”的值无法转换为“{1}”，因为“{2}”不是引用类型。</value>
  </data>
  <data name="ERR_BadModuleFlags1" xml:space="preserve">
    <value>模块不能声明为“{0}”。</value>
  </data>
  <data name="ERR_IllegalXmlWhiteSpace" xml:space="preserve">
    <value>此处不能使用空白。</value>
  </data>
  <data name="WRN_XMLDocIllegalTagOnElement2" xml:space="preserve">
    <value>“{1}”语言元素中不允许 XML 注释标记“{0}”。</value>
  </data>
  <data name="ERR_NotMostSpecificOverload" xml:space="preserve">
    <value>不是最适合。</value>
  </data>
  <data name="WRN_BadSwitch" xml:space="preserve">
    <value>无法识别的选项“{0}”；已忽略</value>
  </data>
  <data name="ERR_BadOverrideAccess2" xml:space="preserve">
    <value>“{0}”无法重写“{1}”，因为它们具有不同的访问级别。</value>
  </data>
  <data name="WRN_MutableStructureInUsing" xml:space="preserve">
    <value>局部变量“{0}”是只读的并且其类型是结构。调用此变量的成员或通过 ByRef 传递它不会更改其内容，并可能导致意外的错误。考虑在“Using”块之外声明此变量。</value>
  </data>
  <data name="WRN_VarianceConversionFailedTryOut4_Title" xml:space="preserve">
    <value>无法将类型转换为目标类型</value>
  </data>
  <data name="VariableSyntaxNotWithinSyntaxTree" xml:space="preserve">
    <value>variableSyntax 不在语法树中</value>
  </data>
  <data name="WRN_AssemblyAttributeFromModuleIsOverridden" xml:space="preserve">
    <value>来自模块“{1}”的特性“{0}”将忽略，以便支持源中出现的实例。</value>
  </data>
  <data name="ERR_UseOfObsoletePropertyAccessor2" xml:space="preserve">
    <value>“{1}”的“{0}”访问器已过时。</value>
  </data>
  <data name="ERR_UseOfObsoletePropertyAccessor3" xml:space="preserve">
    <value>“{1}”的“{0}”访问器已过时:“{2}”。</value>
  </data>
  <data name="ERR_TupleTooFewElements" xml:space="preserve">
    <value>元组必须包含至少两个元素。</value>
  </data>
  <data name="ERR_InferringNonArrayType1" xml:space="preserve">
    <value>无法用非数组类型“{0}”初始化变量。</value>
  </data>
  <data name="FEATURE_LineContinuationComments" xml:space="preserve">
    <value>行延续注释</value>
  </data>
  <data name="WRN_EmptyPrefixAndXmlnsLocalName_Title" xml:space="preserve">
    <value>xmlns 特性具有特殊含义，不应使用前缀进行编写</value>
  </data>
  <data name="WRN_BadUILang" xml:space="preserve">
    <value>语言名“{0}”无效。</value>
  </data>
  <data name="WRN_EqualToLiteralNothing_Title" xml:space="preserve">
    <value>此表达式的计算结果始终为 Nothing</value>
  </data>
  <data name="ERR_ArgumentCopyBackNarrowing3" xml:space="preserve">
    <value>将“ByRef”参数“{0}”的值复制回匹配的参数将导致从类型“{1}”到类型“{2}”的收缩。</value>
  </data>
  <data name="ERR_InvalidAssemblyCulture" xml:space="preserve">
    <value>程序集区域性字符串可能不包含嵌入式 NUL 字符。</value>
  </data>
  <data name="ERR_ClassConstraintNotInheritable1" xml:space="preserve">
    <value>类型约束不能是“NotInheritable”类。</value>
  </data>
  <data name="ERR_BadSpecifierCombo2" xml:space="preserve">
    <value>“{0}”不能与“{1}”组合。</value>
  </data>
  <data name="ERR_TooManyGenericArguments1" xml:space="preserve">
    <value>“{0}”的类型参数太多。</value>
  </data>
  <data name="ERR_TooManyGenericArguments2" xml:space="preserve">
    <value>对“{1}”中定义的扩展方法“{0}”而言，类型参数太多。</value>
  </data>
  <data name="ERR_EndProp" xml:space="preserve">
    <value>Property 缺少 "End Property"。</value>
  </data>
  <data name="WRN_OverlappingCatch" xml:space="preserve">
    <value>永远不会到达“Catch”块，因为“{0}”从“{1}”继承。</value>
  </data>
  <data name="WRN_BadChecksumValExtChecksum" xml:space="preserve">
    <value>错误的校验和值、非十六进制数字或奇数个十六进制数字。</value>
  </data>
  <data name="WRN_ReturnTypeAttributeOnWriteOnlyProperty_Title" xml:space="preserve">
    <value>应用于 WriteOnly 属性的返回类型的特性不起作用</value>
  </data>
  <data name="ERR_SubRequiresParenthesesDot" xml:space="preserve">
    <value>此单行语句 lambda 必须括在括号中。例如: (Sub() &lt;语句&gt;).Invoke()</value>
  </data>
  <data name="WRN_MultipleDeclFileExtChecksum" xml:space="preserve">
    <value>已使用另一个 GUID 和校验和值声明了文件名。</value>
  </data>
  <data name="ERR_AddOrRemoveHandlerEvent" xml:space="preserve">
    <value>“AddHandler”或“RemoveHandler”语句事件操作数必须是以点限定的表达式或者是简单的名称。</value>
  </data>
  <data name="ERR_CantHaveWin32ResAndManifest" xml:space="preserve">
    <value>指定的选项冲突: Win32 资源文件；Win32 清单。</value>
  </data>
  <data name="ERR_ZeroDivide" xml:space="preserve">
    <value>计算此表达式时出现被零除的情况。</value>
  </data>
  <data name="WRN_ObjectMathSelectCase" xml:space="preserve">
    <value>在 "Select"、"Case" 语句的表达式中使用了 Object 类型的操作数；可能会发生运行时错误。</value>
  </data>
  <data name="ERR_InvalidInNamespace" xml:space="preserve">
    <value>语句在命名空间中无效。</value>
  </data>
  <data name="ERR_UsingRequiresDisposePattern" xml:space="preserve">
    <value>“{0}”类型的“Using”操作数必须实现“System.IDisposable”。</value>
  </data>
  <data name="ERR_ModuleCantUseTypeSpecifier1" xml:space="preserve">
    <value>模块中的类型不能声明为“{0}”。</value>
  </data>
  <data name="ERR_PartialTypeConstraintMismatch1" xml:space="preserve">
    <value>此类型参数的约束与在“{0}”的某个其他分部类型上定义的相应类型参数的约束不匹配。</value>
  </data>
  <data name="ERR_ConstraintAlreadyExists1" xml:space="preserve">
    <value>已为此类型参数指定了约束类型“{0}”。</value>
  </data>
  <data name="ERR_CatchVariableNotLocal1" xml:space="preserve">
    <value>“{0}”不是局部变量或参数，因此不能用作“Catch”变量。</value>
  </data>
  <data name="CompilationVisualBasic" xml:space="preserve">
    <value>编译(Visual Basic):</value>
  </data>
  <data name="ERR_OnErrorInUsing" xml:space="preserve">
    <value>"On Error" 语句在 "Using" 语句内无效。</value>
  </data>
  <data name="WRN_VarianceConversionFailedTryOut4" xml:space="preserve">
    <value>“{0}”不能转换为“{1}”。考虑在“{3}”的定义中将“{2}”改为 Out 类型参数“Out {2}”。</value>
  </data>
  <data name="WRN_ObjectMath1Not_Title" xml:space="preserve">
    <value>为运算符 &lt;&gt; 使用的 Object 类型的操作数</value>
  </data>
  <data name="ERR_CatchAfterFinally" xml:space="preserve">
    <value>在“Try”语句中，“Catch”不能出现在“Finally”之后。</value>
  </data>
  <data name="ERR_ComClassOnGeneric" xml:space="preserve">
    <value>“Microsoft.VisualBasic.ComClassAttribute”不能应用于属于泛型类型或者包含在泛型类型中的类。</value>
  </data>
  <data name="ERR_AddressOfNotDelegate1" xml:space="preserve">
    <value>“AddressOf”表达式无法转换为“{0} ”，因为“{0}”不是委托类型。</value>
  </data>
  <data name="WRN_ImplicitConversion2" xml:space="preserve">
    <value>从“{0}”到“{1}”的隐式转换。</value>
  </data>
  <data name="ERR_SynchronizedAsyncMethod" xml:space="preserve">
    <value>"MethodImplOptions.Synchronized" 不能应用于异步方法。</value>
  </data>
  <data name="PositionOfTypeParameterTooLarge" xml:space="preserve">
    <value>类型参数的位置太大</value>
  </data>
  <data name="ERR_OperatorNotOverloadable" xml:space="preserve">
    <value>运算符不可重载。运算符声明必须是以下符号之一: +、-、*、\、/、^、&amp;,、Like、Mod、And、Or、Xor、Not、&lt;&lt;、&gt;&gt;、=、&lt;&gt;、&lt;、&lt;=、&gt;、&gt;=、CType、IsTrue 和 IsFalse。</value>
  </data>
  <data name="ERR_BadAwaitNothing" xml:space="preserve">
    <value>不能等待 Nothing。请考虑改为等待“Task.Yield()”。</value>
  </data>
  <data name="ERR_BadInterfaceOrderOnInherits" xml:space="preserve">
    <value>“Inherits”语句必须位于接口中的所有声明之前。</value>
  </data>
  <data name="ERR_BadAwaitNotInAsyncMethodOrLambda" xml:space="preserve">
    <value>仅当其包含方法或 lambda 表达式用“Async”修饰符标记时，才能使用“Await”。</value>
  </data>
  <data name="ERR_StructCantUseDLLDeclareSpecifier1" xml:space="preserve">
    <value>结构中的“Declare”语句不能声明为“{0}”。</value>
  </data>
  <data name="WRN_CLSEventMethodInNonCLSType3" xml:space="preserve">
    <value>事件“{1}”的“{0}”方法不能被标记为符合 CLS，因为它的包含类型“{2}”不符合 CLS。</value>
  </data>
  <data name="ERR_LiteralExpected" xml:space="preserve">
    <value>应为文本。</value>
  </data>
  <data name="ERR_OperatorMustBeShared" xml:space="preserve">
    <value>运算符必须声明为 "Shared"。</value>
  </data>
  <data name="ERR_TwoParametersRequired1" xml:space="preserve">
    <value>运算符“{0}”必须有两个参数。</value>
  </data>
  <data name="ERR_VarianceOutConstraintDisallowed1" xml:space="preserve">
    <value>类型“{0}”不能用作泛型类型约束，因为“{0}”是“Out”类型参数。</value>
  </data>
  <data name="ERR_ResourceInModule" xml:space="preserve">
    <value>生成模块时，无法链接资源文件</value>
  </data>
  <data name="ERR_ExprTreeNoLateBind" xml:space="preserve">
    <value>后期绑定操作无法转换为表达式树。</value>
  </data>
  <data name="ERR_ExpectedEndSyncLock" xml:space="preserve">
    <value>“SyncLock”语句必须以匹配的“End SyncLock”结束。</value>
  </data>
  <data name="ERR_BadGenericParamForNewConstraint2" xml:space="preserve">
    <value>类型参数“{0}”必须具有“New”约束或“Structure”约束，才能满足类型参数“{1}”的“New”约束。</value>
  </data>
  <data name="WRN_XMLDocMoreThanOneCommentBlock" xml:space="preserve">
    <value>每个语言元素只能有一个 XML 注释块。</value>
  </data>
  <data name="DeclarationSyntaxNotWithinSyntaxTree" xml:space="preserve">
    <value>DeclarationSyntax 未在语法树内</value>
  </data>
  <data name="ERR_PrivateTypeOutsideType" xml:space="preserve">
    <value>声明为 "Private" 的类型必须在另一个类型内。</value>
  </data>
  <data name="ERR_MustInheritForNewConstraint2" xml:space="preserve">
    <value>类型实参“{0}”声明为“MustInherit”，并且不满足类型形参“{1}”的“New”约束。</value>
  </data>
  <data name="ERR_ExpectedEndClass" xml:space="preserve">
    <value>“Class”语句必须以匹配的“End Class”结束。</value>
  </data>
  <data name="ERR_ExtensionMethodCannotBeLateBound" xml:space="preserve">
    <value>不支持后期绑定的扩展方法。</value>
  </data>
  <data name="ERR_InvalidMeReference" xml:space="preserve">
    <value>调用另一个构造函数时引用尚未完成的对象是无效的。</value>
  </data>
  <data name="ERR_NamedSubscript" xml:space="preserve">
    <value>命名参数作为数组下标无效。</value>
  </data>
  <data name="ERR_ExpectedEndUsing" xml:space="preserve">
    <value>“Using”必须以匹配的“End Using”结束。</value>
  </data>
  <data name="ERR_ArrayInitForNonArray2" xml:space="preserve">
    <value>数组初始值设定项仅对数组有效，但“{0}”的类型是“{1}”。</value>
  </data>
  <data name="ERR_GeneralProjectImportsError3" xml:space="preserve">
    <value>项目级 import“{0}”中的“{1}”位置出错: {2}</value>
  </data>
  <data name="ERR_ExpectedEndWhile" xml:space="preserve">
    <value>“While”必须以匹配的“End While”结束。</value>
  </data>
  <data name="WRN_ComClassPropertySetObject1" xml:space="preserve">
    <value>“{0}”无法作为属性“Let”向 COM 公开。将无法使用“Let”语句从 Visual Basic 6.0 向该属性分配非对象值(如数字或字符串)。</value>
  </data>
  <data name="ERR_TypeOfRequiresReferenceType1" xml:space="preserve">
    <value>“TypeOf ... Is”要求它的左操作数具有引用类型，但此操作数具有值类型“{0}”。</value>
  </data>
  <data name="WRN_NotEqualToLiteralNothing_Title" xml:space="preserve">
    <value>此表达式的计算结果始终为 Nothing</value>
  </data>
  <data name="ERR_BadWithRef" xml:space="preserve">
    <value>前导“.”或“!”只能出现在“With”语句内。</value>
  </data>
  <data name="ERR_BadAwaitInNonAsyncMethod" xml:space="preserve">
    <value>“Await”只能在异步方法中使用。请考虑使用“Async”修饰符标记此方法，并将其返回类型更改为“Task(Of {0})”。</value>
  </data>
  <data name="ERR_SecurityCriticalAsyncInClassOrStruct" xml:space="preserve">
    <value>在具有“SecurityCritical”或“SecuritySafeCritical”属性的 [Class|Structure|Interface|Module] 中不允许使用 Async 或 Iterator 方法。</value>
  </data>
  <data name="ERR_ParamArrayMustBeLast" xml:space="preserve">
    <value>应为参数列表的结尾。不能在 Paramarray 参数后定义参数。</value>
  </data>
  <data name="ERR_InterfaceNotImplemented1" xml:space="preserve">
    <value>接口“{0}”不是由此类实现的。</value>
  </data>
  <data name="WRN_XMLDocStartTagWithNoEndTag" xml:space="preserve">
    <value>XML 文档分析错误: 开始标记“{0}”没有匹配的结束标记。XML 注释将被忽略。</value>
  </data>
  <data name="ERR_AbsentReferenceToPIA1" xml:space="preserve">
    <value>找不到与嵌入的类型“{0}”匹配的互操作类型。是否缺少程序集引用?</value>
  </data>
  <data name="ERR_InterfaceImplementedTwiceWithDifferentTupleNames3" xml:space="preserve">
    <value>接口“{0}”只能通过此类型实现一次，但已显示有不同的元组元素名称，如“{1}”(通过“{2}”)。</value>
  </data>
  <data name="ERR_InterfaceImplementedTwiceWithDifferentTupleNames2" xml:space="preserve">
    <value>接口“{0}”只能通过此类型实现一次，但已显示有不同的元组元素名称，如“{1}”。</value>
  </data>
  <data name="ERR_InterfaceImplementedTwiceWithDifferentTupleNames4" xml:space="preserve">
    <value>接口“{0}”只能通过此类型实现一次(通过“{1}”)，但已显示有不同的元组元素名称，如“{2}”(通过“{3}”)。</value>
  </data>
  <data name="WRN_VarianceDeclarationAmbiguous3_Title" xml:space="preserve">
    <value>接口对于另一个实现的接口不明确，原因在于 "In" 和 "Out" 参数</value>
  </data>
  <data name="ERR_EventsCantBeFunctions" xml:space="preserve">
    <value>事件不能有返回类型。</value>
  </data>
  <data name="ERR_CantOverride4" xml:space="preserve">
    <value>“{0}”无法重写“{1}”，因为后者未声明为“Overridable”。</value>
  </data>
  <data name="ERR_OverloadWithDefault2" xml:space="preserve">
    <value>“{0}”和“{1}”的差异仅在于可选参数的默认值，因此它们无法重载对方。</value>
  </data>
  <data name="ERR_BadAwaitInNonAsyncLambda" xml:space="preserve">
    <value>“Await”只能用于异步 lambda 表达式中。请考虑用“Async”修饰符标记此 lambda 表达式。</value>
  </data>
  <data name="WRN_VarianceConversionFailedOut6_Title" xml:space="preserve">
    <value>隐式转换；此转换可能失败，原因是目标类型不是从源类型派生的，而这是 "Out" 泛型参数所必需的</value>
  </data>
  <data name="ERR_TooManyIndices" xml:space="preserve">
    <value>索引数超过索引数组的维数。</value>
  </data>
  <data name="WRN_NoConfigInResponseFile_Title" xml:space="preserve">
    <value>/noconfig 选项是在响应文件中指定的，因此被忽略</value>
  </data>
  <data name="ERR_BadConditionalWithRef" xml:space="preserve">
    <value>以 "?" 开头的情况只能出现在“With”语句中，不能出现在对象成员初始值设定项中。</value>
  </data>
  <data name="ERR_MemberConflictWithSynth4" xml:space="preserve">
    <value>与为 {2}“{3}”中的“{1}”隐式声明的“{0}”冲突。</value>
  </data>
  <data name="ERR_OptionalIllegal1" xml:space="preserve">
    <value>“{0}”参数不能声明为“Optional”。</value>
  </data>
  <data name="WRN_DefAsgNoRetValOpVal1_Title" xml:space="preserve">
    <value>运算符没有在所有代码路径上返回值</value>
  </data>
  <data name="ERR_NoGlobalInHandles" xml:space="preserve">
    <value>句柄中不允许 "Global"；应为本地名称。</value>
  </data>
  <data name="WRN_StaticLocalNoInference" xml:space="preserve">
    <value>未使用 "As" 子句声明的静态变量；假定为 Object 类型。</value>
  </data>
  <data name="ERR_UnrecognizedType" xml:space="preserve">
    <value>应为类型。</value>
  </data>
  <data name="ERR_ParamArrayWithOptArgs" xml:space="preserve">
    <value>方法不能同时具有 ParamArray 和 Optional 参数。</value>
  </data>
  <data name="ERR_StructureCantUseProtected" xml:space="preserve">
    <value>Method in a structure cannot be declared 'Protected', 'Protected Friend', or 'Private Protected'.</value>
  </data>
  <data name="WRN_QueryMissingAsClauseinVarDecl" xml:space="preserve">
    <value>假定范围变量属于对象类型，因为无法推断其类型。请使用“As”子句指定不同类型。</value>
  </data>
  <data name="ERR_DuplicateInInherits1" xml:space="preserve">
    <value>“{0}”不能被继承多次。</value>
  </data>
  <data name="ERR_PartialTypeBadMustInherit1" xml:space="preserve">
    <value>“MustInherit”不能为分部类型“{0}”指定，因为它不能与为该类型的某个其他分部类型指定的“NotInheritable”组合。。</value>
  </data>
  <data name="IDS_LangVersions" xml:space="preserve">
    <value>Supported language versions:</value>
  </data>
  <data name="ERR_RemoveParamWrongForWinRT" xml:space="preserve">
    <value>在 Windows Runtime 事件中，“RemoveHandler”方法参数的类型必须为“EventRegistrationToken”</value>
  </data>
  <data name="ERR_MultilineLambdasCannotContainOnError" xml:space="preserve">
    <value>“On Error”和“Resume”不能出现在 lambda 表达式内。</value>
  </data>
  <data name="ERR_DllImportNotLegalOnGetOrSet" xml:space="preserve">
    <value>"System.Runtime.InteropServices.DllImportAttribute" 不能应用于 Get 或 Set。</value>
  </data>
  <data name="ERR_SyncLockRequiresReferenceType1" xml:space="preserve">
    <value>"SyncLock" 操作数不能是“{0}”类型，因为“{0}”不是引用类型。</value>
  </data>
  <data name="WRN_MultipleDeclFileExtChecksum_Title" xml:space="preserve">
    <value>已使用另一个 GUID 和校验和值声明了文件名</value>
  </data>
  <data name="ERR_BadAsyncReturn" xml:space="preserve">
    <value>只能在 Sub 上或者在返回 Task 或 Task(Of T) 的函数上使用 "Async" 修饰符。</value>
  </data>
  <data name="HDN_UnusedImportClause_Title" xml:space="preserve">
    <value>未使用 import 子句</value>
  </data>
  <data name="ERR_RestrictedAccess" xml:space="preserve">
    <value>表达式的类型为“{0}”，这是受限类型，不能用于访问从“Object”或“ValueType”继承的成员。</value>
  </data>
  <data name="ERR_OperatorMustBePublic" xml:space="preserve">
    <value>运算符必须声明为 "Public"。</value>
  </data>
  <data name="ERR_BadInterfaceEnumSpecifier1" xml:space="preserve">
    <value>接口中的枚举不能声明为“{0}”。</value>
  </data>
  <data name="ERR_MultilineLambdaMissingFunction" xml:space="preserve">
    <value>多行 lambda 表达式缺少 "End Function"。</value>
  </data>
  <data name="ERR_IdentityDirectCastForFloat" xml:space="preserve">
    <value>不支持使用 DirectCast 运算符将浮点值强制转换为同一类型。</value>
  </data>
  <data name="ERR_InheritsStmtWrongOrder" xml:space="preserve">
    <value>“Inherits”语句必须位于类中的所有声明之前。</value>
  </data>
  <data name="ERR_NetModuleNameMustBeUnique" xml:space="preserve">
    <value>模块“{0}”已在此程序集中定义。每个模块必须具有唯一的文件名。</value>
  </data>
  <data name="ERR_GotoIntoWith" xml:space="preserve">
    <value>“GoTo {0}”无效，因为“{0}”位于不包含此语句的“With”语句中。</value>
  </data>
  <data name="ERR_UnknownOperator" xml:space="preserve">
    <value>运算符声明必须是以下符号之一: +、-、*、\、/、^、&amp;,、Like、Mod、And、Or、Xor、Not、&lt;&lt;、&gt;&gt;、=、&lt;&gt;、&lt;、&lt;=、&gt;、&gt;=、CType、IsTrue 和 IsFalse。</value>
  </data>
  <data name="ERR_BadUseOfVoid" xml:space="preserve">
    <value>“System.Void”只能在 GetType 表达式中使用。</value>
  </data>
  <data name="ERR_BadEnumFlags1" xml:space="preserve">
    <value>“{0}”在枚举声明中无效。</value>
  </data>
  <data name="ERR_StartAttributeValue" xml:space="preserve">
    <value>应为带引号的 XML 特性值或嵌入式表达式。</value>
  </data>
  <data name="ERR_BadInstanceMemberAccess" xml:space="preserve">
    <value>没有类的显式实例，就无法从共享方法或共享成员初始值设定项中引用该类的实例成员。</value>
  </data>
  <data name="ERR_SubRequiresParenthesesLParen" xml:space="preserve">
    <value>此单行语句 lambda 必须括在括号中。例如: Call (Sub() &lt;语句&gt;) ()</value>
  </data>
  <data name="WRN_XMLDocBadXMLLine_Title" xml:space="preserve">
    <value>XML 注释块必须紧跟它所应用于的语言元素</value>
  </data>
  <data name="ERR_OnErrorInSyncLock" xml:space="preserve">
    <value>"On Error" 语句在 "SyncLock" 语句内无效。</value>
  </data>
  <data name="ERR_TypeParamMissingAsCommaOrRParen" xml:space="preserve">
    <value>应为 "As"、逗号或 ")"。</value>
  </data>
  <data name="ERR_UseOfKeywordFromModule1" xml:space="preserve">
    <value>“{0}”在模块中无效。</value>
  </data>
  <data name="WRN_XMLDocDuplicateXMLNode1_Title" xml:space="preserve">
    <value>具有相同属性的 XML 注释标记在同一个 XML 注释块中出现多次</value>
  </data>
  <data name="ERR_ForCtlVarArraySizesSpecified" xml:space="preserve">
    <value>声明用于循环控制变量的数组时不能使用初始大小的值。</value>
  </data>
  <data name="ERR_MyClassNotInClass" xml:space="preserve">
    <value>"MyClass" 不能在类的外部使用。</value>
  </data>
  <data name="ERR_InvalidFormatSpecifier" xml:space="preserve">
    <value>“{0}”不是有效的格式说明符</value>
  </data>
  <data name="ERR_ModuleCantImplement" xml:space="preserve">
    <value>"Implements" 在模块中无效。</value>
  </data>
  <data name="ERR_DuplicateProcDef1" xml:space="preserve">
    <value>“{0}”具有多个带相同签名的定义。</value>
  </data>
  <data name="ERR_AttributeStmtWrongOrder" xml:space="preserve">
    <value>Assembly 或 Module 特性语句必须位于文件中的任何声明之前。</value>
  </data>
  <data name="WRN_RequiredNonObsoleteNewCall3_Title" xml:space="preserve">
    <value>此 "Sub New" 的第一条语句必须是对 "MyBase.New" 或 "MyClass.New" 的显式调用，原因是基类中的构造函数被标为已过时</value>
  </data>
  <data name="ERR_ArrayInitNoTypeObjectDisallowed" xml:space="preserve">
    <value>无法推断元素类型，且 Option Strict On 不允许假定 "Object"。指定数组的类型可更正此错误。</value>
  </data>
  <data name="ERR_BadFlagsWithDefault1" xml:space="preserve">
    <value>“Default”不能与“{0}”组合。</value>
  </data>
  <data name="ERR_QueryAnonymousTypeFieldNameInference" xml:space="preserve">
    <value>只能从不带参数的简单名或限定名中推断范围变量名。</value>
  </data>
  <data name="ERR_OverrideWithDefault2" xml:space="preserve">
    <value>“{0}”无法重写“{1}”，因为它们在可选参数的默认值上存在差异。</value>
  </data>
  <data name="ERR_SetHasToBeByVal1" xml:space="preserve">
    <value>“Set”参数不能声明为“{0}”。</value>
  </data>
  <data name="ERR_FinallyAfterFinally" xml:space="preserve">
    <value>“Finally”只能在“Try”语句中出现一次。</value>
  </data>
  <data name="ERR_BadCCExpression" xml:space="preserve">
    <value>条件编译表达式中有语法错误。</value>
  </data>
  <data name="WRN_EnumUnderlyingTypeNotCLS1_Title" xml:space="preserve">
    <value>枚举的基础类型不符合 CLS</value>
  </data>
  <data name="ERR_DuplicateParameterSpecifier" xml:space="preserve">
    <value>参数说明符重复。</value>
  </data>
  <data name="ERR_ExitOperatorNotValid" xml:space="preserve">
    <value>"Exit Operator" 无效。请使用 "Return" 从运算符中退出。</value>
  </data>
  <data name="ERR_ComClassGenericMethod" xml:space="preserve">
    <value>泛型方法不能向 COM 公开。</value>
  </data>
  <data name="ERR_ExpectedOptionCompare" xml:space="preserve">
    <value>应为 "Compare"。</value>
  </data>
  <data name="FEATURE_CollectionInitializers" xml:space="preserve">
    <value>集合初始值设定项</value>
  </data>
  <data name="ERR_BadFlagsInNotInheritableClass1" xml:space="preserve">
    <value>“NotInheritable”类不能有声明为“{0}”的成员。</value>
  </data>
  <data name="ERR_FailureSigningAssembly" xml:space="preserve">
    <value>对程序集“{0}”签名时出错: {1}</value>
  </data>
  <data name="ERR_InheritsFromNonClass" xml:space="preserve">
    <value>类只能从其他类继承。</value>
  </data>
  <data name="ERR_EndSelectNoSelect" xml:space="preserve">
    <value>"End Select" 前面必须是匹配的 "Select Case"。</value>
  </data>
  <data name="ERR_InaccessibleReturnTypeOfMember2" xml:space="preserve">
    <value>“{0}”是不可访问的返回类型，因此它在此上下文中不可访问。</value>
  </data>
  <data name="ERR_TypeCharWithType1" xml:space="preserve">
    <value>在具有显式类型的声明中不能使用类型字符“{0}”。</value>
  </data>
  <data name="WRN_DebuggerHiddenIgnoredOnProperties" xml:space="preserve">
    <value>System.Diagnostics.DebuggerHiddenAttribute 在应用于属性定义时不影响“Get”或“Set”。请根据相应的情况，将此特性直接应用于“Get”和“Set”过程。</value>
  </data>
  <data name="ERR_MissingEndSet" xml:space="preserve">
    <value>"Set" 语句必须以匹配的 "End Set" 结束。</value>
  </data>
  <data name="ERR_MissingEndGet" xml:space="preserve">
    <value>"Get" 语句必须以匹配的 "End Get" 结束。</value>
  </data>
  <data name="ERR_IllegalProcessingInstructionName" xml:space="preserve">
    <value>XML 处理指令名称“{0}”无效。</value>
  </data>
  <data name="ERR_NetModuleNameMismatch" xml:space="preserve">
    <value>存储在“{1}”中的模块名“{0}”必须与其文件名匹配。</value>
  </data>
  <data name="PropertiesCanNotHaveTypeArguments" xml:space="preserve">
    <value>属性不能具有类型参数</value>
  </data>
  <data name="ERR_InvInsideEndsProperty" xml:space="preserve">
    <value>语句不能出现在属性体内。假定为属性末尾。</value>
  </data>
  <data name="ERR_NullableImplicit" xml:space="preserve">
    <value>可以为 null 的修饰符不能与隐式类型为 "Object" 的变量一起使用。</value>
  </data>
  <data name="IDS_ProjectSettingsLocationName" xml:space="preserve">
    <value>&lt;项目设置&gt;</value>
  </data>
  <data name="WRN_InvalidVersionFormat" xml:space="preserve">
    <value>指定版本字符串不符合建议格式 - major.minor.build.revision</value>
  </data>
  <data name="CannotAddCompilerSpecialTree" xml:space="preserve">
    <value>无法添加特定于编译器的树</value>
  </data>
  <data name="ERR_TryCastOfValueType1" xml:space="preserve">
    <value>“TryCast”操作数必须是引用类型，但“{0}”是值类型。</value>
  </data>
  <data name="SyntaxTreeNotFoundToRemove" xml:space="preserve">
    <value>未找到要删除的 SyntaxTree“{0}”。</value>
  </data>
  <data name="ERR_InvalidMe" xml:space="preserve">
    <value>"Me" 不能作为赋值目标。</value>
  </data>
  <data name="WRN_IfTooManyTypesObjectAssumed_Title" xml:space="preserve">
    <value>无法推断通用类型，原因是可能存在多个类型</value>
  </data>
  <data name="WRN_EmptyPrefixAndXmlnsLocalName" xml:space="preserve">
    <value>xmlns 特性具有特殊含义，不应使用前缀进行编写。</value>
  </data>
  <data name="ERR_ExpectedEndNamespace" xml:space="preserve">
    <value>“Namespace”语句必须以匹配的“End Namespace”结束。</value>
  </data>
  <data name="WRN_UndefinedOrEmptyProjectNamespaceOrClass1" xml:space="preserve">
    <value>项目级 Imports“{0}”中指定的命名空间或类型不包含任何公共成员，或者找不到公共成员。要确保定义了该命名空间或类型且其中至少包含一个公共成员；还要确保导入的元素名不使用任何别名。</value>
  </data>
  <data name="WRN_UnusedLocalConst" xml:space="preserve">
    <value>未使用的局部常量:“{0}”。</value>
  </data>
  <data name="ERR_CannotLiftAnonymousType1" xml:space="preserve">
    <value>不能在同一个初始化列表中的 lambda 表达式定义中使用匿名类型属性“{0}”。</value>
  </data>
  <data name="ERR_MissingEndAddHandler" xml:space="preserve">
    <value>"AddHandler" 声明必须以匹配的 "End AddHandler" 结束。</value>
  </data>
  <data name="ERR_TypeCharOnSub" xml:space="preserve">
    <value>"Sub" 不返回值，因此在 "Sub" 声明中不能使用类型字符。</value>
  </data>
  <data name="ERR_VarianceOutNullableDisallowed2" xml:space="preserve">
    <value>类型“{0}”不能用于“{1}”，因为“In”和“Out”类型参数不能设置为可以为 null，并且“{0}”是“Out”类型参数。</value>
  </data>
  <data name="ERR_RecordEmbeds2" xml:space="preserve">
    <value>
  “{0}”包含“{1}”(变量“{2}”)。</value>
  </data>
  <data name="WRN_IgnoreModuleManifest" xml:space="preserve">
    <value>已忽略选项 /win32manifest。只有在目标是程序集时才能指定该选项。</value>
  </data>
  <data name="WRN_ObjectAssumedVar1" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="ERR_ExpectedContinueKind" xml:space="preserve">
    <value>“Continue”的后面必须跟有“Do”、“For”或“While”。</value>
  </data>
  <data name="ERR_MultipleOptionalParameterSpecifiers" xml:space="preserve">
    <value>"Optional" 不能与 "ParamArray" 组合。</value>
  </data>
  <data name="ERR_ExpectedEndStructure" xml:space="preserve">
    <value>“Structure”语句必须以匹配的“End Structure”结束。</value>
  </data>
  <data name="ERR_PredefinedValueTupleTypeMustBeStruct" xml:space="preserve">
    <value>预定义的类型“{0}”必须是一种结构。</value>
  </data>
  <data name="ERR_DefaultPropertyAmbiguousAcrossInterfaces4" xml:space="preserve">
    <value>默认属性访问在接口“{1}”的继承接口成员“{0}”和接口“{3}”的继承接口成员“{2}”之间不明确。</value>
  </data>
  <data name="ERR_DelegateCantHandleEvents" xml:space="preserve">
    <value>委托无法处理事件。</value>
  </data>
  <data name="ERR_BadYieldInNonIteratorMethod" xml:space="preserve">
    <value>只能在用“Iterator”修饰符标记的方法中使用“Yield”。</value>
  </data>
  <data name="WRN_ShadowingGenericParamWithParam1" xml:space="preserve">
    <value>类型参数“{0}”与封闭类型的类型参数同名。封闭类型的类型参数将被隐藏。</value>
  </data>
  <data name="WRN_SelectCaseInvalidRange_Title" xml:space="preserve">
    <value>为 "Case" 语句指定的范围无效</value>
  </data>
  <data name="ERR_DllImportNotLegalOnDeclare" xml:space="preserve">
    <value>"System.Runtime.InteropServices.DllImportAttribute" 不能应用于 Declare。</value>
  </data>
  <data name="ERR_ExitWhileNotWithinWhile" xml:space="preserve">
    <value>"Exit While" 只能出现在 "While" 语句内。</value>
  </data>
  <data name="ERR_InterfaceUnifiesWithInterface2" xml:space="preserve">
    <value>无法继承接口“{0}”，因为对于某些类型参数，该接口与接口“{1}”相同。</value>
  </data>
  <data name="ERR_ConflictDefaultPropertyAttribute" xml:space="preserve">
    <value>默认属性与“{0}”上定义的“DefaultMemberAttribute”之间有冲突。</value>
  </data>
  <data name="ERR_NoXmlAxesLateBinding" xml:space="preserve">
    <value>XML 轴属性不支持后期绑定。</value>
  </data>
  <data name="WRN_AnalyzerCannotBeCreated_Title" xml:space="preserve">
    <value>无法创建分析器实例</value>
  </data>
  <data name="ERR_TypeParamQualifierDisallowed" xml:space="preserve">
    <value>类型参数不能用作限定符。</value>
  </data>
  <data name="ERR_BadIteratorReturn" xml:space="preserve">
    <value>迭代器函数必须返回 IEnumerable(Of T) 或 IEnumerator(Of T)，或返回非泛型格式的 IEnumerable 或 IEnumerator。</value>
  </data>
  <data name="ERR_ExitFuncOfSub" xml:space="preserve">
    <value>"Exit Function" 在 Sub 或属性中无效。</value>
  </data>
  <data name="ERR_OpenTypeDisallowed" xml:space="preserve">
    <value>特性实参中不允许类型形参或用类型形参构造的类型。</value>
  </data>
  <data name="ERR_AttributeCannotBeAbstract" xml:space="preserve">
    <value>“{0}”已声明为“MustInherit”，因此不能用作属性。</value>
  </data>
  <data name="ERR_InheritsFromCantInherit3" xml:space="preserve">
    <value>“{1}”已声明为“NotInheritable”，因此“{0}”无法从 {2}“{1}”继承。</value>
  </data>
  <data name="TypeParameterNotWithinTree" xml:space="preserve">
    <value>TypeParameter 不在树中</value>
  </data>
  <data name="ERR_PublicSignNoKey" xml:space="preserve">
    <value>已指定公共符号并且它需要一个公钥，但未指定任何公钥</value>
  </data>
  <data name="WRN_MustShadowOnMultipleInheritance2_Title" xml:space="preserve">
    <value>方法与继承层次结构中的其他同名成员冲突，因此应声明为 "Shadows"</value>
  </data>
  <data name="ERR_ObsoleteExponent" xml:space="preserve">
    <value>"D" 不能再用来表示指数；请改用 "E"。</value>
  </data>
  <data name="ERR_MissingSubscript" xml:space="preserve">
    <value>缺少数组下标表达式。</value>
  </data>
  <data name="WRN_XMLDocExceptionTagWithoutCRef" xml:space="preserve">
    <value>XML 注释异常必须具有 "cref" 属性。</value>
  </data>
  <data name="PositionNotWithinTree" xml:space="preserve">
    <value>位置必须处于语法树范围内。</value>
  </data>
  <data name="ERR_PropMustHaveGetSet" xml:space="preserve">
    <value>不带 "ReadOnly" 或 "WriteOnly" 说明符的属性必须同时提供 "Get" 和 "Set"。</value>
  </data>
  <data name="ERR_CannotLiftRestrictedTypeLambda" xml:space="preserve">
    <value>不能在 lambda 表达式中使用受限类型“{0}”的实例。</value>
  </data>
  <data name="ERR_ExecutableAsDeclaration" xml:space="preserve">
    <value>语句不能出现在方法体外。</value>
  </data>
  <data name="ERR_ForwardedTypeUnavailable3" xml:space="preserve">
    <value>程序集“{1}”中的类型“{0}”已转发到程序集“{2}”。您的项目中缺少对“{2}”的引用或者程序集中“{2}”缺少类型“{0}”。</value>
  </data>
  <data name="ERR_UnsupportedProperty1" xml:space="preserve">
    <value>属性“{0}”的类型不受支持。</value>
  </data>
  <data name="ERR_OverrideWithArrayVsParamArray2" xml:space="preserve">
    <value>“{0}”无法重写“{1}”，因为它们在声明为“ParamArray”的参数上存在差异。</value>
  </data>
  <data name="ERR_EventNoPIANoBackingMember" xml:space="preserve">
    <value>源接口“{0}”缺少方法“{2}”，此方法对嵌入事件“{1}”是必需的。</value>
  </data>
  <data name="ERR_DuplicateXmlAttribute" xml:space="preserve">
    <value>重复的 XML 属性“{0}”。</value>
  </data>
  <data name="ERR_SharedMemberAggrMemberInit1" xml:space="preserve">
    <value>无法在对象初始值设定项表达式中初始化成员“{0}”，因为它是共享的。</value>
  </data>
  <data name="ERR_UseOfObsoleteSymbol2" xml:space="preserve">
    <value>“{0}”已过时:“{1}”。</value>
  </data>
  <data name="ERR_InvalidSpecifierOnNonConversion1" xml:space="preserve">
    <value>只有转换运算符可以声明为“{0}”。</value>
  </data>
  <data name="ERR_IsNotOpRequiresReferenceTypes1" xml:space="preserve">
    <value>“IsNot”要求具有引用类型的操作数,但此操作数的值类型为“{0}”。</value>
  </data>
  <data name="ERR_MissingIsInTypeOf" xml:space="preserve">
    <value>应为 "Is"。</value>
  </data>
  <data name="IDS_VBCHelp" xml:space="preserve">
    <value>                  Visual Basic Compiler Options

                                  - OUTPUT FILE -
/out:&lt;file&gt;                       Specifies the output file name.
/target:exe                       Create a console application (default). 
                                  (Short form: /t)
/target:winexe                    Create a Windows application.
/target:library                   Create a library assembly.
/target:module                    Create a module that can be added to an 
                                  assembly.
/target:appcontainerexe           Create a Windows application that runs in 
                                  AppContainer.
/target:winmdobj                  Create a Windows Metadata intermediate file
/doc[+|-]                         Generates XML documentation file.
/doc:&lt;file&gt;                       Generates XML documentation file to &lt;file&gt;.
/refout:&lt;file&gt;                    Reference assembly output to generate

                                  - INPUT FILES -
/addmodule:&lt;file_list&gt;            Reference metadata from the specified modules
/link:&lt;file_list&gt;                 Embed metadata from the specified interop 
                                  assembly. (Short form: /l)
/recurse:&lt;wildcard&gt;               Include all files in the current directory 
                                  and subdirectories according to the
                                  wildcard specifications.
/reference:&lt;file_list&gt;            Reference metadata from the specified 
                                  assembly. (Short form: /r)
/analyzer:&lt;file_list&gt;             Run the analyzers from this assembly
                                  (Short form: /a)
/additionalfile:&lt;file list&gt;       Additional files that don't directly affect code
                                  generation but may be used by analyzers for producing
                                  errors or warnings.

                                  - RESOURCES -
/linkresource:&lt;resinfo&gt;           Links the specified file as an external 
                                  assembly resource.
                                  resinfo:&lt;file&gt;[,&lt;name&gt;[,public|private]] 
                                  (Short form: /linkres)
/nowin32manifest                  The default manifest should not be embedded 
                                  in the manifest section of the output PE.
/resource:&lt;resinfo&gt;               Adds the specified file as an embedded 
                                  assembly resource.
                                  resinfo:&lt;file&gt;[,&lt;name&gt;[,public|private]] 
                                  (Short form: /res)
/win32icon:&lt;file&gt;                 Specifies a Win32 icon file (.ico) for the 
                                  default Win32 resources.
/win32manifest:&lt;file&gt;             The provided file is embedded in the manifest
                                  section of the output PE.
/win32resource:&lt;file&gt;             Specifies a Win32 resource file (.res).

                                  - CODE GENERATION -
/optimize[+|-]                    Enable optimizations.
/removeintchecks[+|-]             Remove integer checks. Default off.
/debug[+|-]                       Emit debugging information.
/debug:full                       Emit full debugging information (default).
/debug:pdbonly                    Emit full debugging information.
/debug:portable                   Emit cross-platform debugging information.
/debug:embedded                   Emit cross-platform debugging information into 
                                  the target .dll or .exe.
/deterministic                    Produce a deterministic assembly
                                  (including module version GUID and timestamp)
/refonly                          Produce a reference assembly in place of the main output
/instrument:TestCoverage          Produce an assembly instrumented to collect
                                  coverage information
/sourcelink:&lt;file&gt;                Source link info to embed into PDB.

                                  - ERRORS AND WARNINGS -
/nowarn                           Disable all warnings.
/nowarn:&lt;number_list&gt;             Disable a list of individual warnings.
/warnaserror[+|-]                 Treat all warnings as errors.
/warnaserror[+|-]:&lt;number_list&gt;   Treat a list of warnings as errors.
/ruleset:&lt;file&gt;                   Specify a ruleset file that disables specific
                                  diagnostics.
/errorlog:&lt;file&gt;                  Specify a file to log all compiler and analyzer
                                  diagnostics.
/reportanalyzer                   Report additional analyzer information, such as
                                  execution time.

                                  - LANGUAGE -
/define:&lt;symbol_list&gt;             Declare global conditional compilation 
                                  symbol(s). symbol_list:name=value,... 
                                  (Short form: /d)
/imports:&lt;import_list&gt;            Declare global Imports for namespaces in 
                                  referenced metadata files. 
                                  import_list:namespace,...
/langversion:?                    Display the allowed values for language version
/langversion:&lt;string&gt;             Specify language version such as
                                  `default` (latest major version), or
                                  `latest` (latest version, including minor versions),
                                  or specific versions like `14` or `15.3`
/optionexplicit[+|-]              Require explicit declaration of variables.
/optioninfer[+|-]                 Allow type inference of variables.
/rootnamespace:&lt;string&gt;           Specifies the root Namespace for all type 
                                  declarations.
/optionstrict[+|-]                Enforce strict language semantics.
/optionstrict:custom              Warn when strict language semantics are not
                                  respected.
/optioncompare:binary             Specifies binary-style string comparisons.
                                  This is the default.
/optioncompare:text               Specifies text-style string comparisons.

                                  - MISCELLANEOUS -
/help                             Display this usage message. (Short form: /?)
/noconfig                         Do not auto-include VBC.RSP file.
/nologo                           Do not display compiler copyright banner.
/quiet                            Quiet output mode.
/verbose                          Display verbose messages.
/parallel[+|-]                    Concurrent build. 
/version                          Display the compiler version number and exit.

                                  - ADVANCED -
/baseaddress:&lt;number&gt;             The base address for a library or module 
                                  (hex).
/checksumalgorithm:&lt;alg&gt;          Specify algorithm for calculating source file 
                                  checksum stored in PDB. Supported values are:
                                  SHA1 (default) or SHA256.
/codepage:&lt;number&gt;                Specifies the codepage to use when opening 
                                  source files.
/delaysign[+|-]                   Delay-sign the assembly using only the public
                                  portion of the strong name key.
/publicsign[+|-]                  Public-sign the assembly using only the public
                                  portion of the strong name key.
/errorreport:&lt;string&gt;             Specifies how to handle internal compiler
                                  errors; must be prompt, send, none, or queue
                                  (default).
/filealign:&lt;number&gt;               Specify the alignment used for output file 
                                  sections.
/highentropyva[+|-]               Enable high-entropy ASLR.
/keycontainer:&lt;string&gt;            Specifies a strong name key container.
/keyfile:&lt;file&gt;                   Specifies a strong name key file.
/libpath:&lt;path_list&gt;              List of directories to search for metadata 
                                  references. (Semi-colon delimited.)
/main:&lt;class&gt;                     Specifies the Class or Module that contains 
                                  Sub Main. It can also be a Class that 
                                  inherits from System.Windows.Forms.Form. 
                                  (Short form: /m)
/moduleassemblyname:&lt;string&gt;      Name of the assembly which this module will 
                                  be a part of.
/netcf                            Target the .NET Compact Framework.
/nostdlib                         Do not reference standard libraries 
                                  (system.dll and VBC.RSP file).
/pathmap:&lt;K1&gt;=&lt;V1&gt;,&lt;K2&gt;=&lt;V2&gt;,...
                                  Specify a mapping for source path names output by
                                  the compiler.
/platform:&lt;string&gt;                Limit which platforms this code can run on; 
                                  must be x86, x64, Itanium, arm,
                                  AnyCPU32BitPreferred or anycpu (default).
/preferreduilang                  Specify the preferred output language name.
/sdkpath:&lt;path&gt;                   Location of the .NET Framework SDK directory
                                  (mscorlib.dll).
/subsystemversion:&lt;version&gt;       Specify subsystem version of the output PE. 
                                  version:&lt;number&gt;[.&lt;number&gt;]
/utf8output[+|-]                  Emit compiler output in UTF8 character 
                                  encoding.
@&lt;file&gt;                           Insert command-line settings from a text file
/vbruntime[+|-|*]                 Compile with/without the default Visual Basic
                                  runtime.
/vbruntime:&lt;file&gt;                 Compile with the alternate Visual Basic 
                                  runtime in &lt;file&gt;.
</value>
  </data>
  <data name="ERR_ReturnFromNonGenericTaskAsync" xml:space="preserve">
    <value>此异步方法中的 "Return" 语句无法返回值，因为函数的返回类型为 "Task" 。请考虑将函数的返回类型更改为 "Task(Of T)"。</value>
  </data>
  <data name="ERR_MissingEndRaiseEvent" xml:space="preserve">
    <value>"RaiseEvent" 声明必须以匹配的 "End RaiseEvent" 结束。</value>
  </data>
  <data name="ERR_OverrideWithConstraintMismatch2" xml:space="preserve">
    <value>“{0}”无法重写“{1}”，因为它们在类型参数约束上存在差异。</value>
  </data>
  <data name="ERR_ExpectedNamedArgument" xml:space="preserve">
    <value>Named argument expected. Please use language version {0} or greater to use non-trailing named arguments.</value>
  </data>
  <data name="ERR_CircularEvaluation1" xml:space="preserve">
    <value>常量“{0}”不能依赖自身的值。</value>
  </data>
  <data name="WRN_MainIgnored_Title" xml:space="preserve">
    <value>程序的入口点是全局脚本代码；正在忽略入口点</value>
  </data>
  <data name="WRN_XMLDocCrefToTypeParameter_Title" xml:space="preserve">
    <value>XML 注释包含的一个标记具有绑定到类型参数的 "cref" 属性</value>
  </data>
  <data name="SubmissionCanHaveAtMostOneSyntaxTree" xml:space="preserve">
    <value>提交最多可以具有一个语法树。</value>
  </data>
  <data name="ERR_XmlEntityReference" xml:space="preserve">
    <value>不支持 XML 实体引用。</value>
  </data>
  <data name="ERR_ContinueForNotWithinFor" xml:space="preserve">
    <value>“Continue For”只能出现在“For”语句内。</value>
  </data>
  <data name="ERR_ResumablesCannotContainOnError" xml:space="preserve">
    <value>"On Error" 和 "Resume" 不能出现在异步方法或迭代器方法内。</value>
  </data>
  <data name="ERR_TypeCharOnAggregation" xml:space="preserve">
    <value>聚合函数名不能与类型字符一起使用。</value>
  </data>
  <data name="ERR_DoubleToDateConversion" xml:space="preserve">
    <value>从 "Double" 到 "Date" 的转换需要调用 "Date.FromOADate" 方法。</value>
  </data>
  <data name="WRN_CLSAttrInvalidOnGetSet" xml:space="preserve">
    <value>System.CLSCompliantAttribute 不能应用于属性 "Get" 或 "Set"。</value>
  </data>
  <data name="WRN_DuplicateCatch" xml:space="preserve">
    <value>永远不会到达“Catch”块；“{0}”已在上面同一个 Try 语句中处理。</value>
  </data>
  <data name="ERR_VarianceOutWriteOnlyPropertyDisallowed1" xml:space="preserve">
    <value>类型“{0}”不能用作 ReadOnly 属性类型，因为“{0}”是“Out”类型参数。</value>
  </data>
  <data name="ERR_InvalidSwitchValue" xml:space="preserve">
    <value>值“{1}”对选项“{0}”无效</value>
  </data>
  <data name="ERR_OverloadingPropertyKind2" xml:space="preserve">
    <value>“{0}” 和“{1}”的差异仅在于“ReadOnly”和“WriteOnly”，因此它们无法重载对方。</value>
  </data>
  <data name="ERR_MustBeOverloads2" xml:space="preserve">
    <value>{0}“{1}”必须声明为“Overloads”，因为另一个“{1}”声明为“Overloads”或“Overrides”。</value>
  </data>
  <data name="FEATURE_StatementLambdas" xml:space="preserve">
    <value>多行 lambda 表达式</value>
  </data>
  <data name="WRN_CLSEventMethodInNonCLSType3_Title" xml:space="preserve">
    <value>事件的 AddHandler 方法或 RemoveHandler 方法无法标记为符合 CLS，原因是它的包含类型不符合 CLS</value>
  </data>
  <data name="ERR_ReservedXmlPrefix" xml:space="preserve">
    <value>XML 命名空间前缀“{0}”已保留供 XML 使用，并且命名空间 URI 不能更改。</value>
  </data>
  <data name="ERR_NoRefOutWhenRefOnly" xml:space="preserve">
    <value>不要在使用 refonly 时使用 refout。</value>
  </data>
  <data name="ERR_ModuleEmitFailure" xml:space="preserve">
    <value>未能发出模块“{0}”。</value>
  </data>
  <data name="ERR_ComClassReservedDispId1" xml:space="preserve">
    <value>“Microsoft.VisualBasic.ComClassAttribute”保留的值小于零，因此“System.Runtime.InteropServices.DispIdAttribute”不能应用于“{0}”。</value>
  </data>
  <data name="ERR_LoopNoMatchingDo" xml:space="preserve">
    <value>"Loop" 前面必须是匹配的 "Do"。</value>
  </data>
  <data name="ERR_ArrayInitTooManyTypesObjectDisallowed" xml:space="preserve">
    <value>无法推断元素类型，因为可能存在多个类型。指定数组的类型可更正此错误。</value>
  </data>
  <data name="ERR_QueryAnonymousTypeDisallowsTypeChar" xml:space="preserve">
    <value>在范围变量声明中不能使用类型字符。</value>
  </data>
  <data name="ERR_ExtensionMethodUncallable1" xml:space="preserve">
    <value>扩展方法“{0}”具有无法满足的类型约束。</value>
  </data>
  <data name="ERR_ExitEventMemberNotInvalid" xml:space="preserve">
    <value>"Exit AddHandler"、"Exit RemoveHandler" 和 "Exit RaiseEvent" 无效。请使用 "Return" 从事件成员中退出。</value>
  </data>
  <data name="ERR_BinaryOperandsForXml4" xml:space="preserve">
    <value>没有为类型“{1}”和“{2}”定义运算符“{0}”。可使用“Value”属性来获取“{3}”的第一个元素的字符串值。</value>
  </data>
  <data name="ERR_SubDisallowsStatement" xml:space="preserve">
    <value>该语句在单行语句 lambda 中无效。</value>
  </data>
  <data name="ERR_ConstraintClashIndirectIndirect4" xml:space="preserve">
    <value>从类型参数约束“{1}”获得的间接约束“{0}”与从类型参数约束“{3}”获得的间接约束“{2}”冲突。</value>
  </data>
  <data name="WRN_DebuggerHiddenIgnoredOnProperties_Title" xml:space="preserve">
    <value>在应用到属性定义时，System.Diagnostics.DebuggerHiddenAttribute 不影响 "Get" 或 "Set"</value>
  </data>
  <data name="WRN_PdbLocalNameTooLong_Title" xml:space="preserve">
    <value>本地名称对 PDB 而言太长</value>
  </data>
  <data name="ERR_TryCastOfUnconstrainedTypeParam1" xml:space="preserve">
    <value>“TryCast”操作数必须是类约束类型参数，但“{0}”没有类约束。</value>
  </data>
  <data name="FEATURE_ReadonlyAutoProperties" xml:space="preserve">
    <value>自动实现的只读属性</value>
  </data>
  <data name="FEATURE_TypeOfIsNot" xml:space="preserve">
    <value>TypeOf IsNot 表达式</value>
  </data>
  <data name="ERR_NestedExternalSource" xml:space="preserve">
    <value>"#ExternalSource" 指令不能嵌套。</value>
  </data>
  <data name="WRN_Experimental_Title" xml:space="preserve">
    <value>类型仅用于评估，在将来的更新中可能会被更改或删除。</value>
  </data>
  <data name="ERR_ObjectInitializerRequiresFieldName" xml:space="preserve">
    <value>对象初始值设定项需要一个字段名称以便进行初始化。</value>
  </data>
  <data name="ERR_ImplementingInterfaceWithDifferentTupleNames5" xml:space="preserve">
    <value>“{0}”不能在接口“{3}”上实现{1}“{2}”，因为“{4}”中的元组元素名称与“{5}”中的名称不匹配。</value>
  </data>
  <data name="ERR_ExpectedSpecifier" xml:space="preserve">
    <value>应为“Dim”、“Const”、“Public”、“Private”、“Protected”、“Friend”、“Shadows”、“ReadOnly”或“Shared”中的一个。</value>
  </data>
  <data name="ERR_OverloadsModifierInModule" xml:space="preserve">
    <value>模块中不恰当地使用了“{0}”关键字。</value>
  </data>
  <data name="ERR_QualifiedNameNotAllowed" xml:space="preserve">
    <value>不允许使用 ":"。不能在此上下文中使用 XML 限定名称。</value>
  </data>
  <data name="ERR_NoConstituentArraySizes" xml:space="preserve">
    <value>初始化数组的数组时，只能指定顶级数组的界限。</value>
  </data>
  <data name="ERR_InvalidModuleAttribute1" xml:space="preserve">
    <value>属性“{0}”不能应用于模块。</value>
  </data>
  <data name="ERR_NestedGlobalNamespace" xml:space="preserve">
    <value>全局命名空间不能嵌套在另一个命名空间中。</value>
  </data>
  <data name="ERR_SyntaxInCastOp" xml:space="preserve">
    <value>强制转换运算符中有语法错误；需要两个用逗号分隔的参数。</value>
  </data>
  <data name="ERR_ElseIfNoMatchingIf" xml:space="preserve">
    <value>"ElseIf" 前面必须是匹配的 "If" 或 "ElseIf"。</value>
  </data>
  <data name="ERR_FriendAssemblyStrongNameRequired" xml:space="preserve">
    <value>友元程序集引用“{0}”无效。强名称签名的程序集必须在其 InternalsVisibleTo 声明中指定一个公钥。</value>
  </data>
  <data name="ERR_LambdaParamShadowLocal1" xml:space="preserve">
    <value>Lambda 参数“{0}”隐藏封闭块中的某个变量、以前定义的某个范围变量或者在查询表达式中隐式声明的某个变量。</value>
  </data>
  <data name="ERR_OverrideWithOptionalTypes2" xml:space="preserve">
    <value>“{0}”无法重写“{1}”，因为它们在可选参数类型上存在差异。</value>
  </data>
  <data name="ERR_ObsoleteObjectNotVariant" xml:space="preserve">
    <value>"Variant" 不再是受支持的类型；请改用 "Object" 类型。</value>
  </data>
  <data name="ERR_InterfaceNotExpression1" xml:space="preserve">
    <value>“{0}”是一个接口类型，不能用作表达式。</value>
  </data>
  <data name="WRN_XMLDocCrefAttributeNotFound1_Title" xml:space="preserve">
    <value>XML 注释包含具有无法解析的 "cref" 属性的标记</value>
  </data>
  <data name="WRN_ObjectMathSelectCase_Title" xml:space="preserve">
    <value>"Select"、"Case" 语句的表达式中使用的 Object 类型的操作数</value>
  </data>
  <data name="WRN_DefaultnessShadowed4" xml:space="preserve">
    <value>默认属性“{0}”与基 {2}“{3}”中的默认属性“{1}”冲突。“{0}”将成为默认属性。“{0}”应声明为“Shadows”。</value>
  </data>
  <data name="ERR_GenericConstraintNotSatisfied2" xml:space="preserve">
    <value>类型参数“{0}”不能继承自或实现约束类型“{1}”。</value>
  </data>
  <data name="ERR_ReadOnlyNoAccessorFlag" xml:space="preserve">
    <value>"ReadOnly" 属性在 "Get" 上不能有访问修饰符。</value>
  </data>
  <data name="ERR_MissingVersionInXmlDecl" xml:space="preserve">
    <value>XML 声明中缺少必需的特性 "version"。</value>
  </data>
  <data name="ERR_MarshalUnmanagedTypeOnlyValidForFields" xml:space="preserve">
    <value>非托管类型“{0}”仅对字段有效。</value>
  </data>
  <data name="ERR_VarianceInByRefDisallowed1" xml:space="preserve">
    <value>类型“{0}”不能用于此上下文，因为“In”和“Out”类型参数不能用于 ByRef 参数类型，且“{0}”是“In”类型参数。</value>
  </data>
  <data name="ERR_PartialMethodDefaultParameterValueMismatch2" xml:space="preserve">
    <value>方法“{0}”的可选参数没有与分部方法“{1}”的相应参数相同的默认值。</value>
  </data>
  <data name="ERR_ObsoleteLineNumbersAreLabels" xml:space="preserve">
    <value>数字标签后面必须跟冒号。</value>
  </data>
  <data name="ERR_OnlyOneAccessorForGetSet" xml:space="preserve">
    <value>访问修饰符只能用于 "Get" 或者 "Set"，但不能同时用于这二者。</value>
  </data>
  <data name="ERR_QueryDuplicateAnonTypeMemberName1" xml:space="preserve">
    <value>已声明范围变量“{0}”。</value>
  </data>
  <data name="ERR_IllegalCallOrIndex" xml:space="preserve">
    <value>非法的调用表达式或索引表达式。</value>
  </data>
  <data name="ERR_ConversionToBaseType" xml:space="preserve">
    <value>转换运算符不能从某一类型转换为它的基类型。</value>
  </data>
  <data name="ERR_CantRaiseBaseEvent" xml:space="preserve">
    <value>派生类不能引发基类事件。</value>
  </data>
  <data name="ERR_AttrCannotBeGenerics" xml:space="preserve">
    <value>类型参数、泛型类型或泛型类型中包含的类型不能用作特性。</value>
  </data>
  <data name="ERR_CantSpecifyNullableOnBoth" xml:space="preserve">
    <value>不能在变量及其类型上同时指定可以为 null 的修饰符。</value>
  </data>
  <data name="ERR_UndefinedTypeOrNamespace1" xml:space="preserve">
    <value>未定义类型或命名空间“{0}”。</value>
  </data>
  <data name="ERR_PartialMethodGenericConstraints2" xml:space="preserve">
    <value>方法“{0}”没有与分部方法“{1}”相同的泛型约束。</value>
  </data>
  <data name="ERR_LateBoundOverloadInterfaceCall1" xml:space="preserve">
    <value>后期绑定重载决策不能应用于“{0}”，因为访问实例是一个接口类型。</value>
  </data>
  <data name="ERR_WriteOnlyHasGet" xml:space="preserve">
    <value>声明为 "WriteOnly" 的属性不能有 "Get"。</value>
  </data>
  <data name="ERR_RestrictedConversion1" xml:space="preserve">
    <value>类型“{0}”的表达式无法转换为“Object”或“ValueType”。</value>
  </data>
  <data name="ERR_SecurityAttributeInvalidActionAssembly" xml:space="preserve">
    <value>SecurityAction 值“{0}”对应用于程序集的安全属性无效。</value>
  </data>
  <data name="ERR_DuplicateAnonTypeMemberName1" xml:space="preserve">
    <value>已声明匿名类型成员或属性“{0}”。</value>
  </data>
  <data name="WRN_AssemblyGeneration1_Title" xml:space="preserve">
    <value>生成程序集时检测到可能的问题</value>
  </data>
  <data name="ERR_IllegalChar" xml:space="preserve">
    <value>字符无效。</value>
  </data>
  <data name="WRN_ExpectedInitComponentCall2" xml:space="preserve">
    <value>设计器生成的类型“{1}”中的“{0}”应调用 InitializeComponent 方法。</value>
  </data>
  <data name="WRN_NoAnalyzerInAssembly" xml:space="preserve">
    <value>程序集 {0} 不包含任何分析器。</value>
  </data>
  <data name="ERR_QualNotObjectRecord1" xml:space="preserve">
    <value>“!”要求其左操作数具有类型参数、类或接口类型，但此操作数的类型为“{0}”。</value>
  </data>
  <data name="WRN_XMLDocBadXMLLine" xml:space="preserve">
    <value>XML 注释块必须紧挨着它应用于的语言元素的前面。XML 注释将被忽略。</value>
  </data>
  <data name="FTL_InputFileNameTooLong" xml:space="preserve">
    <value>文件名“{0}”为空、包含无效字符、未使用绝对路径指定驱动器或太长</value>
  </data>
  <data name="ERR_ModulesCannotBeGeneric" xml:space="preserve">
    <value>模块不能是泛型的。</value>
  </data>
  <data name="ERR_BadLanguageVersion" xml:space="preserve">
    <value>提供的语言版本不受支持或无效:“{0}”。</value>
  </data>
  <data name="ERR_ParamTypingInconsistency" xml:space="preserve">
    <value>如果任何一个参数已显式类型化，则所有参数都必须显式类型化。</value>
  </data>
  <data name="ERR_NoDirectDelegateConstruction1" xml:space="preserve">
    <value>委托“{0}”需要使用一个“AddressOf”表达式或 lambda 表达式作为其构造函数的唯一参数。</value>
  </data>
  <data name="WRN_UnobservedAwaitableDelegate_Title" xml:space="preserve">
    <value>自此 Async Function 返回的任务将被丢弃，它包含的任何异常也将被忽略</value>
  </data>
  <data name="ERR_ArrayInitializerForNonConstDim" xml:space="preserve">
    <value>无法为不定维度指定数组初始值设定项；请使用空初始值设定项“{}”。</value>
  </data>
  <data name="ERR_OverloadWithOptional2" xml:space="preserve">
    <value>“{0}” 和“{1}”的差异仅在于可选参数，因此它们无法重载对方。</value>
  </data>
  <data name="ERR_InvalidUseOfCustomModifier" xml:space="preserve">
    <value>"Custom" 修饰符只能在紧靠 "Event" 声明之前使用。</value>
  </data>
  <data name="ERR_MultiplyDefinedType3" xml:space="preserve">
    <value>“{0}”已在此 {2} 中声明为“{1}”。</value>
  </data>
  <data name="ERR_InterfaceCycle1" xml:space="preserve">
    <value>接口“{0}”不能从自身继承: {1}</value>
  </data>
  <data name="ERR_CustomEventInvInInterface" xml:space="preserve">
    <value>“Custom”修饰符在接口中声明的事件上无效。</value>
  </data>
  <data name="ERR_BadOperatorFlags1" xml:space="preserve">
    <value>运算符不能声明为“{0}”。</value>
  </data>
  <data name="ERR_InvalidConstructorCall" xml:space="preserve">
    <value>构造函数调用仅作为实例构造函数中的第一条语句有效。</value>
  </data>
  <data name="ERR_ExpectedDeclaration" xml:space="preserve">
    <value>应为声明。</value>
  </data>
  <data name="WRN_UseOfObsoleteSymbol2" xml:space="preserve">
    <value>“{0}”已过时:“{1}”。</value>
  </data>
  <data name="ERR_ExtensionMethodOptionalFirstArg" xml:space="preserve">
    <value>“Optional”无法应用于扩展方法的第一个参数。第一个参数指定要扩展哪个类型。</value>
  </data>
  <data name="ERR_BadConstraintSyntax" xml:space="preserve">
    <value>应为类型或“New”。</value>
  </data>
  <data name="ERR_TypeParamWithStructConstAsConst" xml:space="preserve">
    <value>具有 "Structure" 约束的类型参数不能用作约束。</value>
  </data>
  <data name="ERR_ComClassReservedDispIdZero1" xml:space="preserve">
    <value>“Microsoft.VisualBasic.ComClassAttribute”为默认属性保留的值为零，因此“System.Runtime.InteropServices.DispIdAttribute”不能应用于“{0}”。</value>
  </data>
  <data name="ERR_TooFewGenericArguments2" xml:space="preserve">
    <value>对“{1}”中定义的扩展方法“{0}”而言，类型参数太少。</value>
  </data>
  <data name="ERR_TooFewGenericArguments1" xml:space="preserve">
    <value>“{0}”的类型参数太少。</value>
  </data>
  <data name="ERR_InvOutsideProc" xml:space="preserve">
    <value>标签在方法外部无效。</value>
  </data>
  <data name="TreesMustHaveRootNode" xml:space="preserve">
    <value>树({0}) 必须具有带 SyntaxKind.CompilationUnit 的根节点。</value>
  </data>
  <data name="ERR_Syntax" xml:space="preserve">
    <value>语法错误。</value>
  </data>
  <data name="ERR_SwitchNeedsBool" xml:space="preserve">
    <value>选项“{0}”后面只能跟“+”或“-”</value>
  </data>
  <data name="ERR_InitializedExpandedProperty" xml:space="preserve">
    <value>无法初始化扩展属性。</value>
  </data>
  <data name="ERR_RaiseEventShapeMismatch1" xml:space="preserve">
    <value>“RaiseEvent”方法必须具有与包含事件的委托类型“{0}”相同的签名。</value>
  </data>
  <data name="ERR_PIAHasNoTypeLibAttribute1" xml:space="preserve">
    <value>无法嵌入来自程序集“{0}”的互操作类型，因为它缺少“{1}”特性或“{2}”特性。</value>
  </data>
  <data name="WRN_NonCLSMemberInCLSInterface1_Title" xml:space="preserve">
    <value>在符合 CLS 的接口中不允许出现不符合 CLS 的成员</value>
  </data>
  <data name="WRN_IndirectRefToLinkedAssembly2" xml:space="preserve">
    <value>已创建对嵌入的互操作程序集“{0}”的引用，因为程序集“{1}”间接引用了该程序集。请考虑更改其中一个程序集的“嵌入互操作类型”属性。</value>
  </data>
  <data name="ERR_UnreferencedModule3" xml:space="preserve">
    <value>需要对模块“{0}”(包含类型“{1}”)的引用。请在项目中添加一个。</value>
  </data>
  <data name="ERR_InvalidOptionStrictCustom" xml:space="preserve">
    <value>Option Strict Custom 只能用作命令行编译器(vbc.exe)的选项。</value>
  </data>
  <data name="ERR_SyntMemberShadowsGenericParam3" xml:space="preserve">
    <value>{0}“{1}”隐式定义了与某个类型参数同名的成员“{2}”。</value>
  </data>
  <data name="ERR_RefAndValueConstraintsCombined" xml:space="preserve">
    <value>"Class" 约束不能与 "Structure" 约束组合。</value>
  </data>
  <data name="WRN_DefAsgNoRetValPropRef1_Title" xml:space="preserve">
    <value>属性没有在所有代码路径上返回值</value>
  </data>
  <data name="ERR_EmptyAggregateInitializer" xml:space="preserve">
    <value>聚合集合初始值设定项必须至少包含一个元素。</value>
  </data>
  <data name="ERR_NewWithTupleTypeSyntax" xml:space="preserve">
    <value>"New" 不能用于元组类型。请改用元组文本表达式。</value>
  </data>
  <data name="ERR_NoNonNarrowingOverloadCandidates2" xml:space="preserve">
    <value>重载决策失败，因为没有不使用收缩转换即可调用的可访问重载“{0}”: {1}</value>
  </data>
  <data name="ERR_DebugEntryPointNotSourceMethodDefinition" xml:space="preserve">
    <value>调试入口点必须是当前编译中声明的方法的定义。</value>
  </data>
  <data name="ERR_InvalidStructMemberNoPIA1" xml:space="preserve">
    <value>嵌入的互操作结构“{0}”只能包含公共实例字段。</value>
  </data>
  <data name="ERR_InvalidImplicitMeReference" xml:space="preserve">
    <value>调用另一个构造函数时隐式引用尚未完成的对象是无效的。</value>
  </data>
  <data name="WRN_XMLDocNotFirstOnLine" xml:space="preserve">
    <value>XML 注释必须是一行中的第一条语句。XML 注释将被忽略。</value>
  </data>
  <data name="ERR_UnexpectedGroup" xml:space="preserve">
    <value>此上下文中不允许 "Group"；应为标识符。</value>
  </data>
  <data name="WRN_ObjectMath1" xml:space="preserve">
    <value>对运算符“{0}”使用了 Object 类型的操作数；应使用“Is”运算符来测试对象标识。</value>
  </data>
  <data name="WRN_ObjectMath2" xml:space="preserve">
    <value>对运算符“{0}”使用了 Object 类型的操作数；可能会发生运行时错误。</value>
  </data>
  <data name="FieldInitializerSyntaxNotWithinSyntaxTree" xml:space="preserve">
    <value>FieldInitializerSyntax 不在语法树中</value>
  </data>
  <data name="ERR_AttributeParameterRequired2" xml:space="preserve">
    <value>必须指定特性参数“{0}”或“{1}”。</value>
  </data>
  <data name="ERR_AttributeParameterRequired1" xml:space="preserve">
    <value>必须指定特性参数“{0}”。</value>
  </data>
  <data name="ERR_InitializerInStruct" xml:space="preserve">
    <value>结构成员上的初始值设定项仅对“Shared”成员和常量有效。</value>
  </data>
  <data name="ERR_VarianceTypeDisallowedHere3" xml:space="preserve">
    <value>类型“{0}”不能在此上下文用于“{2}”，因为此上下文和“{0}”的定义均嵌套在接口“{1}”内，而“{1}”含有“In”或“Out”类型参数。考虑将“{0}”的定义移出“{1}”。</value>
  </data>
  <data name="ERR_NoNetModuleOutputWhenRefOutOrRefOnly" xml:space="preserve">
    <value>无法在使用 /refout 或 /refonly 时编译 Net 模块。</value>
  </data>
  <data name="ERR_TypeDisallowsDescendants" xml:space="preserve">
    <value>XML 子代元素不能从类型“{0}”中选择。</value>
  </data>
  <data name="ERR_GenericParamBase2" xml:space="preserve">
    <value>{0}“{1}”不能从类型参数中继承。</value>
  </data>
  <data name="ERR_BadAssemblyName" xml:space="preserve">
    <value>无效的程序集名称: {0}</value>
  </data>
  <data name="ERR_BadRecordFlags1" xml:space="preserve">
    <value>“{0}”在结构声明中无效。</value>
  </data>
  <data name="ERR_NestingViolatesCLS1" xml:space="preserve">
    <value>类型“{0}”不继承其容器的泛型类型参数。</value>
  </data>
  <data name="ERR_ExpectedEndModule" xml:space="preserve">
    <value>“Module”语句必须以匹配的“End Module”结束。</value>
  </data>
  <data name="ERR_BaseUnifiesWithInterfaces3" xml:space="preserve">
    <value>无法继承接口“{0}”，因为对于某些类型参数，它所继承的接口“{1}”可能与接口“{2}”相同。</value>
  </data>
  <data name="ERR_MaximumNumberOfErrors" xml:space="preserve">
    <value>已超出最大错误数。</value>
  </data>
  <data name="ERR_IllegalOperandInIIFConversion" xml:space="preserve">
    <value>无法推断“If”运算符的第二个和第三个操作数的通用类型。其中一个必须是另一个的扩大转换。</value>
  </data>
  <data name="ERR_BadAsyncByRefParam" xml:space="preserve">
    <value>异步方法不能包含 ByRef 参数。</value>
  </data>
  <data name="ERR_NoTypecharInLabel" xml:space="preserve">
    <value>标签标识符中不允许使用类型字符。</value>
  </data>
  <data name="ERR_InvalidFormatForGuidForOption" xml:space="preserve">
    <value>命令行语法错误: Guid 格式“{0}”对于选项“{1}”无效</value>
  </data>
  <data name="ERR_NoTypecharInAlias" xml:space="preserve">
    <value>在 Imports 别名上不允许使用类型字符。</value>
  </data>
  <data name="WRN_MustOverride2" xml:space="preserve">
    <value>{0}“{1}”隐藏基 {2}“{3}”中的可重写方法。若要重写基方法，必须将此方法声明为“Overrides”。</value>
  </data>
  <data name="ERR_NoSuitableWidestType1" xml:space="preserve">
    <value>无法推断“{0}”的类型，因为循环边界和 step 子句不会转换为同一类型。</value>
  </data>
  <data name="ERR_IsOperatorNullable1" xml:space="preserve">
    <value>类型“{0}”是可以为 null 的类型，因此“{0}”的“Is”操作数只能与“Nothing”进行比较。</value>
  </data>
  <data name="ERR_OptionMustBeAbsolutePath" xml:space="preserve">
    <value>选项“{0}”必须是绝对路径。</value>
  </data>
  <data name="ERR_ExpectedXmlEndEmbedded" xml:space="preserve">
    <value>应为嵌入表达式的结束标记“%&gt;”。</value>
  </data>
  <data name="ERR_ExitDoNotWithinDo" xml:space="preserve">
    <value>"Exit Do" 只能出现在 "Do" 语句内。</value>
  </data>
  <data name="ERR_ConstructorAsync" xml:space="preserve">
    <value>构造函数不得包含“Async”修饰符。</value>
  </data>
  <data name="ERR_VarianceOutByValDisallowed1" xml:space="preserve">
    <value>类型“{0}”不能用作 ByVal 参数类型，因为“{0}”是“Out”类型参数。</value>
  </data>
  <data name="ERR_InvalidSubsystemVersion" xml:space="preserve">
    <value>值“{0}”不是有效的子系统版本。对于 ARM 或 AppContainerExe，版本必须为 6.02 或更高版本，对于其他内容，版本必须为 4.00 或更高版本。</value>
  </data>
  <data name="ERR_ConditionOperatorRequired3" xml:space="preserve">
    <value>类型“{0}”必须定义运算符“{1}”，才能在“{2}”表达式中使用。</value>
  </data>
  <data name="ERR_InvalidPathMap" xml:space="preserve">
    <value>路径映射选项的格式不正确。</value>
  </data>
  <data name="ERR_MissingRuntimeHelper" xml:space="preserve">
    <value>所请求的操作不可用，因为没有定义运行库函数“{0}”。</value>
  </data>
  <data name="ERR_TypeInferenceFailureNoExplicitNoBest2" xml:space="preserve">
    <value>无法从这些实参推断方法“{0}”中类型形参的数据类型，因为这些数据类型不会转换为同一类型。</value>
  </data>
  <data name="ERR_TypeInferenceFailureNoExplicitNoBest3" xml:space="preserve">
    <value>无法从这些实参推断“{1}”中定义的扩展方法“{0}”中类型形参的数据类型，因为这些数据类型不会转换为同一类型。</value>
  </data>
  <data name="ERR_TypeInferenceFailureNoExplicitNoBest1" xml:space="preserve">
    <value>无法从这些实参推断类型形参的数据类型，因为这些数据类型不会转换为同一类型。</value>
  </data>
  <data name="ERR_InvalidAssemblyAttribute1" xml:space="preserve">
    <value>属性“{0}”不能应用于程序集。</value>
  </data>
  <data name="ERR_IllegalBaseTypeReferences3" xml:space="preserve">
    <value>{0}“{1}”的继承子句会导致循环依赖: {2}</value>
  </data>
  <data name="ERR_MissingAddHandlerDef1" xml:space="preserve">
    <value>缺少事件“{0}”的“AddHandler”定义。</value>
  </data>
  <data name="ERR_MemberClashesWithSynth6" xml:space="preserve">
    <value>{0}“{1}”与为 {4}“{5}”中的 {2}“{3}”隐式声明的成员冲突。</value>
  </data>
  <data name="ERR_StrictArgumentCopyBackNarrowing3" xml:space="preserve">
    <value>将“ByRef”形参“{0}”的值复制回匹配实参时，Option Strict On 不允许从类型“{1}”收缩为类型“{2}”。</value>
  </data>
  <data name="ERR_BadCodepage" xml:space="preserve">
    <value>代码页“{0}”无效或未安装</value>
  </data>
  <data name="ERR_ExpectedXmlBeginEmbedded" xml:space="preserve">
    <value>嵌入表达式的开头应为“%=”。</value>
  </data>
  <data name="ERR_MustShadow2" xml:space="preserve">
    <value>{0}“{1}”必须声明为“Shadows”，因为具有此名称的另一个成员被声明为“Shadows”。</value>
  </data>
  <data name="ERR_InterfacePossiblyImplTwice2" xml:space="preserve">
    <value>无法实现接口“{0}”，因为对于某些类型参数，该接口的实现可能与另一个已实现的接口“{1}”的实现冲突。</value>
  </data>
  <data name="WRN_AttributeIgnoredWhenPublicSigning" xml:space="preserve">
    <value>指定公共签名时，将忽略特性“{0}”。</value>
  </data>
  <data name="ERR_BadInterfaceClassSpecifier1" xml:space="preserve">
    <value>接口中的类不能声明为“{0}”。</value>
  </data>
  <data name="ERR_FriendAssemblyBadArguments" xml:space="preserve">
    <value>友元程序集引用“{0}”无效。不能在 InternalsVisibleTo 声明中指定版本、区域性、公钥标记或处理器架构。</value>
  </data>
  <data name="ERR_VarianceTypeDisallowedHereForGeneric5" xml:space="preserve">
    <value>类型“{0}”不能在此上下文中用于“{2}”中“{4}”的“{3}”，因为此上下文和“{0}”的定义均嵌套在接口“{1}”内，而“{1}”含有“In”或“Out”类型参数。考虑将“{0}”的定义移出“{1}”。</value>
  </data>
  <data name="ERR_DoesntImplementAwaitInterface2" xml:space="preserve">
    <value>“{0}”未实现“{1}”。</value>
  </data>
  <data name="ERR_IllegalXmlCommentChar" xml:space="preserve">
    <value>XML 注释中不允许出现字符序列“--”。</value>
  </data>
  <data name="ERR_ConflictingDirectConstraints3" xml:space="preserve">
    <value>约束“{0}”与已为类型参数“{2}”指定的约束“{1}”冲突。</value>
  </data>
  <data name="ERR_SourceInterfaceMustBeInterface" xml:space="preserve">
    <value>接口“{0}”的源接口无效，该源接口是嵌入事件“{1}”所必需的。</value>
  </data>
  <data name="ERR_NameNotDeclared1" xml:space="preserve">
    <value>未声明“{0}”。由于其保护级别，它可能无法访问。</value>
  </data>
  <data name="ERR_ObsoleteGetStatement" xml:space="preserve">
    <value>不再支持 "Get" 语句。"Microsoft.VisualBasic" 命名空间中有文件 I/O 功能。</value>
  </data>
  <data name="ERR_IndexedNotArrayOrProc" xml:space="preserve">
    <value>表达式不是数组或方法，不能具有参数列表。</value>
  </data>
  <data name="ERR_AmbiguousDelegateBinding2" xml:space="preserve">
    <value>没有非常明确的可访问“{0}”: {1}</value>
  </data>
  <data name="ERR_ExpectedXmlEndComment" xml:space="preserve">
    <value>应为 XML 注释的结束标记“--&gt;”。</value>
  </data>
  <data name="ERR_StructCantInherit" xml:space="preserve">
    <value>结构不能有 "Inherits" 语句。</value>
  </data>
  <data name="ERR_AttributeMustInheritSysAttr" xml:space="preserve">
    <value>“{0}”不从“System.Attribute”继承，因此不能用作属性。</value>
  </data>
  <data name="ERR_NoPIAAttributeMissing2" xml:space="preserve">
    <value>无法嵌入互操作类型“{0}”，因为它缺少必需的“{1}”特性。</value>
  </data>
  <data name="INF_UnableToLoadSomeTypesInAnalyzer_Title" xml:space="preserve">
    <value>跳过加载分析器程序集中因 ReflectionTypeLoadException 而失败的类型</value>
  </data>
  <data name="WRN_SynthMemberShadowsSynthMember7_Title" xml:space="preserve">
    <value>属性或事件隐式声明与为基类型中的属性或事件隐式声明的成员发生冲突的成员</value>
  </data>
  <data name="WRN_ObjectAssumed1_Title" xml:space="preserve">
    <value>函数没有 "As" 子句</value>
  </data>
  <data name="ERR_InterfaceInheritedTwiceWithDifferentTupleNamesReverse3" xml:space="preserve">
    <value>接口“{0}”只能通过此接口继承一次(通过“{1}”)，但已显示有不同的元组元素名称，如“{2}”。</value>
  </data>
  <data name="WRN_MissingAsClauseinProperty" xml:space="preserve">
    <value>属性没有 "As" 子句；假定为 Object 类型。</value>
  </data>
  <data name="ERR_CantShadowAMustOverride1" xml:space="preserve">
    <value>“{0}”不能隐藏声明为“MustOverride”的方法。</value>
  </data>
  <data name="ERR_DelegateNoInvoke1" xml:space="preserve">
    <value>委托类“{0}”没有 Invoke 方法，所以此类型的表达式不能作为方法调用的目标。</value>
  </data>
  <data name="ERR_ReadOnlyHasNoGet" xml:space="preserve">
    <value>"ReadOnly" 属性必须提供 "Get"。</value>
  </data>
  <data name="WRN_SynthMemberShadowsMember5" xml:space="preserve">
    <value>{0}“{1}”隐式声明的“{2}”与基 {3}“{4}”中的成员冲突，因此应将 {0} 声明为“Shadows”。</value>
  </data>
  <data name="ERR_EqualsTypeMismatch" xml:space="preserve">
    <value>“Equals”不能对类型为“{0}”的值与类型“{1}”的值进行比较。</value>
  </data>
  <data name="ERR_NoDefaultNotExtend1" xml:space="preserve">
    <value>无法为类“{0}”编制索引，因为它没有默认属性。</value>
  </data>
  <data name="ERR_ObsoleteEndIf" xml:space="preserve">
    <value>不再支持 "EndIf" 语句；请改用 "End If"。</value>
  </data>
  <data name="ERR_UnsupportedMethod1" xml:space="preserve">
    <value>“{0}”有不受支持的返回类型或不受支持的参数类型。</value>
  </data>
  <data name="ERR_ObsoleteGosub" xml:space="preserve">
    <value>不再支持 "GoSub" 语句。</value>
  </data>
  <data name="ERR_ObsoleteAsAny" xml:space="preserve">
    <value>"Declare" 语句中不支持 "As Any"。</value>
  </data>
  <data name="ERR_RedimRankMismatch" xml:space="preserve">
    <value>"ReDim" 无法更改数组的维数。</value>
  </data>
  <data name="ERR_BadImplementsType" xml:space="preserve">
    <value>已实现的类型必须是接口。</value>
  </data>
  <data name="WRN_NoNonObsoleteConstructorOnBase3_Title" xml:space="preserve">
    <value>类应声明 "Sub New"，原因是它的基类中的构造函数被标记为已过时</value>
  </data>
  <data name="ERR_ExpectedForOptionStmt" xml:space="preserve">
    <value>“Option”的后面必须跟有“Compare”、“Explicit”、“Infer”或“Strict”。</value>
  </data>
  <data name="ERR_ExtensionMethodNotInModule" xml:space="preserve">
    <value>只能在模块中定义扩展方法。</value>
  </data>
  <data name="WRN_ImplicitConversionSubst1_Title" xml:space="preserve">
    <value>隐式转换</value>
  </data>
  <data name="ERR_TypeRefResolutionError3" xml:space="preserve">
    <value>从程序集或模块“{1}”导入类型“{0}”失败。</value>
  </data>
  <data name="WRN_EnumUnderlyingTypeNotCLS1" xml:space="preserve">
    <value>枚举的基础类型“{0}”不符合 CLS。</value>
  </data>
  <data name="ERR_MustOverOnNotInheritPartClsMem1" xml:space="preserve">
    <value>不能在此成员上指定“MustOverride”，因为它所在的分部类型在另一个分部定义中被声明为“NotInheritable”。</value>
  </data>
  <data name="ERR_NoExplicitArraySizes" xml:space="preserve">
    <value>数组界限不能出现在类型说明符中。</value>
  </data>
  <data name="ERR_NonNamespaceOrClassOnImport2" xml:space="preserve">
    <value>Imports “{0}”的“{1}”不引用命名空间、类、结构、枚举或模块。</value>
  </data>
  <data name="WRN_XMLDocReturnsOnWriteOnlyProperty" xml:space="preserve">
    <value>WriteOnly 属性中不允许有 XML 注释标记 "returns"。</value>
  </data>
  <data name="ERR_PartialMethodsMustBePrivate" xml:space="preserve">
    <value>必须将分部方法声明为 "Private"。</value>
  </data>
  <data name="ERR_ConstAsNonConstant" xml:space="preserve">
    <value>常量必须是内部类型或者枚举类型，不能是类、结构、类型参数或数组类型。</value>
  </data>
  <data name="ERR_NoArgumentCountOverloadCandidates1" xml:space="preserve">
    <value>重载决策失败，因为没有可访问的“{0}”接受此数目的参数。</value>
  </data>
  <data name="ERR_AmbiguousOverrides3" xml:space="preserve">
    <value>无法重写与此签名匹配的成员“{0}”，因为类“{1}”包含多个具有此相同名称和签名的成员: {2}</value>
  </data>
  <data name="ERR_StatementLambdaInExpressionTree" xml:space="preserve">
    <value>语句 lambda 不能转换为表达式树。</value>
  </data>
  <data name="ERR_InheritanceCycle1" xml:space="preserve">
    <value>类“{0}”不能从自身继承: {1}</value>
  </data>
  <data name="ERR_MissingEndEnum" xml:space="preserve">
    <value>"Enum" 必须以匹配的 "End Enum" 结束。</value>
  </data>
  <data name="ERR_UnsupportedModule1" xml:space="preserve">
    <value>“{0}”是不受支持的 .NET 模块。</value>
  </data>
  <data name="ERR_ByRefIllegal1" xml:space="preserve">
    <value>{0} 参数不能声明为“ByRef”。</value>
  </data>
  <data name="WRN_InvalidOverrideDueToTupleNames2" xml:space="preserve">
    <value>“{0}”不能替代“{1}”，因为它们的元组元素名称不同。</value>
  </data>
  <data name="ERR_BadFlagsOnStdModuleProperty1" xml:space="preserve">
    <value>模块中的属性不能声明为“{0}”。</value>
  </data>
  <data name="ERR_SubNewCycle2" xml:space="preserve">
    <value>
  “{0}”调用“{1}”。</value>
  </data>
  <data name="ERR_SubNewCycle1" xml:space="preserve">
    <value>构造函数“{0}”不能调用自身: {1}</value>
  </data>
  <data name="ERR_BadAwaitInTryHandler" xml:space="preserve">
    <value>不能在“Catch”语句、“Finally”语句或“SyncLock”语句内使用“Await”。</value>
  </data>
  <data name="ERR_NoAccessibleSet" xml:space="preserve">
    <value>属性“{0}”的“Set”访问器不可访问。</value>
  </data>
  <data name="ERR_NoAccessibleGet" xml:space="preserve">
    <value>属性“{0}”的“Get”访问器不可访问。</value>
  </data>
  <data name="WRN_TypeConflictButMerged6_Title" xml:space="preserve">
    <value>类型和分部类型冲突，但由于其中一个被声明为 Partial，因此正在合并</value>
  </data>
  <data name="ERR_IsOperatorRequiresReferenceTypes1" xml:space="preserve">
    <value>“Is”运算符不接受类型为“{0}”的操作数。操作数必须是引用类型或可以为 null 的类型。</value>
  </data>
  <data name="WRN_InvalidOverrideDueToTupleNames2_Title" xml:space="preserve">
    <value>成员不能替代，因为它的元组元素名称不同。</value>
  </data>
  <data name="WRN_ObsoleteIdentityDirectCastForValueType_Title" xml:space="preserve">
    <value>使用 DirectCast 运算符将值类型强制转换为同一类型的做法已过时</value>
  </data>
  <data name="ERR_ConstantWithNoValue" xml:space="preserve">
    <value>常量必须具有值。</value>
  </data>
  <data name="ERR_NameNotMemberOfAnonymousType2" xml:space="preserve">
    <value>“{0}”不是“{1}”的成员；它不存在于当前上下文。</value>
  </data>
  <data name="ERR_EndClassNoClass" xml:space="preserve">
    <value>"End Class" 前面必须是匹配的 "Class"。</value>
  </data>
  <data name="WRN_FileAlreadyIncluded_Title" xml:space="preserve">
    <value>多次指定源文件</value>
  </data>
  <data name="ERR_TypecharNotallowed" xml:space="preserve">
    <value>类型声明字符在此上下文中无效。</value>
  </data>
  <data name="ERR_BogusWithinLineIf" xml:space="preserve">
    <value>语句不能在“If”语句行之外结束块。</value>
  </data>
  <data name="WRN_NameNotCLSCompliant1_Title" xml:space="preserve">
    <value>名称不符合 CLS</value>
  </data>
  <data name="WRN_TypeNotCLSCompliant1_Title" xml:space="preserve">
    <value>类型不符合 CLS</value>
  </data>
  <data name="ERR_NestedTypeInInheritsClause2" xml:space="preserve">
    <value>类“{0}”无法在 Inherits 子句中引用其嵌套类型“{1}”。</value>
  </data>
  <data name="ERR_UnsupportedType1" xml:space="preserve">
    <value>“{0}”是不受支持的类型。</value>
  </data>
  <data name="ERR_ConvParamMustBeContainingType1" xml:space="preserve">
    <value>此转换运算符的参数类型或返回类型必须属于包含类型“{0}”。</value>
  </data>
  <data name="ERR_ForLoopOperatorRequired2" xml:space="preserve">
    <value>类型“{0}”必须定义运算符“{1}”，才能在“For”语句中使用。</value>
  </data>
  <data name="ERR_ExitForNotWithinFor" xml:space="preserve">
    <value>"Exit For" 只能出现在 "For" 语句内。</value>
  </data>
  <data name="WRN_MainIgnored" xml:space="preserve">
    <value>程序的入口点是全局脚本代码；正在忽略“{0}”入口点。</value>
  </data>
  <data name="ERR_NullableCharNotSupported" xml:space="preserve">
    <value>此处不能使用 "?" 字符。</value>
  </data>
  <data name="ERR_MissingEndEvent" xml:space="preserve">
    <value>Custom Event 必须以匹配的 "End Event" 结束。</value>
  </data>
  <data name="ERR_MissingEndBrack" xml:space="preserve">
    <value>用括号标识的标识符缺少右边的 "]"。</value>
  </data>
  <data name="ERR_AmbiguousCastConversion2" xml:space="preserve">
    <value>Option Strict 不允许进行“{0}”到“{1}”的隐式转换，因为转换不明确。</value>
  </data>
  <data name="ERR_BadDelegateFlags1" xml:space="preserve">
    <value>“{0}”在委托声明中无效。</value>
  </data>
  <data name="WRN_VarianceIEnumerableSuggestion3_Title" xml:space="preserve">
    <value>无法将类型转换为目标集合类型</value>
  </data>
  <data name="WRN_PrefixAndXmlnsLocalName_Title" xml:space="preserve">
    <value>不建议拥有名为 xmlns 的属性</value>
  </data>
  <data name="ERR_BadAttributeNonPublicConstructor" xml:space="preserve">
    <value>特性没有 Public 构造函数，因此不能使用。</value>
  </data>
  <data name="ERR_BadAttributeNonPublicProperty1" xml:space="preserve">
    <value>特性成员“{0}”未声明为“Public”，因此不能作为赋值的目标。</value>
  </data>
  <data name="ERR_FileNotFound" xml:space="preserve">
    <value>找不到文件“{0}”。</value>
  </data>
  <data name="ERR_ArgumentNarrowing3" xml:space="preserve">
    <value>与参数“{0}”匹配的参数从“{1}”收缩到“{2}”。</value>
  </data>
  <data name="ERR_ArgumentNarrowing2" xml:space="preserve">
    <value>与形参“{0}”匹配的实参收缩到“{1}”。</value>
  </data>
  <data name="ERR_AnonymousTypeFieldNameInference" xml:space="preserve">
    <value>只能从不带参数的简单名或限定名中推断匿名类型成员名称。</value>
  </data>
  <data name="WRN_LiftControlVariableLambda_Title" xml:space="preserve">
    <value>在 lambda 表达式中使用迭代变量可能会产生意外的结果</value>
  </data>
  <data name="ERR_NoSuitableNewForNewConstraint2" xml:space="preserve">
    <value>类型实参“{0}”必须具有一个公共的无参数实例构造函数，才能满足类型形参“{1}”的“New”约束。</value>
  </data>
  <data name="ERR_LbBadElseif" xml:space="preserve">
    <value>"#ElseIf" 前面必须是匹配的 "#If" 或 "#ElseIf"。</value>
  </data>
  <data name="ERR_PrincipalPermissionInvalidAction" xml:space="preserve">
    <value>SecurityAction 值“{0}”对 PrincipalPermission 属性无效。</value>
  </data>
  <data name="ERR_AsNewArray" xml:space="preserve">
    <value>不能用 "New" 声明数组。</value>
  </data>
  <data name="AssociatedTypeDoesNotHaveTypeParameters" xml:space="preserve">
    <value>关联类型没有类型参数</value>
  </data>
  <data name="ERR_InitializerTooFewElements1" xml:space="preserve">
    <value>数组初始值设定项缺少 {0} 个元素。</value>
  </data>
  <data name="ERR_NewIfNullOnNonClass" xml:space="preserve">
    <value>"New"不能在接口上使用。</value>
  </data>
  <data name="ERR_MultipleParameterSpecifiers" xml:space="preserve">
    <value>“ByVal”不能与“ByRef”组合。</value>
  </data>
  <data name="ERR_ExpectedQueryableSource" xml:space="preserve">
    <value>类型“{0}”的表达式不可查询。请确保不缺少程序集引用和/或 LINQ 提供程序的命名空间导入。</value>
  </data>
  <data name="ERR_AnonymousTypePropertyOutOfOrder1" xml:space="preserve">
    <value>无法使用匿名类型成员属性“{0}”来推断另一个成员属性的类型，因为尚未建立“{0}”的类型。</value>
  </data>
  <data name="ERR_SynthMemberClashesWithMember5" xml:space="preserve">
    <value>{0}“{1}”隐式定义的“{2}”与 {3}“{4}”中的同名成员冲突。</value>
  </data>
  <data name="ERR_InvalidAttributeValue1" xml:space="preserve">
    <value>属性值无效；应为“{0}”。</value>
  </data>
  <data name="ERR_InvalidAttributeValue2" xml:space="preserve">
    <value>属性值无效；应为“{0}”或“{1}”。</value>
  </data>
  <data name="WRN_AssemblyAttributeFromModuleIsOverridden_Title" xml:space="preserve">
    <value>为支持源中出现的实例，将忽略模块的特性</value>
  </data>
  <data name="ERR_NoSourcesOut" xml:space="preserve">
    <value>无法从仅资源输入文件推理出输出文件名；提供“/out”选项</value>
  </data>
  <data name="ERR_ShadowingGenericParamWithMember1" xml:space="preserve">
    <value>“{0}”与一个类型参数同名。</value>
  </data>
  <data name="ERR_CantReferToMyGroupInsideGroupType1" xml:space="preserve">
    <value>“{0}”不能通过其默认实例指代自身；请改用“Me”。</value>
  </data>
  <data name="WRN_ObjectMath1Not" xml:space="preserve">
    <value>对运算符“{0}”使用了 Object 类型的操作数；应使用“IsNot”运算符来测试对象标识。</value>
  </data>
  <data name="ERR_MyGroupCollectionAttributeCycle" xml:space="preserve">
    <value>MyGroupCollectionAttribute 不能应用于自身。</value>
  </data>
  <data name="ERR_IntegralToCharTypeMismatch1" xml:space="preserve">
    <value>“{0}”值不能转换为“Char”。使用“Microsoft.VisualBasic.ChrW”将数值解释为 Unicode 字符或先将其转换为“String”以产生数字。</value>
  </data>
  <data name="ERR_BadRefLib1" xml:space="preserve">
    <value>无法加载引用的库“{0}”: {1}</value>
  </data>
  <data name="ERR_IllegalXmlNameChar" xml:space="preserve">
    <value>XML 名称中允许字符“{0}”({1})。</value>
  </data>
  <data name="FEATURE_BinaryLiterals" xml:space="preserve">
    <value>二进制文字</value>
  </data>
  <data name="ERR_EndExternalSource" xml:space="preserve">
    <value>"#End ExternalSource" 前面必须是匹配的 "#ExternalSource"。</value>
  </data>
  <data name="ERR_CantUseRequiredAttribute" xml:space="preserve">
    <value>Visual Basic 类型上不允许有 RequiredAttribute 特性。</value>
  </data>
  <data name="ERR_ForEachCollectionDesignPattern1" xml:space="preserve">
    <value>表达式的类型为“{0}”，该类型不是集合类型。</value>
  </data>
  <data name="ERR_NestedFunctionArgumentNarrowing3" xml:space="preserve">
    <value>与参数“{0}”匹配的嵌套函数的返回类型从“{1}”收缩到“{2}”。</value>
  </data>
  <data name="ERR_VarianceTypeDisallowed2" xml:space="preserve">
    <value>类型“{0}”不能用于此上下文，因为此上下文和“{0}”的定义均嵌套在接口“{1}”内，而“{1}”含有“In”或“Out”类型参数。考虑将“{0}”的定义移出“{1}”。</value>
  </data>
  <data name="ERR_BadDeclareFlags1" xml:space="preserve">
    <value>“{0}”在 Declare 中无效。</value>
  </data>
  <data name="ERR_DeclaresCantBeInGeneric" xml:space="preserve">
    <value>泛型类型或包含在泛型类型中的类型中不允许“Declare”语句。</value>
  </data>
  <data name="ERR_CannotOverrideInAccessibleMember" xml:space="preserve">
    <value>“{0}”无法重写“{1}”，因为它在此上下文中是无法访问的。</value>
  </data>
  <data name="ERR_ExpectedEndExternalSource" xml:space="preserve">
    <value>“#ExternalSource”语句必须以匹配的“#End ExternalSource”结束。</value>
  </data>
  <data name="FunctionSyntaxNotWithinSyntaxTree" xml:space="preserve">
    <value>FunctionSyntax 不在语法树中</value>
  </data>
  <data name="WRN_DefAsgNoRetValOpRef1_Title" xml:space="preserve">
    <value>运算符没有在所有代码路径上返回值</value>
  </data>
  <data name="WRN_ProcTypeNotCLSCompliant1" xml:space="preserve">
    <value>函数“{0}”的返回类型不符合 CLS。</value>
  </data>
  <data name="ERR_DuplicateLocals1" xml:space="preserve">
    <value>当前块中已声明了局部变量“{0}”。</value>
  </data>
  <data name="ERR_FriendRefNotEqualToThis" xml:space="preserve">
    <value>友元访问权限由“{0}”授予，但是输出程序集的公钥与授予程序集中特性指定的公钥不匹配。</value>
  </data>
  <data name="WRN_MustOverride2_Title" xml:space="preserve">
    <value>成员隐藏基类型中的可重写的方法</value>
  </data>
  <data name="ERR_BadReturnValueInIterator" xml:space="preserve">
    <value>若要从迭代器函数返回值，请使用“Yield”而不是“Return”。</value>
  </data>
  <data name="WRN_MustOverloadBase4" xml:space="preserve">
    <value>{0}“{1}”隐藏在基 {2}“{3}”中声明的可重载的成员。如果要重载基方法，则此方法必须声明为“Overloads”。</value>
  </data>
  <data name="ERR_STAThreadAndMTAThread0" xml:space="preserve">
    <value>"System.STAThreadAttribute" 和 "System.MTAThreadAttribute" 不能同时应用于同一方法。</value>
  </data>
  <data name="WRN_InvalidAssemblyName_Title" xml:space="preserve">
    <value>程序集引用无效且无法解析</value>
  </data>
  <data name="ERR_ImplementsWithConstraintMismatch3" xml:space="preserve">
    <value>“{0}”无法实现“{1}.{2}”，因为它们在类型参数约束上存在差异。</value>
  </data>
  <data name="WRN_LambdaNoTypeObjectAssumed" xml:space="preserve">
    <value>无法推断返回类型；假定为 "Object"。</value>
  </data>
  <data name="WRN_RecursivePropertyCall_Title" xml:space="preserve">
    <value>表达式递归调用包含属性</value>
  </data>
  <data name="ERR_AccessMismatchOutsideAssembly4" xml:space="preserve">
    <value>“{0}”不能通过 {2}“{3}”在项目外部公开类型“{1}”。</value>
  </data>
  <data name="WRN_XMLDocInvalidXMLFragment" xml:space="preserve">
    <value>无法包括文件“{1}”的 XML 段落“{0}”。</value>
  </data>
  <data name="ERR_InvalidTypeForAliasesImport2" xml:space="preserve">
    <value>“{0}”的 Imports 别名的“{1}”不引用命名空间、类、结构、接口、枚举或模块。</value>
  </data>
  <data name="ERR_CannotCallEvent1" xml:space="preserve">
    <value>“{0}”是事件，不能直接调用。请使用“RaiseEvent”语句引发事件。</value>
  </data>
  <data name="ERR_MultiplyDefined1" xml:space="preserve">
    <value>当前方法中已定义了标签“{0}”。</value>
  </data>
  <data name="ERR_EndUsingWithoutUsing" xml:space="preserve">
    <value>“End Using”前面必须是匹配的“Using”。</value>
  </data>
  <data name="ERR_DuplicateTypeParamName1" xml:space="preserve">
    <value>类型参数已使用名称“{0}”声明。</value>
  </data>
  <data name="ERR_InvalidLiteralExponent" xml:space="preserve">
    <value>指数无效。</value>
  </data>
  <data name="ERR_PartialTypeAccessMismatch3" xml:space="preserve">
    <value>“{1}”的指定访问“{0}”与它的一个其他分部类型上指定的访问“{2}”不匹配。</value>
  </data>
  <data name="WRN_OptionalValueNotCLSCompliant1_Title" xml:space="preserve">
    <value>可选参数的可选值类型不符合 CLS</value>
  </data>
  <data name="ERR_FileAttributeNotAssemblyOrModule" xml:space="preserve">
    <value>应为“Assembly”或“Module”。</value>
  </data>
  <data name="WRN_XMLDocBadGenericParamTag2" xml:space="preserve">
    <value>XML 注释类型参数“{0}”和相应的“{1}”语句的类型参数不匹配。</value>
  </data>
  <data name="ERR_MissingXmlEndTag" xml:space="preserve">
    <value>元素缺少结束标记。</value>
  </data>
  <data name="WRN_MissingAsClauseinVarDecl_Title" xml:space="preserve">
    <value>变量声明没有 "As" 子句</value>
  </data>
  <data name="ERR_BadInterfaceFlags1" xml:space="preserve">
    <value>“{0}”在接口声明中无效。</value>
  </data>
  <data name="ERR_MultilineLambdaMissingSub" xml:space="preserve">
    <value>多行 lambda 表达式缺少 "End Sub"。</value>
  </data>
  <data name="ERR_CantOverrideConstructor" xml:space="preserve">
    <value>“Sub New”不能声明为“Overrides”。</value>
  </data>
  <data name="ERR_UnboundTypeParam1" xml:space="preserve">
    <value>无法推断类型参数“{0}”。</value>
  </data>
  <data name="ERR_UnboundTypeParam3" xml:space="preserve">
    <value>无法推断“{2}”中定义的扩展方法“{1}”的类型参数“{0}”。</value>
  </data>
  <data name="ERR_UnboundTypeParam2" xml:space="preserve">
    <value>无法推断“{1}”的类型参数“{0}”。</value>
  </data>
  <data name="WRN_IfNoTypeObjectAssumed_Title" xml:space="preserve">
    <value>无法推断通用类型</value>
  </data>
  <data name="ERR_UseOfLocalBeforeDeclaration1" xml:space="preserve">
    <value>局部变量“{0}”在声明之前不能被引用。</value>
  </data>
  <data name="ERR_ConversionFromBaseType" xml:space="preserve">
    <value>转换运算符不能从基类型转换。</value>
  </data>
  <data name="ERR_ExpectedRelational" xml:space="preserve">
    <value>应为关系运算符。</value>
  </data>
  <data name="ERR_TypeDisallowsAttributes" xml:space="preserve">
    <value>XML 特性不能从类型“{0}”中选择。</value>
  </data>
  <data name="WRN_ObjectAssumedProperty1_Title" xml:space="preserve">
    <value>属性没有 "As" 子句</value>
  </data>
</root>