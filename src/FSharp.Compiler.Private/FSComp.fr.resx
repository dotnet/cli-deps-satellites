<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="parsTypeAbbreviationsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Les modificateurs d'accessibilité ne sont pas autorisés à cette position pour les abréviations de type</value>
  </data>
  <data name="fscStaticLinkingNoEXE" xml:space="preserve">
    <value>La liaison statique ne peut pas inclure de fichier .EXE</value>
  </data>
  <data name="tcPropertyIsNotReadable" xml:space="preserve">
    <value>La propriété '{0}' n'est pas lisible</value>
  </data>
  <data name="tcInvalidUseBinding" xml:space="preserve">
    <value>Les liaisons 'use' doivent être sous la forme 'use &lt;var&gt; = &lt;expr&gt;'</value>
  </data>
  <data name="buildProductName" xml:space="preserve">
    <value>Compilateur F# Microsoft (R) version {0}</value>
  </data>
  <data name="fieldIsNotAccessible" xml:space="preserve">
    <value>Le champ de type enregistrement, struct ou classe '{0}' n'est pas accessible à partir de cet emplacement du code</value>
  </data>
  <data name="etMethodHasRequirements" xml:space="preserve">
    <value>Membre '{0}' non valide sur le type fourni '{1}'. Les membres de type fourni doivent être publics et non pas génériques, virtuels ou abstraits.</value>
  </data>
  <data name="tcEmptyRecordInvalid" xml:space="preserve">
    <value>'{{ }}' n'est pas une expression valide. Les enregistrements doivent inclure au moins un champ. Les séquences vides sont spécifiées via Seq.empty ou une liste vide '[]'.</value>
  </data>
  <data name="ilDynamicInvocationNotSupported" xml:space="preserve">
    <value>L'appel dynamique de {0} n'est pas pris en charge</value>
  </data>
  <data name="tcStructuralEqualityNotSatisfied1" xml:space="preserve">
    <value>Le type struct, enregistrement ou union '{0}' a l'attribut 'StructuralEquality' mais le paramètre de type '{1}' ne satisfait pas la contrainte 'equality'. Ajoutez la contrainte 'equality' au paramètre de type</value>
  </data>
  <data name="tcStructuralEqualityNotSatisfied2" xml:space="preserve">
    <value>Le type struct, enregistrement ou union '{0}' a l'attribut 'StructuralEquality' mais le type de composant '{1}' ne satisfait pas la contrainte 'equality'</value>
  </data>
  <data name="parsConsiderUsingSeparateRecordType" xml:space="preserve">
    <value>Utilisez un autre type enregistrement à la place</value>
  </data>
  <data name="chkNoByrefReturnOfLocal" xml:space="preserve">
    <value>Impossible d'utiliser l'adresse de la variable '{0}'. Une méthode ou une fonction ne doit pas retourner l'adresse de cette valeur locale.</value>
  </data>
  <data name="buildCannotReadAssembly" xml:space="preserve">
    <value>Impossible de lire l'assembly '{0}'</value>
  </data>
  <data name="csGenericConstructRequiresStructType" xml:space="preserve">
    <value>Une construction générique requiert que le type '{0}' soit un type struct CLI ou F#</value>
  </data>
  <data name="etNullProvidedExpression" xml:space="preserve">
    <value>Le fournisseur de type '{0}' a retourné Null de GetInvokerExpression.</value>
  </data>
  <data name="buildMultipleReferencesNotAllowed" xml:space="preserve">
    <value>Les références multiples à '{0}.dll' ne sont pas autorisées</value>
  </data>
  <data name="parsMismatchedQuotationName" xml:space="preserve">
    <value>Incompatibilité du nom d'opérateur de quotation, qui commence par '{0}'</value>
  </data>
  <data name="keywordDescriptionAbstract" xml:space="preserve">
    <value>Indique une méthode qui n'a aucune implémentation dans le type dans lequel elle est déclarée, ou qui est virtuelle avec une implémentation par défaut.</value>
  </data>
  <data name="fscStaticLinkingNoMixedDLL" xml:space="preserve">
    <value>La liaison statique ne peut pas inclure une DLL mixte managée/non managée</value>
  </data>
  <data name="keywordDescriptionPrivate" xml:space="preserve">
    <value>Restreint l'accès à un membre au code situé dans le même type ou module.</value>
  </data>
  <data name="csTypeNotCompatibleBecauseOfPrintf" xml:space="preserve">
    <value>Le type '{0}' n'est pas compatible avec les types {1}, qui résultent de l'utilisation d'une chaîne de format de style printf</value>
  </data>
  <data name="tcMemberOperatorDefinitionInExtrinsic" xml:space="preserve">
    <value>Les membres d'extension ne peuvent pas fournir de surcharges d'opérateur. Définissez l'opérateur comme faisant partie de la définition de type.</value>
  </data>
  <data name="chkVariableUsedInInvalidWay" xml:space="preserve">
    <value>La variable '{0}' est utilisée de manière incorrecte</value>
  </data>
  <data name="tcSyntaxCanOnlyBeUsedToCreateObjectTypes" xml:space="preserve">
    <value>'{0}' ne peut être utilisé que pour construire des types d'objets</value>
  </data>
  <data name="parsUnfinishedExpression" xml:space="preserve">
    <value>Jeton inattendu '{0}' ou expression incomplète</value>
  </data>
  <data name="parsUnderscoreInvalidFieldName" xml:space="preserve">
    <value>'_' ne peut pas être utilisé comme nom de champ</value>
  </data>
  <data name="parsMultipleAccessibilitiesForGetSet" xml:space="preserve">
    <value>Plusieurs accessibilités fournies pour la méthode getter ou setter de la propriété</value>
  </data>
  <data name="tcConstructorsCannotBeFirstClassValues" xml:space="preserve">
    <value>Les constructeurs doivent être appliqués aux arguments et ne peuvent pas être utilisés en tant que valeurs de première classe. Si nécessaire, utilisez une fonction anonyme '(fun arg1 ... argN -&gt; new Type(arg1,...,argN))'.</value>
  </data>
  <data name="buildInvalidVersionFile" xml:space="preserve">
    <value>Fichier de version non valide '{0}'</value>
  </data>
  <data name="tcRecursiveBindingsWithMembersMustBeDirectAugmentation" xml:space="preserve">
    <value>Les liaisons récursives qui incluent des spécifications de membres ne peuvent se produire qu'en tant qu'augmentation directe d'un type</value>
  </data>
  <data name="InvalidRecursiveReferenceToAbstractSlot" xml:space="preserve">
    <value>Référence récursive non valide à un emplacement abstrait</value>
  </data>
  <data name="crefQuotationsCantContainInlineIL" xml:space="preserve">
    <value>Les quotations ne peuvent pas contenir de code assembleur inline ou de critères spéciaux dans les tableaux</value>
  </data>
  <data name="tcObjectsMustBeInitializedWithObjectExpression" xml:space="preserve">
    <value>Les objets doivent être initialisés par une expression de construction d'objet qui appelle un constructeur d'objet hérité et assigne une valeur à chaque champ</value>
  </data>
  <data name="tcUnrecognizedQueryBinaryOperator" xml:space="preserve">
    <value>Les arguments des opérateurs de requête nécessitent des parenthèses, par exemple where (x &gt; y)' ou 'groupBy (x.Length / 10)'</value>
  </data>
  <data name="optsWarn" xml:space="preserve">
    <value>Définir un niveau d'avertissement (0-5)</value>
  </data>
  <data name="optsHelp" xml:space="preserve">
    <value>Affiche ce message d'utilisation (forme abrégée : -?)</value>
  </data>
  <data name="fscSystemRuntimeInteropServicesIsRequired" xml:space="preserve">
    <value>L'assembly System.Runtime.InteropServices est requis pour l'utilisation de classes UnknownWrapper\DispatchWrapper.</value>
  </data>
  <data name="typeInfoModule" xml:space="preserve">
    <value>module</value>
  </data>
  <data name="astInvalidExprLeftHandOfAssignment" xml:space="preserve">
    <value>Expression non valide à gauche de l'assignation</value>
  </data>
  <data name="tcInvalidInlineSpecification" xml:space="preserve">
    <value>Spécification inline non valide</value>
  </data>
  <data name="keywordDescriptionTypedQuotation" xml:space="preserve">
    <value>Délimite une quotation de code typé.</value>
  </data>
  <data name="tcMemberKindPropertyGetSetNotExpected" xml:space="preserve">
    <value>MemberKind.PropertyGetSet attendu uniquement dans les arborescences d'analyse</value>
  </data>
  <data name="pathIsInvalid" xml:space="preserve">
    <value>Problème avec le nom de fichier '{0}' : caractères non valides dans le chemin.</value>
  </data>
  <data name="loadingDescription" xml:space="preserve">
    <value>(chargement de la description...)</value>
  </data>
  <data name="csTypeDoesNotSupportComparison3" xml:space="preserve">
    <value>Le type '{0}' ne prend pas en charge la contrainte 'comparison', car il s'agit d'un enregistrement, d'une union ou d'une structure avec un ou plusieurs types d'éléments structurels qui ne prennent pas en charge la contrainte 'comparison'. Vous devez soit éviter d'utiliser la comparaison avec ce type, soit ajouter l'attribut 'StructuralComparison' au type pour identifier le type de champ qui ne prend pas en charge la comparaison</value>
  </data>
  <data name="csTypeDoesNotSupportComparison2" xml:space="preserve">
    <value>Le type '{0}' ne prend pas en charge la contrainte 'comparison'. Par exemple, il ne prend pas en charge l'interface 'System.IComparable'</value>
  </data>
  <data name="csTypeDoesNotSupportComparison1" xml:space="preserve">
    <value>Le type '{0}' ne prend pas en charge la contrainte 'comparison', car il a l'attribut 'NoComparison'</value>
  </data>
  <data name="notAFunctionButMaybeIndexerErrorCode" xml:space="preserve">
    <value>
    </value>
  </data>
  <data name="tcConditionalAttributeUsage" xml:space="preserve">
    <value>L'attribute 'System.Diagnostics.ConditionalAttribute' n'est valide que sur les méthodes ou les classes d'attributs</value>
  </data>
  <data name="ExceptionDefsNotCompatibleDotNetRepresentationsDiffer" xml:space="preserve">
    <value>Les définitions de l'exception ne sont pas compatibles, car les représentations CLI sont différentes. Le module contient la définition de l'exception\n    {0}    \nmais sa signature spécifie\n\t{1}</value>
  </data>
  <data name="parsSyntaxErrorInLabeledType" xml:space="preserve">
    <value>Erreur de syntaxe dans l'argument de type étiqueté</value>
  </data>
  <data name="tcPropertyRequiresExplicitTypeParameters" xml:space="preserve">
    <value>Une propriété ne peut pas avoir de paramètres de type explicite. Utilisez une méthode à la place.</value>
  </data>
  <data name="optsUtf8output" xml:space="preserve">
    <value>Messages de sortie au format d'encodage UTF-8</value>
  </data>
  <data name="tastConflictingModuleAndTypeDefinitionInAssembly" xml:space="preserve">
    <value>Une définition de module et une définition de type nommées '{0}' sont présentes dans l'espace de noms '{1}' dans deux parties de cet assembly</value>
  </data>
  <data name="tcNameNotBoundInPattern" xml:space="preserve">
    <value>Nom '{0}' non lié dans le contexte du modèle</value>
  </data>
  <data name="etTypeProviderConstructorException" xml:space="preserve">
    <value>Le constructeur du fournisseur de type a levé une exception : {0}</value>
  </data>
  <data name="etUnknownStaticArgumentKind" xml:space="preserve">
    <value>Genre d'argument statique inconnu '{0}' durant la résolution d'une référence à un type ou une méthode fournie '{1}'</value>
  </data>
  <data name="tcCustomOperationInvalid" xml:space="preserve">
    <value>La définition de l'opérateur personnalisé '{0}' n'utilise pas de combinaison d'indicateurs d'attributs valide</value>
  </data>
  <data name="ilStaticMethodIsNotLambda" xml:space="preserve">
    <value>GenSetStorage : {0} a été représenté en tant que méthode statique mais n'était pas une expression lambda appropriée</value>
  </data>
  <data name="lexOutsideEightBitUnsigned" xml:space="preserve">
    <value>Ce nombre se trouve en dehors de la plage autorisée pour les entiers non signés 8 bits</value>
  </data>
  <data name="parsAttributesIgnored" xml:space="preserve">
    <value>Les attributs ont été ignorés dans cette construction</value>
  </data>
  <data name="tcOperatorRequiresIn" xml:space="preserve">
    <value>'{0}' doit être suivi de 'in'. Utilisation : {1}.</value>
  </data>
  <data name="tcImplementsIEquatableExplicitly" xml:space="preserve">
    <value>Le type struct, enregistrement ou union '{0}' implémente explicitement l'interface 'System.IEquatable&lt;_&gt;'. Appliquez l'attribut 'CustomEquality' au type et fournissez une implémentation cohérente de la substitution non générique 'System.Object.Equals(obj)'.</value>
  </data>
  <data name="srcFileTooLarge" xml:space="preserve">
    <value>Le fichier source est trop grand pour être incorporé dans un fichier PDB portable</value>
  </data>
  <data name="tcObjectConstructorRequiresArgument" xml:space="preserve">
    <value>Un constructeur d'objet requiert un argument</value>
  </data>
  <data name="pickleErrorReadingWritingMetadata" xml:space="preserve">
    <value>Erreur lors de la lecture/l'écriture des métadonnées de la DLL compilée F# '{0}'. Est-ce que la DLL a été compilée avec une version antérieure du compilateur F# ? (erreur : '{1}').</value>
  </data>
  <data name="tcMemberOverridesIllegalInInterface" xml:space="preserve">
    <value>Les interfaces ne peuvent pas contenir de définitions de substitutions de membres</value>
  </data>
  <data name="tcMultipleVisibilityAttributes" xml:space="preserve">
    <value>Plusieurs attributs de visibilité ont été spécifiés pour cet identificateur</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureIsAbstract" xml:space="preserve">
    <value>Les {0} définitions pour le type '{1}' dans la signature et l'implémentation ne sont pas compatibles, car la signature est une classe abstraite, contrairement à l'implémentation. Ajoutez l'attribut [&lt;AbstractClass&gt;] à l'implémentation.</value>
  </data>
  <data name="etNullMemberDeclaringTypeDifferentFromProvidedType" xml:space="preserve">
    <value>Le type fourni '{0}' a un membre '{1}' de type déclarant '{2}'. Le type déclarant attendu est le même que le type fourni.</value>
  </data>
  <data name="parsUnmatchedClassInterfaceOrStruct" xml:space="preserve">
    <value>'class', 'interface' ou 'struct' non apparié</value>
  </data>
  <data name="keywordDescriptionNamespace" xml:space="preserve">
    <value>Permet d'associer un nom à un groupe de types et de modules connexes, pour le séparer de manière logique du reste du code.</value>
  </data>
  <data name="undefinedNameNamespaceOrModule" xml:space="preserve">
    <value>L'espace de noms ou le module '{0}' n'est pas défini.</value>
  </data>
  <data name="tcUnionCaseRequiresOneArgument" xml:space="preserve">
    <value>Ce cas d'union accepte un argument</value>
  </data>
  <data name="parsUnexpectedEmptyModuleDefn" xml:space="preserve">
    <value>Liste moduleDefn de type vide inattendue</value>
  </data>
  <data name="keywordDescriptionWhen" xml:space="preserve">
    <value>Utilisé pour les conditions booléennes (when guards) sur des critères spéciaux et pour introduire une clause de contrainte d'un paramètre de type générique.</value>
  </data>
  <data name="keywordDescriptionWith" xml:space="preserve">
    <value>Utilisé avec le mot clé match dans les expressions de critères spéciaux. Également utilisé dans les expressions d'objet, les expressions de copie d'enregistrement et les extensions de type pour introduire des définitions de membre et des gestionnaires d'exceptions.</value>
  </data>
  <data name="keywordDescriptionVoid" xml:space="preserve">
    <value>Indique le type void .NET. Utilisé durant l'interaction avec d'autres langages .NET.</value>
  </data>
  <data name="keywordDescriptionThen" xml:space="preserve">
    <value>Utilisé dans les expressions conditionnelles. Utilisé également pour provoquer des effets secondaires après une construction d'objet.</value>
  </data>
  <data name="keywordDescriptionType" xml:space="preserve">
    <value>Permet de déclarer une classe, un enregistrement, une structure, une union discriminée, un type énumération, une unité de mesure ou une abréviation de type.</value>
  </data>
  <data name="keywordDescriptionOpen" xml:space="preserve">
    <value>Permet de rendre disponible le contenu d'un espace de noms ou d'un module sans qualification.</value>
  </data>
  <data name="keywordDescriptionNull" xml:space="preserve">
    <value>Indique l'absence d'un objet. Utilisé également dans les contraintes de paramètre générique.</value>
  </data>
  <data name="keywordDescriptionCast" xml:space="preserve">
    <value>Convertit un type en type supérieur dans la hiérarchie.</value>
  </data>
  <data name="keywordDescriptionBase" xml:space="preserve">
    <value>Utilisé comme nom de l'objet de classe de base.</value>
  </data>
  <data name="keywordDescriptionLazy" xml:space="preserve">
    <value>Permet de spécifier un calcul à effectuer uniquement quand un résultat est nécessaire.</value>
  </data>
  <data name="keywordDescriptionElse" xml:space="preserve">
    <value>Utilisé dans la création de branche conditionnelle.</value>
  </data>
  <data name="keywordDescriptionElif" xml:space="preserve">
    <value>Utilisé dans la création de branche conditionnelle. Forme abrégée d'else if.</value>
  </data>
  <data name="keywordDescriptionDone" xml:space="preserve">
    <value>En syntaxe détaillée, indique la fin d'un bloc de code dans une expression de boucle.</value>
  </data>
  <data name="impReferenceToDllRequiredByAssembly" xml:space="preserve">
    <value>Une référence à la DLL {0} est requise par l'assembly {1}. Le type importé {2} se trouve dans le premier assembly et n'a pas pu être résolu.</value>
  </data>
  <data name="lexOusideThirtyTwoBitFloat" xml:space="preserve">
    <value>Ce nombre se trouve en dehors de la plage autorisée pour les valeurs float 32 bits</value>
  </data>
  <data name="tcTypeDefinitionsWithImplicitConstructionMustHaveOneInherit" xml:space="preserve">
    <value>Les définitions de type ne peuvent avoir qu'une spécification 'inherit' et il doit s'agir de la première déclaration</value>
  </data>
  <data name="tcLiteralCannotHaveGenericParameters" xml:space="preserve">
    <value>Les valeurs littérales ne peuvent pas avoir de paramètres génériques</value>
  </data>
  <data name="parsUnexpectedQuotationOperatorInTypeAliasDidYouMeanVerbatimString" xml:space="preserve">
    <value>Opérateur de citation inattendu '&lt;@' dans la définition de type. Si vous envisagez de passer une chaîne textuelle en tant qu'argument statique à un fournisseur de type, insérez un espace entre les caractères '&lt;' et '@'.</value>
  </data>
  <data name="tcInvalidOperatorDefinitionRelational" xml:space="preserve">
    <value>Normalement, l'opérateur '{0}' ne doit pas être redéfini. Pour définir une sémantique de comparaison surchargée pour un type particulier, implémentez l'interface 'System.IComparable' dans la définition de ce type.</value>
  </data>
  <data name="chkCurriedMethodsCantHaveOutParams" xml:space="preserve">
    <value>Les méthodes avec des arguments curryfiés ne peuvent pas déclarer d'arguments 'out', 'ParamArray', 'optional', 'ReflectedDefinition', 'byref', 'CallerLineNumber', 'CallerMemberName' ou 'CallerFilePath'</value>
  </data>
  <data name="buildPdbRequiresDebug" xml:space="preserve">
    <value>L'option '--pdb' requiert l'utilisation de l'option '--debug'</value>
  </data>
  <data name="optValueMarkedInlineButWasNotBoundInTheOptEnv" xml:space="preserve">
    <value>La valeur '{0}' a été marquée comme inline mais n'a pas été liée dans l'environnement d'optimisation</value>
  </data>
  <data name="tcPropertyIsStatic" xml:space="preserve">
    <value>La propriété '{0}' est statique</value>
  </data>
  <data name="tcNoComparisonNeeded1" xml:space="preserve">
    <value>Le type struct, enregistrement ou union '{0}' n'est pas structurellement comparable, car le paramètre de type {1} ne satisfait pas la contrainte 'comparison'. Ajoutez l'attribut 'NoComparison' au type '{2}' pour préciser que le type n'est pas comparable</value>
  </data>
  <data name="tcNoComparisonNeeded2" xml:space="preserve">
    <value>Le type struct, enregistrement ou union '{0}' n'est pas structurellement comparable, car le type '{1}' ne satisfait pas la contrainte 'comparison'. Ajoutez l'attribut 'NoComparison' au type '{2}' pour préciser que le type n'est pas comparable</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplDefinesStruct" xml:space="preserve">
    <value>Les {0} définitions pour le type '{1}' dans la signature et l'implémentation ne sont pas compatibles, car l'implémentation définit un struct alors que la signature définit un type avec une représentation masquée</value>
  </data>
  <data name="tlrLambdaLiftingOptimizationsNotApplied" xml:space="preserve">
    <value>Remarque : les optimisations par suppression d'expressions lambda n'ont pas été appliquées en raison de l'utilisation de cette fonction générique contrainte locale en tant que valeur de première classe. L'ajout de contraintes de type peut résoudre ce problème.</value>
  </data>
  <data name="tcUseForInSequenceExpression" xml:space="preserve">
    <value>L'utilisation de 'let! x = coll' dans les expressions de séquence n'est pas autorisée. Utilisez 'for x in coll' à la place.</value>
  </data>
  <data name="FieldNotContainedMutablesDiffer" xml:space="preserve">
    <value>Le module contient le champ\n    {0}    \nmais sa signature spécifie\n    {1}    \nLes modificateurs 'mutable' sont différents</value>
  </data>
  <data name="ilwriteMDBFileNameCannotBeChangedWarning" xml:space="preserve">
    <value>Le nom du fichier MDB doit être &lt;nom-fichier-assembly&gt;.mdb. L'option --pdb sera ignorée.</value>
  </data>
  <data name="ValueNotContainedMutabilityStaticButInstance" xml:space="preserve">
    <value>Le module '{0}' contient\n    {1}    \nmais sa signature spécifie\n    {2}    \nLa représentation compilée de cette méthode est celle d'un membre statique, mais la signature indique que sa représentation compilée est celle d'un membre d'instance</value>
  </data>
  <data name="ilDllImportAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>Impossible de décoder l'attribut DllImport</value>
  </data>
  <data name="chkBaseUsedInInvalidWay" xml:space="preserve">
    <value>Le mot clé 'base' est utilisé de manière incorrecte. Impossible d'utiliser les appels de base dans les fermetures. Utilisez un membre privé pour effectuer les appels de base.</value>
  </data>
  <data name="tcNewMustBeUsedWithNamedType" xml:space="preserve">
    <value>'new' doit être utilisé avec un type nommé</value>
  </data>
  <data name="tcTypeAbbreviationHasTypeParametersMissingOnType" xml:space="preserve">
    <value>Cette abréviation de type a un ou plusieurs paramètres de type déclarés qui n'apparaissent pas dans le type abrégé. Les abréviations de type doivent utiliser tous les paramètres de type déclarés dans le type abrégé. Supprimez un ou plusieurs paramètres de type, ou utilisez une définition de type concret qui inclut dans un wrapper un type sous-jacent, par exemple 'type C&lt;'a&gt; = C of ...'.</value>
  </data>
  <data name="optsResponseFileNameInvalid" xml:space="preserve">
    <value>Le nom du fichier réponse '{0}' est vide, contient des caractères non valides, spécifie un lecteur sans chemin absolu, ou est trop long</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAccessibilityDiffer" xml:space="preserve">
    <value>Les {0} définitions pour le type '{1}' dans la signature et l'implémentation ne sont pas compatibles, car l'accessibilité spécifiée dans la signature est supérieure à celle spécifiée dans l'implémentation</value>
  </data>
  <data name="tcNoPropertyFoundForOverride" xml:space="preserve">
    <value>Impossible de trouver une propriété abstraite qui corresponde à cette substitution</value>
  </data>
  <data name="astParseEmbeddedILError" xml:space="preserve">
    <value>Erreur lors de l'analyse du code IL (Intermediate Language) incorporé</value>
  </data>
  <data name="tcDllImportStubsCannotBeInlined" xml:space="preserve">
    <value>Impossible d'utiliser des stubs DLLImport inline</value>
  </data>
  <data name="tcIllegalPattern" xml:space="preserve">
    <value>Modèle non conforme</value>
  </data>
  <data name="tcSimpleMethodNameRequired" xml:space="preserve">
    <value>Un nom de méthode simple est requis ici</value>
  </data>
  <data name="tcAutoPropertyRequiresImplicitConstructionSequence" xml:space="preserve">
    <value>Les définitions 'member val' sont uniquement autorisées dans les types avec un constructeur principal. Ajoutez des arguments à votre définition de type, par exemple 'type X(args) =…'.</value>
  </data>
  <data name="forFlagSetTwice" xml:space="preserve">
    <value>Indicateur '{0}' défini à deux reprises</value>
  </data>
  <data name="crefQuotationsCantContainObjExprs" xml:space="preserve">
    <value>Les quotations ne peuvent pas contenir d'expressions d'objet</value>
  </data>
  <data name="optValueMarkedInlineHasUnexpectedValue" xml:space="preserve">
    <value>Une valeur marquée comme 'inline' a une valeur inattendue</value>
  </data>
  <data name="tcMatchMayNotBeUsedWithQuery" xml:space="preserve">
    <value>Les expressions 'match' ne peuvent pas être utilisées dans les requêtes</value>
  </data>
  <data name="chkPropertySameNameIndexer" xml:space="preserve">
    <value>La propriété '{0}' a le même nom qu'une autre propriété dans le type '{1}'. Toutefois, l'une d'elles accepte les arguments de l'indexeur mais pas l'autre. Il manque peut-être un argument d'indexeur dans l'une de vos propriétés.</value>
  </data>
  <data name="lexIdentEndInMarkReserved" xml:space="preserve">
    <value>Les identificateurs suivis de '{0}' sont réservés pour un usage futur</value>
  </data>
  <data name="tcExplicitTypeParameterInvalid" xml:space="preserve">
    <value>Les paramètres de type explicite ne peuvent être utilisés que sur les liaisons de module ou de membre</value>
  </data>
  <data name="etPropertyHasSetterButNoCanWrite" xml:space="preserve">
    <value>La propriété '{0}' sur le type fourni '{1}' a CanWrite=false, mais GetSetMethod() a retourné une méthode</value>
  </data>
  <data name="optsEmitDebugInfoInQuotations" xml:space="preserve">
    <value>Émettre les informations de débogage entre quotations</value>
  </data>
  <data name="optsNowin32manifest" xml:space="preserve">
    <value>Ne pas inclure le manifeste Win32 par défaut</value>
  </data>
  <data name="typeInfoActiveRecognizer" xml:space="preserve">
    <value>module de reconnaissance actif</value>
  </data>
  <data name="tcCompiledNameAttributeMisused" xml:space="preserve">
    <value>Impossible d'utiliser l'attribut 'CompiledName' avec cet élément de langage</value>
  </data>
  <data name="keywordDescriptionMutable" xml:space="preserve">
    <value>Permet de déclarer une variable, c'est-à-dire une valeur qui peut être modifiée.</value>
  </data>
  <data name="buildSignatureAlreadySpecified" xml:space="preserve">
    <value>Une signature pour le fichier ou le module '{0}' a déjà été spécifiée</value>
  </data>
  <data name="crefQuotationsCantSetUnionFields" xml:space="preserve">
    <value>Les quotations ne peuvent pas contenir d'expressions qui définissent des champs de cas d'union</value>
  </data>
  <data name="tcTypeDefinitionIsCyclic" xml:space="preserve">
    <value>Cette définition de type implique une référence cyclique immédiate via une abréviation</value>
  </data>
  <data name="optsInvalidTargetProfile" xml:space="preserve">
    <value>Valeur '{0}' non valide pour '--targetprofile'. Les valeurs valides sont 'mscorlib', 'netcore' ou 'netstandard'.</value>
  </data>
  <data name="parsUseBindingsIllegalInImplicitClassConstructors" xml:space="preserve">
    <value>Les liaisons 'use' ne sont pas autorisées dans les constructeurs principaux</value>
  </data>
  <data name="tcStructsCanOnlyBindThisAtMemberDeclaration" xml:space="preserve">
    <value>Les structs ne peuvent lier un paramètre 'this' que dans les déclarations de membre</value>
  </data>
  <data name="parsAllEnumFieldsRequireValues" xml:space="preserve">
    <value>Tous les champs enum doivent recevoir des valeurs</value>
  </data>
  <data name="parsIllegalMemberVarInObjectImplementation" xml:space="preserve">
    <value>Les définitions 'member val' et 'override val' ne sont pas autorisées dans les expressions d'objet.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleAbbreviationHiddenBySignature" xml:space="preserve">
    <value>Les définitions de l'exception ne sont pas compatibles, car l'abréviation de l'exception est masquée par la signature. L'abréviation doit être visible par les autres langages CLI. Rendez l'abréviation visible dans la signature. Le module contient la définition de l'exception\n    {0}    \nmais sa signature spécifie\n\t{1}.</value>
  </data>
  <data name="keywordDescriptionFinally" xml:space="preserve">
    <value>Utilisé avec try pour introduire un bloc de code qui s'exécute indépendamment de toute exception.</value>
  </data>
  <data name="ilCustomMarshallersCannotBeUsedInFSharp" xml:space="preserve">
    <value>Impossible de spécifier des marshaleurs personnalisés en F#. Utilisez une fonction d'assistance C#.</value>
  </data>
  <data name="typrelOverloadNotFound" xml:space="preserve">
    <value>Aucune implémentation de '{0}' n'avait le nombre approprié d'arguments et de paramètres de type. La signature requise est '{1}'.</value>
  </data>
  <data name="tcMethodOverridesIllegalHere" xml:space="preserve">
    <value>Les substitutions de méthodes et les implémentations d'interfaces ne sont pas autorisées ici</value>
  </data>
  <data name="ilFieldOffsetAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>Impossible de décoder l'attribut FieldOffset</value>
  </data>
  <data name="buildSignatureWithoutImplementation" xml:space="preserve">
    <value>Le fichier de signature '{0}' n'a pas de fichier d'implémentation correspondant. S'il existe un fichier d'implémentation, vérifiez que les déclarations 'module' et 'namespace' correspondent entre les fichiers de signature et d'implémentation.</value>
  </data>
  <data name="tcInvalidIndexOperatorDefinition" xml:space="preserve">
    <value>Impossible de redéfinir l'opérateur '{0}'. Utilisez un autre nom d'opérateur</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSigHasAbbreviation" xml:space="preserve">
    <value>Les {0} définitions pour le type '{1}' dans la signature et l'implémentation ne sont pas compatibles, car la signature a une abréviation, contrairement à l'implémentation</value>
  </data>
  <data name="undefinedNameTypeParameter" xml:space="preserve">
    <value>Le paramètre de type '{0}' n'est pas défini.</value>
  </data>
  <data name="keywordDescriptionInherit" xml:space="preserve">
    <value>Permet de spécifier une classe de base ou une interface de base.</value>
  </data>
  <data name="lexfltTokenIsOffsideOfContextStartedEarlier" xml:space="preserve">
    <value>Mise en retrait éventuellement incorrecte : ce jeton est situé hors du contexte qui débute à la position {0}. Essayez d'effectuer une mise en retrait supplémentaire de ce jeton ou d'utiliser des conventions de mise en forme standard.</value>
  </data>
  <data name="ValueNotContainedMutabilityDisplayNamesDiffer" xml:space="preserve">
    <value>Le module '{0}' contient\n    {1}    \nmais sa signature spécifie\n    {2}    \nLes noms complets sont différents</value>
  </data>
  <data name="tastConstantExpressionOverflow" xml:space="preserve">
    <value>Cette expression littérale ou cet argument d'attribut engendre un dépassement arithmétique.</value>
  </data>
  <data name="tcOptionalArgumentsCannotBeUsedInCustomAttribute" xml:space="preserve">
    <value>Impossible d'utiliser les arguments facultatifs dans les attributs personnalisés</value>
  </data>
  <data name="optsStaticlink" xml:space="preserve">
    <value>Lier statiquement l'assembly donné et toutes les DLL référencées qui en dépendent. Utilisez un nom d'assembly tel que mylib au lieu d'un nom de DLL.</value>
  </data>
  <data name="parsEofInVerbatimStringInComment" xml:space="preserve">
    <value>Fin de fichier dans la chaîne textuelle incorporée dans le commentaire ayant débuté à cet emplacement ou avant</value>
  </data>
  <data name="ValueNotContainedMutabilityLiteralConstantValuesDiffer" xml:space="preserve">
    <value>Le module '{0}' contient\n    {1}    \nmais sa signature spécifie\n    {2}    \nLes valeurs et/ou attributs de constante littérale sont différents</value>
  </data>
  <data name="lexThisUnicodeOnlyInStringLiterals" xml:space="preserve">
    <value>Cet encodage Unicode est uniquement valide dans les littéraux de chaîne</value>
  </data>
  <data name="tcCallerInfoNotOptional" xml:space="preserve">
    <value>'{0}' peut uniquement être appliqué à des arguments facultatifs</value>
  </data>
  <data name="ilAddressOfValueHereIsInvalid" xml:space="preserve">
    <value>Cette opération implique l'acceptation de l'adresse d'une valeur '{0}' représentée à l'aide d'une variable locale ou de toute autre représentation spéciale. Ceci n'est pas valide.</value>
  </data>
  <data name="optsNoframework" xml:space="preserve">
    <value>Ne pas référencer les assemblys CLI par défaut</value>
  </data>
  <data name="buildExpectedFileAlongSideFSharpCore" xml:space="preserve">
    <value>Fichier '{0}' introuvable avec FSharp.Core. Fichier attendu dans {1}. Effectuez une mise à niveau vers une version plus récente de FSharp.Core, où ce fichier n'est plus nécessaire.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull" xml:space="preserve">
    <value>Les {0} définitions pour le type '{1}' dans la signature et l'implémentation ne sont pas compatibles, car la signature indique que ce type peut utiliser des valeurs Null comme représentation, contrairement à l'implémentation</value>
  </data>
  <data name="parsEofInComment" xml:space="preserve">
    <value>Fin de fichier dans le commentaire ayant débuté à cet emplacement ou avant</value>
  </data>
  <data name="csMemberHasNoArgumentOrReturnProperty" xml:space="preserve">
    <value>Le membre ou le constructeur d'objet '{0}' n'a aucun argument ou aucune propriété de retour définissable '{1}'. {2}.</value>
  </data>
  <data name="etUnsupportedConstantType" xml:space="preserve">
    <value>Type de constante '{0}' non pris en charge. Les quotations fournies par les fournisseurs de type peuvent uniquement contenir des constantes simples. L'implémentation du fournisseur de type peut nécessiter un ajustement consistant à remplacer une valeur déclarée en dehors d'un littéral de quotation fourni par une liaison 'let' au sein du littéral de quotation.</value>
  </data>
  <data name="patcPartialActivePatternsGenerateOneResult" xml:space="preserve">
    <value>Les modèles actifs partiels ne peuvent générer qu'un seul résultat</value>
  </data>
  <data name="typeIsNotAccessible" xml:space="preserve">
    <value>Le type '{0}' n'est pas accessible à partir de cet emplacement du code</value>
  </data>
  <data name="tcListLiteralMaxSize" xml:space="preserve">
    <value>Cette expression de liste dépasse la taille maximale des littéraux de liste. Utilisez un tableau pour des littéraux plus importants et appelez Array.ToList.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSealed" xml:space="preserve">
    <value>Les {0} définitions pour le type '{1}' dans la signature et l'implémentation ne sont pas compatibles, car le type de l'implémentation est sealed alors que la signature implique le contraire. Ajoutez l'attribut [&lt;Sealed&gt;] à la signature.</value>
  </data>
  <data name="tcNamedArgumentDidNotMatch" xml:space="preserve">
    <value>L'argument nommé '{0}' ne correspond à aucun argument, ni à aucune propriété mutable</value>
  </data>
  <data name="tcInvalidConstraintTypeSealed" xml:space="preserve">
    <value>Contrainte non valide : le type utilisé pour la contrainte est sealed, ce qui signifie que la contrainte ne peut être satisfaite que par une seule solution</value>
  </data>
  <data name="lexUnexpectedChar" xml:space="preserve">
    <value>Caractère inattendu '{0}'</value>
  </data>
  <data name="ExceptionDefsNotCompatibleHiddenBySignature" xml:space="preserve">
    <value>Les définitions de l'exception ne sont pas compatibles, car le mappage d'une exception CLI est masqué par une signature. Le mappage de l'exception doit être visible par les autres modules. Le module contient la définition de l'exception\n    {0}    \nmais sa signature spécifie\n\t{1}</value>
  </data>
  <data name="parsIgnoreAttributesOnModuleAbbreviation" xml:space="preserve">
    <value>Attributs ignorés pour l'abréviation du module</value>
  </data>
  <data name="tcExpectedTypeNotUnitOfMeasure" xml:space="preserve">
    <value>Type attendu à la place d'une unité de mesure</value>
  </data>
  <data name="typrelTypeImplementsIComparableDefaultObjectEqualsProvided" xml:space="preserve">
    <value>Le type '{0}' implémente explicitement 'System.IComparable' mais ne fournit aucune substitution correspondante pour 'Object.Equals'. Une implémentation de 'Object.Equals' a été fournie automatiquement, implémentée via 'System.IComparable'. Implémentez explicitement la substitution 'Object.Equals'</value>
  </data>
  <data name="buildCouldNotResolveAssemblyRequiredByFile" xml:space="preserve">
    <value>Impossible de résoudre l'assembly '{0}' requis par '{1}'</value>
  </data>
  <data name="tastInvalidMutationOfConstant" xml:space="preserve">
    <value>Mutation non valide d'une expression constante. Copiez l'expression dans une variable locale mutable, par exemple 'let mutable x = ...'.</value>
  </data>
  <data name="optsWarnaserror" xml:space="preserve">
    <value>Signaler des avertissements spécifiques comme des erreurs</value>
  </data>
  <data name="considerUpcast" xml:space="preserve">
    <value>La conversion de {0} en {1} est un cast sécurisé d'un type dérivé en l'une de ses classes de base au moment de la compilation, et non un cast d'une classe de base en une classe dérivée. Utilisez 'upcast' à la place de 'downcast'.</value>
  </data>
  <data name="lexhlpIdentifierReserved" xml:space="preserve">
    <value>L'identificateur '{0}' est réservé pour un usage futur par F#</value>
  </data>
  <data name="buildMultiFileRequiresNamespaceOrModule" xml:space="preserve">
    <value>Les fichiers situés dans les bibliothèques ou les applications contenant plusieurs fichiers doivent commencer par une déclaration d'espace de noms ou de module, par exemple 'namespace SomeNamespace.SubNamespace' ou 'module SomeNamespace.SomeModule'. Seul le dernier fichier source d'une application peut omettre une telle déclaration.</value>
  </data>
  <data name="tcBindingCannotBeUseAndRec" xml:space="preserve">
    <value>Impossible de marquer une liaison à la fois 'use' et 'rec'</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeArgs" xml:space="preserve">
    <value>Fin d'entrée inattendue dans les arguments de type</value>
  </data>
  <data name="ValueNotContainedMutabilityVirtualsDiffer" xml:space="preserve">
    <value>Le module '{0}' contient\n    {1}    \nmais sa signature spécifie\n    {2}    \nL'un est virtuel mais pas l'autre</value>
  </data>
  <data name="astDeprecatedIndexerNotation" xml:space="preserve">
    <value>Cette notation de l'indexeur a été supprimée du langage F#</value>
  </data>
  <data name="tcTypeUsedInInvalidWay" xml:space="preserve">
    <value>Le type '{0}' est utilisé de manière incorrecte. Une valeur antérieure à '{1}' a un type déduit qui implique '{2}', qui est une référence anticipée non valide.</value>
  </data>
  <data name="chkDuplicateMethodWithSuffix" xml:space="preserve">
    <value>Méthode dupliquée. La méthode '{0}' a le même nom et la même signature qu'une autre méthode dans le type '{1}', une fois les tuples, fonctions, unités de mesure et/ou types fournis effacés.</value>
  </data>
  <data name="impNotEnoughTypeParamsInScopeWhileImporting" xml:space="preserve">
    <value>Erreur interne ou métadonnées incorrectes : nombre insuffisant de paramètres de type dans la portée lors de l'importation</value>
  </data>
  <data name="ilIncorrectNumberOfTypeArguments" xml:space="preserve">
    <value>Nombre incorrect d'arguments de type dans l'appel local</value>
  </data>
  <data name="parsSyntaxModuleSigEndDeprecated" xml:space="preserve">
    <value>La syntaxe 'module ... : sig .. end' n'est pas utilisée pour le code F#. Utilisez 'module ... = begin .. end'</value>
  </data>
  <data name="tcExpectedInterfaceType" xml:space="preserve">
    <value>Type interface attendu</value>
  </data>
  <data name="tcInvalidMemberNameFixedTypes" xml:space="preserve">
    <value>Le nom '({0})' ne doit pas être utilisé en tant que nom de membre, car il reçoit une définition standard dans la bibliothèque F# sur les types fixes</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeDefinition" xml:space="preserve">
    <value>Fin d'entrée inattendue dans la définition de type</value>
  </data>
  <data name="impInvalidMeasureArgument2" xml:space="preserve">
    <value>Valeur de paramètre d'unité de mesure non valide '{0}'</value>
  </data>
  <data name="impInvalidMeasureArgument1" xml:space="preserve">
    <value>Valeur non valide '{0}' pour le paramètre d'unité de mesure '{1}'</value>
  </data>
  <data name="tastInvalidFormForPropertyGetter" xml:space="preserve">
    <value>Forme non valide pour la méthode getter d'une propriété. Au moins un argument '()' est obligatoire lors de l'utilisation de la syntaxe explicite.</value>
  </data>
  <data name="etOneOrMoreErrorsSeenDuringExtensionTypeSetting" xml:space="preserve">
    <value>Une ou plusieurs erreurs se sont produites pendant la configuration du type fourni</value>
  </data>
  <data name="tcConstructorForInterfacesDoNotTakeArguments" xml:space="preserve">
    <value>Les expressions de constructeur pour les interfaces n'acceptent pas d'arguments</value>
  </data>
  <data name="optsInvalidWarningLevel" xml:space="preserve">
    <value>Niveau d'avertissement non valide '{0}'</value>
  </data>
  <data name="tcUnionCaseNameConflictsWithGeneratedType" xml:space="preserve">
    <value>Le cas d'union nommé '{0}' est en conflit avec le type généré '{1}'</value>
  </data>
  <data name="tcNoAbstractOrVirtualMemberFound" xml:space="preserve">
    <value>Le membre '{0}' ne correspond à aucune méthode abstraite ou virtuelle pouvant être substituée ou implémentée.</value>
  </data>
  <data name="tcInvalidRecordConstruction" xml:space="preserve">
    <value>Construction d'enregistrement non valide</value>
  </data>
  <data name="ModuleContainsConstructorButTypesOfFieldsDiffer" xml:space="preserve">
    <value>Le module contient le constructeur\n    {0}    \nmais sa signature spécifie\n    {1}    \nLes types des champs sont différents</value>
  </data>
  <data name="ilLabelNotFound" xml:space="preserve">
    <value>Étiquette {0} introuvable</value>
  </data>
  <data name="activePatternChoiceHasFreeTypars" xml:space="preserve">
    <value>Le modèle actif '{0}' a un type de résultat contenant des variables de type qui ne sont pas déterminées par l'entrée. Un cas de résultat n'est probablement pas mentionné, par ex. 'let (|A|B|) (x:int) = A x'. Cela peut être corrigé avec une contrainte de type, par ex. 'let (|A|B|) (x:int) : Choice&lt;int,unit&gt; = A x'</value>
  </data>
  <data name="csMemberSignatureMismatchArityNamed" xml:space="preserve">
    <value>Le membre ou le constructeur d'objet '{0}' requiert {1} argument(s) mais reçoit ici {2} argument(s) non nommé(s) et {3} argument(s) nommé(s). La signature requise est '{4}'.</value>
  </data>
  <data name="tastTypeOrModuleNotConcrete" xml:space="preserve">
    <value>Le type/module '{0}' n'est pas un module ou type concret</value>
  </data>
  <data name="optsHelpBannerOutputFiles" xml:space="preserve">
    <value>- FICHIERS DE SORTIE -</value>
  </data>
  <data name="csSeeAvailableOverloads" xml:space="preserve">
    <value>Les surcharges disponibles sont indiquées ci-dessous (ou dans la fenêtre Liste d'erreurs).</value>
  </data>
  <data name="tcCustomOperationHasIncorrectArgCount" xml:space="preserve">
    <value>'{0}' est utilisé avec un nombre d'arguments incorrect. Il s'agit d'une opération personnalisée dans cette requête ou cette expression de calcul. {1} argument(s) étai(en)t attendu(s), mais {2} ont été fournis.</value>
  </data>
  <data name="csMethodIsNotAnInstanceMethod" xml:space="preserve">
    <value>{0} n'est pas une méthode d'instance</value>
  </data>
  <data name="tcObjectExpressionFormDeprecated" xml:space="preserve">
    <value>Cette forme d'expression d'objet n'est pas utilisée en F#. Utilisez 'member this.MemberName ... = ...' pour définir des implémentations de membres dans les expressions d'objet.</value>
  </data>
  <data name="tcUnexpectedExprAtRecInfPoint" xml:space="preserve">
    <value>Expression inattendue au point d'inférence récursif</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInImpl" xml:space="preserve">
    <value>Les {0} définitions pour le type '{1}' dans la signature et l'implémentation ne sont pas compatibles, car le membre abstrait '{2}' a été requis par la signature mais n'a pas été spécifié par l'implémentation</value>
  </data>
  <data name="tcDoesNotAllowExplicitTypeArguments" xml:space="preserve">
    <value>La méthode ou fonction '{0}' ne doit pas recevoir d'arguments de type explicite, car elle ne déclare pas explicitement ses paramètres de type</value>
  </data>
  <data name="tastTypeHasAssemblyCodeRepresentation" xml:space="preserve">
    <value>Le type '{0}' a une représentation du code assembleur inline</value>
  </data>
  <data name="tastRecursiveValuesMayNotBeAssignedToNonMutableField" xml:space="preserve">
    <value>Impossible d'assigner directement les valeurs récursives au champ non mutable '{0}' du type '{1}' dans une liaison récursive. Utilisez un champ mutable à la place.</value>
  </data>
  <data name="optsMlcompatibility" xml:space="preserve">
    <value>Ignorer les avertissements de compatibilité ML</value>
  </data>
  <data name="memberOperatorDefinitionWithNoArguments" xml:space="preserve">
    <value>Le membre opérateur infixe '{0}' n'a aucun argument. Tuple de 2 arguments attendu. Exemple : static member (+) (x,y) = ...</value>
  </data>
  <data name="tcConcreteMembersIllegalInInterface" xml:space="preserve">
    <value>Les interfaces ne peuvent pas contenir de définitions de membres concrets. Vous pouvez définir un constructeur sur votre type pour indiquer que le type est une classe.</value>
  </data>
  <data name="parsMissingQualificationAfterDot" xml:space="preserve">
    <value>Qualification manquante après '.'</value>
  </data>
  <data name="nrTypeInstantiationIsMissingAndCouldNotBeInferred" xml:space="preserve">
    <value>L'instanciation du type générique '{0}' est manquante. Impossible de la déduire à partir des arguments ou du type de retour de ce membre. Fournissez une instanciation de type lors de l'accès à ce type. Exemple : '{1}'.</value>
  </data>
  <data name="parsActivePatternCaseMustBeginWithUpperCase" xml:space="preserve">
    <value>Les identificateurs de casse du modèle actif doivent commencer par une lettre majuscule</value>
  </data>
  <data name="forHIsUnnecessary" xml:space="preserve">
    <value>Le 'h' ou 'H' dans ce spécificateur de format est inutile. Vous pouvez utiliser %d, %x, %o ou %u à la place, qui sont surchargés pour fonctionner avec tous les types entiers de base.</value>
  </data>
  <data name="tcExpressionFormRequiresObjectConstructor" xml:space="preserve">
    <value>La forme d'expression 'expr then expr' ne peut être utilisée que dans le cadre d'un constructeur d'objet explicite</value>
  </data>
  <data name="chkLimitationsOfBaseKeyword" xml:space="preserve">
    <value>Les valeurs 'base' ne peuvent être utilisées que pour effectuer des appels directs aux implémentations de base des membres substitués</value>
  </data>
  <data name="tastNotAConstantExpression" xml:space="preserve">
    <value>Il ne s'agit pas d'une expression constante valide ou d'une valeur d'attribut personnalisé valide</value>
  </data>
  <data name="tcInvalidMixtureOfRecursiveForms" xml:space="preserve">
    <value>Cette liaison récursive utilise une combinaison non valide de formes récursives</value>
  </data>
  <data name="tcImplementsGenericIComparableExplicitly" xml:space="preserve">
    <value>Le type struct, enregistrement ou union '{0}' implémente explicitement l'interface 'System.IComparable&lt;_&gt;'. Vous devez appliquer l'attribut 'CustomComparison' au type et fournir une implémentation cohérente de l'interface non générique System.IComparable.</value>
  </data>
  <data name="tcInvalidAssignment" xml:space="preserve">
    <value>Assignation non valide</value>
  </data>
  <data name="parsEofInString" xml:space="preserve">
    <value>Fin de fichier dans la chaîne ayant débuté à cet emplacement ou avant</value>
  </data>
  <data name="chkFirstClassFuncNoByref" xml:space="preserve">
    <value>Une fonction de première classe ne peut pas contenir de types byref</value>
  </data>
  <data name="csTypeDoesNotSupportEquality2" xml:space="preserve">
    <value>Le type '{0}' ne prend pas en charge la contrainte 'equality', car il s'agit d'un type de fonction</value>
  </data>
  <data name="csTypeDoesNotSupportEquality3" xml:space="preserve">
    <value>Le type '{0}' ne prend pas en charge la contrainte 'equality', car il s'agit d'un enregistrement, d'une union ou d'une structure avec un ou plusieurs types d'éléments structurels qui ne prennent pas en charge la contrainte 'equality'. Vous devez soit éviter d'utiliser l'égalité avec ce type, soit ajouter l'attribut 'StructuralEquality' au type pour identifier le type de champ qui ne prend pas en charge l'égalité</value>
  </data>
  <data name="csTypeDoesNotSupportEquality1" xml:space="preserve">
    <value>Le type '{0}' ne prend pas en charge la contrainte 'equality', car il a l'attribut 'NoEquality'</value>
  </data>
  <data name="parsUnmatchedUseBang" xml:space="preserve">
    <value>Définition de valeur incomplète. S'il s'agit d'une expression, le corps de l'expression doit être mis en retrait sur la même colonne que le mot-clé 'use!'.</value>
  </data>
  <data name="parsNonAtomicType" xml:space="preserve">
    <value>L'utilisation de la syntaxe de type 'int C' et 'C  &lt;int&gt;' n'est pas autorisée ici. Modifiez ce type en l'écrivant sous la forme 'C&lt;int&gt;'</value>
  </data>
  <data name="forPrefixFlagSpacePlusSetTwice" xml:space="preserve">
    <value>Indicateur de préfixe (' ' ou '+') défini à deux reprises</value>
  </data>
  <data name="assemblyResolutionFoundByAssemblyFoldersKey" xml:space="preserve">
    <value>Trouvée par la clé de Registre AssemblyFolders</value>
  </data>
  <data name="tcConstructRequiresSequenceOrComputations" xml:space="preserve">
    <value>Cette construction ne peut être utilisée que dans des expressions de calcul ou de séquence</value>
  </data>
  <data name="astParseEmbeddedILTypeError" xml:space="preserve">
    <value>Erreur lors de l'analyse du type IL (Intermediate Language) incorporé</value>
  </data>
  <data name="tcIllegalAttributesForLiteral" xml:space="preserve">
    <value>Impossible de donner à une valeur littérale les attributs [&lt;ThreadStatic&gt;] ou [&lt;ContextStatic&gt;]</value>
  </data>
  <data name="etInvalidTypeProviderAssemblyName" xml:space="preserve">
    <value>L'assembly '{0}' a un attribut TypeProviderAssembly comportant la valeur non valide '{1}'. La valeur doit être un nom d'assembly valide</value>
  </data>
  <data name="tcFunctionRequiresExplicitLambda" xml:space="preserve">
    <value>Cette valeur de fonction est utilisée pour construire un type délégué dont la signature comprend un argument byref. Vous devez utiliser une expression lambda explicite qui accepte {0} arguments.</value>
  </data>
  <data name="tcAbbreviationsFordotNetExceptionsCannotTakeArguments" xml:space="preserve">
    <value>Les abréviations des exceptions CIL (Common Intermediate Language) ne peuvent pas accepter d'arguments</value>
  </data>
  <data name="tcEnumTypeCannotBeEnumerated" xml:space="preserve">
    <value>Le type '{0}' n'est pas un type d'énumérateur valide, c-à-d qu'il n'a pas de méthode 'MoveNext()' qui retourne une valeur booléenne, ni de propriété 'Current'</value>
  </data>
  <data name="parsEofInDirective" xml:space="preserve">
    <value>Fin de fichier dans la directive ayant débuté à cet emplacement ou avant</value>
  </data>
  <data name="forFormatDoesntSupportPrecision" xml:space="preserve">
    <value>Le format '{0}' ne prend pas en charge la précision</value>
  </data>
  <data name="tcConstructorRequiresCall" xml:space="preserve">
    <value>Les constructeurs du type '{0}' doivent directement ou indirectement appeler son constructeur d'objet implicite. Utilisez un appel au constructeur d'objet implicite à la place d'une expression d'enregistrement.</value>
  </data>
  <data name="tcCustomOperationNotUsedCorrectly" xml:space="preserve">
    <value>'{0}' n'est pas utilisé correctement. Il s'agit d'une opération personnalisée dans cette requête ou opération de calcul.</value>
  </data>
  <data name="parsUnmatchedLBrackLess" xml:space="preserve">
    <value>'[&lt;' sans correspondance. Une '&gt;]' fermante était attendue</value>
  </data>
  <data name="tcFixedNotAllowed" xml:space="preserve">
    <value>Utilisation non valide de 'fixed'. Utilisez uniquement 'fixed' dans une déclaration de la forme 'use x = fixed expr' où l'expression est un tableau, l'adresse d'un champ, l'adresse d'un élément de tableau ou une chaîne</value>
  </data>
  <data name="etIllegalCharactersInTypeName" xml:space="preserve">
    <value>Le caractère '{0}' n'est pas autorisé dans le nom de type fourni '{1}'</value>
  </data>
  <data name="etStaticParameterRequiresAValue" xml:space="preserve">
    <value>Le paramètre statique '{0}' du type ou de la méthode fournie '{1}' nécessite une valeur. Les paramètres statiques des fournisseurs de type peuvent être spécifiés de manière facultative à l'aide d'arguments nommés, par exemple '{2}&lt;{3}=...&gt;'.</value>
  </data>
  <data name="tcUnexpectedMeasureAnon" xml:space="preserve">
    <value>SynMeasure.Anon inattendu</value>
  </data>
  <data name="parsAssertIsNotFirstClassValue" xml:space="preserve">
    <value>'assert' ne peut pas être utilisé en tant que valeur de première classe. Utilisez 'assert &lt;expr&gt;' à la place.</value>
  </data>
  <data name="tcCannotInheritFromVariableType" xml:space="preserve">
    <value>Impossible d'hériter d'un type variable</value>
  </data>
  <data name="unionCasesAreNotAccessible" xml:space="preserve">
    <value>Les cas d'union ou champs du type '{0}' ne sont pas accessibles à partir de cet emplacement du code</value>
  </data>
  <data name="tcMutableValuesSyntax" xml:space="preserve">
    <value>Les valeurs de fonction mutables doivent être écrites 'let mutable f = (fun args -&gt; ...)'</value>
  </data>
  <data name="parsOnlyClassCanTakeValueArguments" xml:space="preserve">
    <value>Seuls les types classe peuvent accepter des arguments de valeur</value>
  </data>
  <data name="buildInvalidWarningNumber" xml:space="preserve">
    <value>Numéro d'avertissement non valide '{0}'</value>
  </data>
  <data name="csTypeHasNonStandardDelegateType" xml:space="preserve">
    <value>Le type '{0}' a un type délégué non standard</value>
  </data>
  <data name="tcArgumentArityMismatch" xml:space="preserve">
    <value>Le membre '{0}' n'accepte pas le nombre approprié d'arguments. {1} argument(s) attendu(s) mais {2} fournis. La signature nécessaire est '{3}'.{4}</value>
  </data>
  <data name="typeInfoPatternVariable" xml:space="preserve">
    <value>patvar</value>
  </data>
  <data name="ValueNotContainedMutabilityFinalsDiffer" xml:space="preserve">
    <value>Le module '{0}' contient\n    {1}    \nmais sa signature spécifie\n    {2}    \nL'un est final mais pas l'autre</value>
  </data>
  <data name="delegatesNotAllowedToHaveCurriedSignatures" xml:space="preserve">
    <value>Les délégués ne sont pas autorisés à avoir des signatures curryfiées</value>
  </data>
  <data name="optsPlatform" xml:space="preserve">
    <value>Limiter les plateformes sur lesquelles ce code peut s'exécuter : x86, Itanium, x64, anycpu32bitpreferred ou anycpu. La valeur par défaut est anycpu.</value>
  </data>
  <data name="tcExpectedUnitOfMeasureNotType" xml:space="preserve">
    <value>Unité de mesure attendue à la place d'un type</value>
  </data>
  <data name="optsWin32res" xml:space="preserve">
    <value>Spécifier un fichier de ressources Win32 (.res)</value>
  </data>
  <data name="tcLocalClassBindingsCannotBeInline" xml:space="preserve">
    <value>Impossible de marquer les liaisons de classe locales inline. Enlevez la définition de la classe ou ne la marquez pas inline.</value>
  </data>
  <data name="descriptionUnavailable" xml:space="preserve">
    <value>(description non disponible...)</value>
  </data>
  <data name="undefinedNameTypeIn" xml:space="preserve">
    <value>Le type '{0}' n'est pas défini dans '{1}'.</value>
  </data>
  <data name="parsIdentifierExpected" xml:space="preserve">
    <value>Identificateur attendu</value>
  </data>
  <data name="ppparsUnexpectedToken" xml:space="preserve">
    <value>Jeton '{0}' inattendu dans l'expression de préprocesseur</value>
  </data>
  <data name="forPrecisionMissingAfterDot" xml:space="preserve">
    <value>Précision manquante après le '.'</value>
  </data>
  <data name="crefNoSetOfHole" xml:space="preserve">
    <value>Une citation ne peut pas impliquer d'assignation à une variable locale capturée ou d'utilisation de l'adresse de cette dernière</value>
  </data>
  <data name="optsInternalNoDescription" xml:space="preserve">
    <value>L'option de ligne de commande '{0}' ne doit servir qu'à des fins de test</value>
  </data>
  <data name="yieldUsedInsteadOfYieldBang" xml:space="preserve">
    <value>Utilisez 'yield!' à la place de 'yield'.</value>
  </data>
  <data name="tcInheritedTypeIsNotObjectModelType" xml:space="preserve">
    <value>Le type hérité n'est pas un type de modèle objet</value>
  </data>
  <data name="ilMainModuleEmpty" xml:space="preserve">
    <value>Le module principal du programme est vide : rien ne se passera lors de son exécution</value>
  </data>
  <data name="fscAssemblyWildcardAndDeterminism" xml:space="preserve">
    <value>{0} a spécifié la version '{1}', mais cette valeur est un caractère générique, et comme vous avez demandé une build déterministe, il existe un conflit.</value>
  </data>
  <data name="fscResxSourceFileDeprecated" xml:space="preserve">
    <value>Le passage d'un fichier .resx ({0}) en tant que fichier source au compilateur est déconseillé. Utilisez resgen.exe pour transformer le fichier .resx file en fichier .resources devant être passé en tant qu'option --resource. Si vous utilisez MSBuild, vous pouvez effectuer cette opération via un élément &lt;EmbeddedResource&gt; dans le fichier de projet .fsproj.</value>
  </data>
  <data name="tcModuleAbbreviationForNamespace" xml:space="preserve">
    <value>Le chemin '{0}' est un espace de noms. Une abréviation de module ne peut pas être abrégée en espace de noms.</value>
  </data>
  <data name="tcValueInSignatureRequiresLiteralAttribute" xml:space="preserve">
    <value>Une déclaration ne peut recevoir de valeur dans une signature que si la déclaration a l'attribut [&lt;Literal&gt;]</value>
  </data>
  <data name="etProvidedTypeWithNameException" xml:space="preserve">
    <value>Une exception s'est produite lors de l'accès au '{0}' d'un type fourni : {1}</value>
  </data>
  <data name="keywordDescriptionInternal" xml:space="preserve">
    <value>Permet de spécifier qu'un membre est visible dans un assembly mais pas à l'extérieur de celui-ci.</value>
  </data>
  <data name="parsNoHashEndIfFound" xml:space="preserve">
    <value>#endif introuvable pour #if ou #else</value>
  </data>
  <data name="tastInvalidMemberSignature" xml:space="preserve">
    <value>Signature de membre non valide détectée en raison d'une erreur antérieure</value>
  </data>
  <data name="tcFieldNameConflictsWithGeneratedNameForAnonymousField" xml:space="preserve">
    <value>Le champ nommé '{0}' est en conflit avec le nom généré automatiquement pour le champ anonyme.</value>
  </data>
  <data name="buildInvalidHashtimeDirective" xml:space="preserve">
    <value>Directive non valide. '#time', '#time \"on\"' ou '#time \"off\"' attendu.</value>
  </data>
  <data name="parsEnumTypesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Les modificateurs d'accessibilité ne sont pas autorisés à cette position pour les types enum</value>
  </data>
  <data name="parsAttributesIllegalHere" xml:space="preserve">
    <value>Les attributs ne sont pas autorisés ici</value>
  </data>
  <data name="optsHelpBannerLanguage" xml:space="preserve">
    <value>- LANGAGE -</value>
  </data>
  <data name="optsUnrecognizedDebugType" xml:space="preserve">
    <value>Type de débogage '{0}' non reconnu, 'pdbonly' ou 'full' attendu</value>
  </data>
  <data name="tcIntoNeedsRestOfQuery" xml:space="preserve">
    <value>L'utilisation de 'into' doit être suivie du reste du calcul</value>
  </data>
  <data name="chkNoFirstClassRethrow" xml:space="preserve">
    <value>Les utilisations de première classe de la fonction 'reraise' ne sont pas autorisées</value>
  </data>
  <data name="parsMissingGreaterThan" xml:space="preserve">
    <value>'&lt;' sans correspondance. Une '&gt;' fermante était attendue</value>
  </data>
  <data name="tastUndefinedItemRefVal" xml:space="preserve">
    <value>Le module/l'espace de noms '{0}' de l'unité de compilation '{1}' ne contenait pas la valeur '{2}'</value>
  </data>
  <data name="tcFunctionRequiresExplicitTypeArguments" xml:space="preserve">
    <value>La fonction générique '{0}' doit recevoir un ou plusieurs arguments de type explicite</value>
  </data>
  <data name="etPropertyCanReadButHasNoGetter" xml:space="preserve">
    <value>La propriété '{0}' sur le type fourni '{1}' a CanRead=true, mais aucune valeur n'a été retournée par GetGetMethod()</value>
  </data>
  <data name="chkReturnTypeNoByref" xml:space="preserve">
    <value>Le type de retour d'une méthode contient des types byref, ce qui n'est pas autorisé</value>
  </data>
  <data name="tcEventIsStatic" xml:space="preserve">
    <value>L'événement '{0}' est statique</value>
  </data>
  <data name="lexTokenReserved" xml:space="preserve">
    <value>Ce jeton est réservé pour un usage futur</value>
  </data>
  <data name="tcOpenFirstInMutRec" xml:space="preserve">
    <value>Dans un groupe de déclarations récursives, les déclarations 'open' doivent figurer en premier dans chaque module</value>
  </data>
  <data name="etNullOrEmptyMemberName" xml:space="preserve">
    <value>Le type fourni '{0}' a retourné un membre avec un nom de membre Null ou vide</value>
  </data>
  <data name="forBadFormatSpecifier" xml:space="preserve">
    <value>Spécificateur de format incorrect (après l ou L) : ld,li,lo,lu,lx ou lX attendu. En F#, vous pouvez utiliser %d, %x, %o ou %u à la place, qui sont surchargés pour fonctionner avec tous les types entiers de base.</value>
  </data>
  <data name="infosInvalidProvidedLiteralValue" xml:space="preserve">
    <value>Valeur littérale fournie non valide '{0}'</value>
  </data>
  <data name="tcInterfaceTypesCannotBeSealed" xml:space="preserve">
    <value>Les types interface ne peuvent pas être sealed</value>
  </data>
  <data name="checkLowercaseLiteralBindingInPattern" xml:space="preserve">
    <value>Le littéral en minuscule '{0}' est actuellement caché par un nouveau modèle du même nom. Seuls les littéraux en majuscule préfixés avec un module peuvent être utilisés comme modèles nommés.</value>
  </data>
  <data name="ilUndefinedValue" xml:space="preserve">
    <value>Valeur non définie '{0}'</value>
  </data>
  <data name="tcConstructRequiresListArrayOrSequence" xml:space="preserve">
    <value>Cette construction ne peut être utilisée que dans des expressions de liste, de tableau et de séquence, par exemple des expressions sous la forme 'seq {{ ... }}', '[ ... ]' ou '[| ... |]'. Celles-ci utilisent la syntaxe 'for ... in ... do ... yield...' pour générer des éléments</value>
  </data>
  <data name="tcCustomAttributeMustBeReferenceType" xml:space="preserve">
    <value>Un attribut personnalisé doit être un type référence</value>
  </data>
  <data name="tcStaticFieldUsedWhenInstanceFieldExpected" xml:space="preserve">
    <value>Un champ statique a été utilisé à l'emplacement où un champ d'instance est attendu</value>
  </data>
  <data name="parsUnmatchedParen" xml:space="preserve">
    <value>'(' non apparié</value>
  </data>
  <data name="csMethodIsOverloaded" xml:space="preserve">
    <value>Impossible de déterminer une surcharge unique pour la méthode '{0}' basée sur des informations de type situées avant ce point du programme. Une annotation de type peut être ajoutée.</value>
  </data>
  <data name="csMemberIsNotAccessible" xml:space="preserve">
    <value>Le membre ou le constructeur d'objet '{0}' n'est pas {1}</value>
  </data>
  <data name="optsDebugPM" xml:space="preserve">
    <value>Émettre les informations de débogage (forme abrégée : -g)</value>
  </data>
  <data name="fscKeyFileWarning" xml:space="preserve">
    <value>L'option '--keyfile' remplace l'attribut 'System.Reflection.AssemblyKeyFileAttribute' fourni dans un fichier source ou un module ajouté</value>
  </data>
  <data name="optsResponseFile" xml:space="preserve">
    <value>Lire le fichier réponse pour plus d'options</value>
  </data>
  <data name="parsUnmatchedBrace" xml:space="preserve">
    <value>'{{' non apparié</value>
  </data>
  <data name="parsUnmatchedBegin" xml:space="preserve">
    <value>'begin' non apparié</value>
  </data>
  <data name="tcNonSimpleLetBindingInQuery" xml:space="preserve">
    <value>Cette définition 'let' ne peut pas être utilisée dans une requête. Seules les définitions de valeur simple peuvent être utilisées dans les requêtes.</value>
  </data>
  <data name="chkProtectedOrBaseCalled" xml:space="preserve">
    <value>Un membre protégé est appelé ou 'base' est utilisé. Cela n'est autorisé que dans l'implémentation directe des membres, car ils peuvent sortir de la portée de leurs objets.</value>
  </data>
  <data name="parsNonAdjacentTyargs" xml:space="preserve">
    <value>Les arguments de type doivent être directement adjacents au nom de type, par exemple \"C&lt;'T&gt;\" et non \"C  &lt;'T&gt;\"</value>
  </data>
  <data name="parsNonAdjacentTypars" xml:space="preserve">
    <value>Les paramètres de type doivent être directement adjacents au nom de type, par exemple \"type C&lt;'T&gt;\" et non type \"C   &lt;'T&gt;\"</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInPrintf" xml:space="preserve">
    <value>Impossible de résoudre l'ambigüité inhérente à l'utilisation d'une chaîne de format de style 'printf'</value>
  </data>
  <data name="parsErrorInReturnForLetIncorrectIndentation" xml:space="preserve">
    <value>Erreur dans l'expression de retour de ce 'let'. Mise en retrait éventuellement incorrecte.</value>
  </data>
  <data name="typrelCannotResolveImplicitGenericInstantiation" xml:space="preserve">
    <value>Impossible de résoudre l'instanciation implicite d'une construction générique à cet emplacement ou à proximité, car elle peut être résolue en plusieurs types non liés, par exemple '{0}' et '{1}'. Utilisez des annotations de type pour résoudre l'ambigüité</value>
  </data>
  <data name="tcOptionalArgsMustComeAfterNonOptionalArgs" xml:space="preserve">
    <value>Les arguments facultatifs doivent se trouver à la fin de la liste d'arguments, après les arguments non facultatifs</value>
  </data>
  <data name="parsErrorParsingAsOperatorName" xml:space="preserve">
    <value>La tentative d'analyse de cet élément en tant que nom d'opérateur a échoué</value>
  </data>
  <data name="optsReference" xml:space="preserve">
    <value>Référencer un assembly (forme abrégée : -r)</value>
  </data>
  <data name="assemblyResolutionFoundByAssemblyFoldersExKey" xml:space="preserve">
    <value>Trouvée par la clé de Registre AssemblyFoldersEx</value>
  </data>
  <data name="parsGetOrSetRequired" xml:space="preserve">
    <value>'get', 'set' ou 'get,set' requis</value>
  </data>
  <data name="buildArgInvalidFloat" xml:space="preserve">
    <value>'{0}' n'est pas un argument à virgule flottante valide</value>
  </data>
  <data name="optsDCLODeprecatedSuggestAlternative" xml:space="preserve">
    <value>L'option de ligne de commande '{0}' est déconseillée. Utilisez '{1}' à la place.</value>
  </data>
  <data name="augCustomEqNeedsObjEquals" xml:space="preserve">
    <value>Un type avec l'attribut 'CustomEquality' doit avoir au moins une implémentation explicite de 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' ou 'System.Collections.IStructuralEquatable'</value>
  </data>
  <data name="tcUnexpectedSymbolInTypeExpression" xml:space="preserve">
    <value>{0} inattendu dans l'expression de type</value>
  </data>
  <data name="tcUnrecognizedAttributeTarget" xml:space="preserve">
    <value>Cible d'attribut non reconnue. Les cibles d'attributs valides sont 'assembly', 'module', 'type', 'method', 'property', 'return', 'param', 'field', 'event', 'constructor'.</value>
  </data>
  <data name="parsMissingFunctionBody" xml:space="preserve">
    <value>Corps de la fonction manquant</value>
  </data>
  <data name="parsUnexpectedVisibilityDeclaration" xml:space="preserve">
    <value>Les modificateurs d'accessibilité ne sont pas autorisés ici mais '{0}' a été spécifié.</value>
  </data>
  <data name="tcTypesCannotContainNestedTypes" xml:space="preserve">
    <value>Les types ne peuvent pas contenir de définitions de type imbriquées</value>
  </data>
  <data name="optsConsoleColors" xml:space="preserve">
    <value>Générer les messages d'avertissement et d'erreur en couleur</value>
  </data>
  <data name="tcInvalidUseOfTypeName" xml:space="preserve">
    <value>Utilisation non valide d'un nom de type</value>
  </data>
  <data name="tastValueDoesNotHaveSetterType" xml:space="preserve">
    <value>Cette valeur n'a pas de type de méthode setter de propriété valide</value>
  </data>
  <data name="buildInvalidSearchDirectory" xml:space="preserve">
    <value>Le répertoire de recherche '{0}' n'est pas valide</value>
  </data>
  <data name="optsLinkresource" xml:space="preserve">
    <value>Lier la ressource spécifiée à cet assembly où le format resinfo est &lt;fichier&gt;[,&lt;nom de chaîne&gt;[,public|private]]</value>
  </data>
  <data name="parsIllegalDenominatorForMeasureExponent" xml:space="preserve">
    <value>La valeur de l’exposant en unité de mesure du dénominateur ne doit pas être égale à 0</value>
  </data>
  <data name="tcInheritCannotBeUsedOnInterfaceType" xml:space="preserve">
    <value>Impossible d'utiliser 'inherit' sur les types interface. Implémentez l'interface avec 'interface ... with ... end' à la place.</value>
  </data>
  <data name="parsUnexpectedIntegerLiteralForUnitOfMeasure" xml:space="preserve">
    <value>Littéral d'entier inattendu dans l'expression de l'unité de mesure</value>
  </data>
  <data name="tcNamedTypeRequired" xml:space="preserve">
    <value>'{0}' ne peut être utilisé qu'avec des types nommés</value>
  </data>
  <data name="csMemberSignatureMismatchArity" xml:space="preserve">
    <value>Le membre ou le constructeur d'objet '{0}' accepte {1} argument(s) mais en reçoit ici {2}. La signature requise est '{3}'.</value>
  </data>
  <data name="chkUnionCaseDefaultAugmentation" xml:space="preserve">
    <value>augmentation par défaut du cas d'union</value>
  </data>
  <data name="notAFunction" xml:space="preserve">
    <value>Cette valeur n'est pas une fonction et ne peut pas être appliquée.</value>
  </data>
  <data name="forMissingFormatSpecifier" xml:space="preserve">
    <value>Spécificateur de format manquant</value>
  </data>
  <data name="parsIndexerPropertyRequiresAtLeastOneArgument" xml:space="preserve">
    <value>Une propriété d'indexeur doit être définie avec au moins un argument</value>
  </data>
  <data name="optsUnrecognizedTarget" xml:space="preserve">
    <value>Cible '{0}' non reconnue, 'exe', 'winexe', 'library' ou 'module' attendu</value>
  </data>
  <data name="parsWhileDoExpected" xml:space="preserve">
    <value>'do' est manquant dans l'expression 'while'. 'while &lt;expr&gt; do &lt;expr&gt;' était attendu.</value>
  </data>
  <data name="parsUnexpectedEndOfFileFunBody" xml:space="preserve">
    <value>Fin d'entrée inattendue dans le corps de l'expression lambda. 'fun &lt;pat&gt; … &lt;pat&gt; -&gt; &lt;expr&gt;' était attendu.</value>
  </data>
  <data name="docfileNoXmlSuffix" xml:space="preserve">
    <value>Le fichier de documentation n'a pas de suffixe .xml</value>
  </data>
  <data name="parsArrowUseIsLimited" xml:space="preserve">
    <value>L'utilisation de '-&gt;' dans les expressions de séquence et de calcul est limitée à la forme 'for pat in expr -&gt; expr'. Utilisez la syntaxe 'for ... in ... do ... yield...' pour générer des éléments dans des expressions de séquence plus complexes.</value>
  </data>
  <data name="parsGetterMustHaveAtLeastOneArgument" xml:space="preserve">
    <value>Une propriété de méthode getter est censée être une fonction, par exemple 'get() = ...' ou 'get(index) = ...'</value>
  </data>
  <data name="parsMismatchedQuote" xml:space="preserve">
    <value>Incompatibilité de quotation, qui commence par '{0}'</value>
  </data>
  <data name="lexOutsideSixtyFourBitUnsigned" xml:space="preserve">
    <value>Ce nombre se trouve en dehors de la plage autorisée pour les entiers non signés 64 bits</value>
  </data>
  <data name="itemNotFoundInTypeDuringDynamicCodeGen" xml:space="preserve">
    <value>{0} '{1}' introuvable dans le type '{2}' de l'assembly '{3}'. Cela est peut-être dû à une incompatibilité de version. Vous devrez peut-être référencer explicitement la version appropriée de cet assembly pour permettre à tous les composants référencés d'utiliser la version nécessaire.</value>
  </data>
  <data name="ValueNotContainedMutabilityGenericParametersAreDifferentKinds" xml:space="preserve">
    <value>Le module '{0}' contient\n    {1}    \nmais sa signature spécifie\n    {2}    \nLes paramètres génériques ne sont pas du même genre entre la signature et l'implémentation. Il est possible qu'un attribut [&lt;Measure&gt;] soit manquant.</value>
  </data>
  <data name="ilTypeCannotBeUsedForLiteralField" xml:space="preserve">
    <value>Impossible d'utiliser ce type pour un champ littéral</value>
  </data>
  <data name="optsTailcalls" xml:space="preserve">
    <value>Activer ou désactiver les appels tail</value>
  </data>
  <data name="tcEmptyCopyAndUpdateRecordInvalid" xml:space="preserve">
    <value>Les expressions d'enregistrement de copie et mise à jour doivent inclure au moins un champ.</value>
  </data>
  <data name="parsEofInStringInComment" xml:space="preserve">
    <value>Fin de fichier dans la chaîne incorporée dans le commentaire ayant débuté à cet emplacement ou avant</value>
  </data>
  <data name="tcMissingCustomOperation" xml:space="preserve">
    <value>Une opération de requête personnalisée pour '{0}' est requise mais non spécifiée</value>
  </data>
  <data name="parsInvalidLiteralInType" xml:space="preserve">
    <value>littéral non valide dans le type</value>
  </data>
  <data name="typrelMemberHasMultiplePossibleDispatchSlots" xml:space="preserve">
    <value>Le membre '{0}' correspond à plusieurs surcharges de la même méthode.\nLimitez-le à l'une des options suivantes : {1}.</value>
  </data>
  <data name="tcStructUnionMultiCaseDistinctFields" xml:space="preserve">
    <value>Si un type union a plusieurs étiquettes case, et s'il s'agit d'un struct, tous les champs du type union doivent avoir des noms uniques.</value>
  </data>
  <data name="etPropertyNeedsCanWriteOrCanRead" xml:space="preserve">
    <value>La propriété '{0}' sur le type fourni '{1}' ne peut être ni lue ni écrite, car CanRead=false et CanWrite=false</value>
  </data>
  <data name="typeInfoGeneratedProperty" xml:space="preserve">
    <value>propriété générée</value>
  </data>
  <data name="tcStaticValFieldsMustBeMutableAndPrivate" xml:space="preserve">
    <value>Les champs 'val' statiques des types doivent être mutables, privés et marqués avec l'attribut '[&lt;DefaultValue&gt;]'. Ils sont initialisés avec la valeur 'null' ou 'zero' pour leur type. Utilisez également une liaison 'static let mutable' dans un type classe.</value>
  </data>
  <data name="csMethodExpectsParams" xml:space="preserve">
    <value>Cette méthode attend un paramètre CLI 'params' à cet emplacement. 'params' permet de passer un nombre variable d'arguments à une méthode dans les langages tels que C#. Passez un tableau pour cet argument</value>
  </data>
  <data name="tcUninitializedValFieldsMustBeMutable" xml:space="preserve">
    <value>Les champs 'val' non initialisés doivent être mutables et marqués avec l'attribut '[&lt;DefaultValue&gt;]'. Utilisez une liaison 'let' au lieu d'un champ 'val'.</value>
  </data>
  <data name="etMustNotBeGeneric" xml:space="preserve">
    <value>'IsGenericType' a la valeur True pour le type fourni '{0}', mais les types génériques ne sont pas pris en charge.</value>
  </data>
  <data name="optsCopyright" xml:space="preserve">
    <value>Copyright (c) Microsoft Corporation. Tous droits réservés.</value>
  </data>
  <data name="crefQuotationsCantSetExceptionFields" xml:space="preserve">
    <value>Les quotations ne peuvent pas contenir d'expressions qui définissent des champs dans des valeurs d'exception</value>
  </data>
  <data name="lexByteArrayCannotEncode" xml:space="preserve">
    <value>Ce littéral de tableau d'octets contient des caractères qui ne sont pas encodés sous forme d'octet unique</value>
  </data>
  <data name="parsAttributesMustComeBeforeVal" xml:space="preserve">
    <value>Les attributs doivent être placés avant 'val'</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplDefinesButSignatureDoesNot" xml:space="preserve">
    <value>Les {0} définitions pour le type '{1}' dans la signature et l'implémentation ne sont pas compatibles, car l'implémentation définit le {2} '{3}' mais la signature ne le fait pas (ou elle le fait mais dans un ordre différent)</value>
  </data>
  <data name="tcAnonymousUnitsOfMeasureCannotBeNested" xml:space="preserve">
    <value>Impossible d'imbriquer une unité de mesure anonyme dans une autre expression d'unité de mesure</value>
  </data>
  <data name="typrelSigImplNotCompatibleConstraintsDiffer" xml:space="preserve">
    <value>La signature et l'implémentation ne sont pas compatibles, car la déclaration du paramètre de type '{0}' requiert une contrainte sous la forme {1}</value>
  </data>
  <data name="tcTypeOrModule" xml:space="preserve">
    <value>type ou module</value>
  </data>
  <data name="etNestedProvidedTypesDoNotTakeStaticArgumentsOrGenericParameters" xml:space="preserve">
    <value>Les types fournis imbriqués ne prennent pas d'arguments statiques ni de paramètres génériques</value>
  </data>
  <data name="parsUnexpectedEndOfFileExpression" xml:space="preserve">
    <value>Fin d'entrée inattendue dans l'expression</value>
  </data>
  <data name="tcModuleRequiresQualifiedAccess" xml:space="preserve">
    <value>Cette déclaration ouvre le module '{0}', qui est marqué comme 'RequireQualifiedAccess'. Modifiez votre code pour utiliser des références qualifiées aux éléments du module à la place. Par exemple, utilisez 'List.map' au lieu de 'map'. Cette modification garantit la fiabilité de votre code au fur et à mesure de l'ajout de nouvelles constructions aux bibliothèques.</value>
  </data>
  <data name="tcDeclarationElementNotPermittedInAugmentation" xml:space="preserve">
    <value>Cet élément de déclaration n'est pas autorisé dans une augmentation</value>
  </data>
  <data name="csCtorSignatureMismatchArity" xml:space="preserve">
    <value>Le constructeur d'objet '{0}' accepte {1} argument(s), mais il en reçoit {2} ici. La signature exigée est '{3}'.</value>
  </data>
  <data name="tcNewMemberHidesAbstractMember" xml:space="preserve">
    <value>Ce nouveau membre masque le membre abstrait '{0}'. Renommez le membre ou utilisez 'override' à la place.</value>
  </data>
  <data name="tcKindOfTypeSpecifiedDoesNotMatchDefinition" xml:space="preserve">
    <value>Le genre du type spécifié par ses attributs ne correspond pas au genre impliqué par sa définition</value>
  </data>
  <data name="fscProblemWritingBinary" xml:space="preserve">
    <value>Un problème s'est produit lors de l'écriture du fichier binaire '{0}' : {1}</value>
  </data>
  <data name="tcInvalidNonPrimitiveLiteralInPatternMatch" xml:space="preserve">
    <value>Impossible d'utiliser les constantes littérales numériques non primitives dans les critères spéciaux, car elles peuvent être mappées à plusieurs types différents via l'utilisation d'un module NumericLiteral. Utilisez une variable en remplacement et utilisez 'when &lt;variable&gt; = &lt;constante&gt;' à la fin de la clause de correspondance.</value>
  </data>
  <data name="typrelSigImplNotCompatibleCompileTimeRequirementsDiffer" xml:space="preserve">
    <value>La signature et l'implémentation ne sont pas compatibles, car le paramètre de type de la classe/signature n'a pas la même exigence au moment de la compilation que celui du membre/de l'implémentation</value>
  </data>
  <data name="checkRaiseFamilyFunctionArgumentCount" xml:space="preserve">
    <value>Les arguments redondants sont actuellement ignorés dans la fonction '{0}'. {1} attendu(s), mais {2} argument(s) obtenu(s).</value>
  </data>
  <data name="tcCustomAttributeMustInvokeConstructor" xml:space="preserve">
    <value>Un attribut personnalisé doit appeler un constructeur d'objet</value>
  </data>
  <data name="tcSyntaxFormUsedOnlyWithRecordLabelsPropertiesAndFields" xml:space="preserve">
    <value>La syntaxe 'expr.id' ne peut être utilisée qu'avec des étiquettes d'enregistrement, des propriétés et des champs</value>
  </data>
  <data name="parsExpectedTypeAfterToken" xml:space="preserve">
    <value>Un type était attendu après ce point</value>
  </data>
  <data name="augNoRefEqualsOnStruct" xml:space="preserve">
    <value>Impossible d'utiliser l'attribut 'ReferenceEquality' sur des structs. Utilisez l'attribut 'StructuralEquality' à la place, ou implémentez une substitution pour 'System.Object.Equals(obj)'.</value>
  </data>
  <data name="typrelOverrideImplementsMoreThenOneSlot" xml:space="preserve">
    <value>La substitution '{0}' implémente plusieurs emplacements abstraits, par exemple '{1}' et '{2}'</value>
  </data>
  <data name="tcArgumentArityMismatchOneOverload" xml:space="preserve">
    <value>Le membre '{0}' n'accepte pas le nombre approprié d'arguments. Une surcharge accepte {1} arguments, mais {2} ont été fournis. La signature nécessaire est '{3}'.{4}</value>
  </data>
  <data name="parsModuleDefnMustBeSimpleName" xml:space="preserve">
    <value>Un nom de module doit être un nom simple et non un chemin d'accès</value>
  </data>
  <data name="parsMutableOnAutoPropertyShouldBeGetSetNotJustSet" xml:space="preserve">
    <value>Pour indiquer que cette propriété peut être définie, utilisez 'member val PropertyName = expr with get,set'.</value>
  </data>
  <data name="fsharpCoreNotFoundToBeCopied" xml:space="preserve">
    <value>FSharp.Core.dll est introuvable dans le répertoire du compilateur</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypesHaveDifferentBaseTypes" xml:space="preserve">
    <value>Les {0} définitions pour le type '{1}' dans la signature et l'implémentation ne sont pas compatibles, car les types ont des types de base différents</value>
  </data>
  <data name="csNoOverloadsFound" xml:space="preserve">
    <value>Aucune surcharge correspondante pour la méthode '{0}'.</value>
  </data>
  <data name="nrIsNotConstructorOrLiteral" xml:space="preserve">
    <value>Soit il ne s'agit pas d'un constructeur ou d'un littéral, soit un constructeur est utilisé de manière incorrecte</value>
  </data>
  <data name="tcOnlyTypesRepresentingUnitsOfMeasureCanHaveMeasure" xml:space="preserve">
    <value>Seuls les types représentant des unités de mesure peuvent recevoir l'attribut 'Measure'</value>
  </data>
  <data name="csExpectedArguments" xml:space="preserve">
    <value>Arguments attendus pour un membre d'instance</value>
  </data>
  <data name="tcLessGenericBecauseOfAnnotation" xml:space="preserve">
    <value>Ce code est moins générique que ne l'exigent ses annotations, car il est impossible de généraliser la variable de type explicite '{0}'. Il a été contraint à être '{1}'.</value>
  </data>
  <data name="tcInvalidOperatorDefinitionEquality" xml:space="preserve">
    <value>Normalement, l'opérateur '{0}' ne doit pas être redéfini. Pour définir une sémantique d'égalité pour un type, substituez le membre 'Object.Equals' dans la définition de ce type.</value>
  </data>
  <data name="augRefEqCantHaveObjEquals" xml:space="preserve">
    <value>Un type avec l'attribut 'ReferenceEquality' ne peut pas avoir une implémentation explicite de 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' ou 'System.Collections.IStructuralEquatable'</value>
  </data>
  <data name="tcInvalidUseNullAsTrueValue" xml:space="preserve">
    <value>L'indicateur d'attribut 'UseNullAsTrueValue' ne peut être utilisé qu'avec des types union qui ont un cas nullaire et au moins un cas non nullaire</value>
  </data>
  <data name="parsUnmatchedBeginOrStruct" xml:space="preserve">
    <value>'begin' ou 'struct' non apparié</value>
  </data>
  <data name="keywordDescriptionLeftArrow" xml:space="preserve">
    <value>Assigne une valeur à une variable.</value>
  </data>
  <data name="parsEofInHashIf" xml:space="preserve">
    <value>Fin de fichier dans la section #if ayant débuté à cet emplacement ou après</value>
  </data>
  <data name="tcUseWhenPatternGuard" xml:space="preserve">
    <value>Les correspondances de plages de caractères ont été supprimées de F#. Utilisez une garde par modèle 'when' à la place.</value>
  </data>
  <data name="lexHashBangMustBeFirstInFile" xml:space="preserve">
    <value>#! ne peut se trouver que sur la première ligne au début d'un fichier.</value>
  </data>
  <data name="tcConstructorsDisallowedInExceptionAugmentation" xml:space="preserve">
    <value>Impossible de spécifier des constructeurs dans des augmentations d'exception</value>
  </data>
  <data name="etMustNotBeAnArray" xml:space="preserve">
    <value>'IsArray' a la valeur True pour le type fourni '{0}', mais les types de tableau ne sont pas pris en charge.</value>
  </data>
  <data name="chkDuplicatePropertyWithSuffix" xml:space="preserve">
    <value>Propriété dupliquée. La propriété '{0}' a le même nom et la même signature qu'une autre propriété dans le type '{1}', une fois les tuples, fonctions, unités de mesure et/ou types fournis effacés.</value>
  </data>
  <data name="tastUndefinedItemRefModuleNamespace" xml:space="preserve">
    <value>Le module/l'espace de noms '{0}' de l'unité de compilation '{1}' ne contenait pas le module/l'espace de noms '{2}'</value>
  </data>
  <data name="parsLetAndForNonRecBindings" xml:space="preserve">
    <value>La forme de déclaration 'let ... and ...' pour les liaisons non récursives n'est pas utilisée dans le code F#. Utilisez une séquence de liaisons 'let'</value>
  </data>
  <data name="typrelExplicitImplementationOfGetHashCodeOrEquals" xml:space="preserve">
    <value>Le type struct, enregistrement ou union '{0}' a une implémentation explicite de 'Object.GetHashCode' ou 'Object.Equals'. Vous devez appliquer l'attribut 'CustomEquality' au type</value>
  </data>
  <data name="tcInvalidUseOfDelegate" xml:space="preserve">
    <value>Utilisation non valide d'un constructeur délégué. Utilisez la syntaxe 'new Type(args)' ou simplement 'Type(args)'.</value>
  </data>
  <data name="typrelSigImplNotCompatibleConstraintsDifferRemove" xml:space="preserve">
    <value>La signature et l'implémentation ne sont pas compatibles, car le paramètre de type '{0}' a une contrainte sous la forme {1} mais l'implémentation n'en a pas. Vous devez soit supprimer cette contrainte de la signature, soit l'ajouter à l'implémentation.</value>
  </data>
  <data name="etHostingAssemblyFoundWithoutHosts" xml:space="preserve">
    <value>L'assembly référencé '{0}' a un attribut de niveau assembly '{1}', mais aucune classe de fournisseur de type publique n'a été trouvée</value>
  </data>
  <data name="optsWarnaserrorPM" xml:space="preserve">
    <value>Signaler tous les avertissements comme des erreurs</value>
  </data>
  <data name="lexTabsNotAllowed" xml:space="preserve">
    <value>Les tabulations ne sont pas autorisées dans le code F# sauf si l'option #indent \"off\" est utilisée</value>
  </data>
  <data name="etInvalidStaticArgument" xml:space="preserve">
    <value>L'argument statique transmis au type fourni n'est pas valide. Un argument du genre '{0}' était attendu.</value>
  </data>
  <data name="tcMutableValuesCannotBeInline" xml:space="preserve">
    <value>Impossible de marquer des valeurs mutables 'inline'</value>
  </data>
  <data name="typrelMoreThenOneOverride" xml:space="preserve">
    <value>Plusieurs substitutions implémentent '{0}'</value>
  </data>
  <data name="tcAbstractTypeCannotBeInstantiated" xml:space="preserve">
    <value>Impossible de créer des instances de ce type, car il est marqué comme abstract, ou toutes les méthodes n'ont pas reçu d'implémentations. Utilisez une expression d'objet '{{ new ... with ... }}' à la place.</value>
  </data>
  <data name="tcModuleAbbrevFirstInMutRec" xml:space="preserve">
    <value>Dans un groupe de déclarations récursives, les abréviations de module doivent figurer après toutes les déclarations 'open' et avant les autres déclarations</value>
  </data>
  <data name="keywordDescriptionFunction" xml:space="preserve">
    <value>Utilisé comme alternative plus courte au mot clé fun et à une expression match dans une expression lambda ayant des critères spéciaux sur un argument unique.</value>
  </data>
  <data name="ValueNotContainedMutabilityCompiledNamesDiffer" xml:space="preserve">
    <value>Le module '{0}' contient\n    {1}    \nmais sa signature spécifie\n    {2}    \nLes noms compilés sont différents</value>
  </data>
  <data name="ValueNotContainedMutabilityAccessibilityMore" xml:space="preserve">
    <value>Le module '{0}' contient\n    {1}    \nmais sa signature spécifie\n    {2}    \nL'accessibilité spécifiée dans la signature est supérieure à celle spécifiée dans l'implémentation</value>
  </data>
  <data name="tcInvalidObjectConstructionExpression" xml:space="preserve">
    <value>Expression de construction d'objet non valide. Les constructeurs d'objets doivent appeler un autre constructeur ou initialiser tous les champs de l'objet et spécifier un appel à un constructeur de superclasse.</value>
  </data>
  <data name="optsUnknownPlatform" xml:space="preserve">
    <value>Plateforme '{0}' non reconnue, les valeurs valides sont 'x86', 'x64', 'Itanium', 'anycpu32bitpreferred' et 'anycpu'</value>
  </data>
  <data name="tcNewCannotBeUsedOnInterfaceType" xml:space="preserve">
    <value>Impossible d'utiliser 'new' sur les types interface. Utilisez une expression d'objet '{{ new ... with ... }}' à la place.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbbreviationHiddenBySig" xml:space="preserve">
    <value>Les {0} définitions pour le type '{1}' dans la signature et l'implémentation ne sont pas compatibles, car une abréviation est masquée par une signature. L'abréviation doit être visible par les autres langages CLI. Rendez l'abréviation visible dans la signature.</value>
  </data>
  <data name="tastInvalidFormForPropertySetter" xml:space="preserve">
    <value>Forme non valide pour la méthode setter d'une propriété. Au moins un argument est requis.</value>
  </data>
  <data name="tcBindMayNotBeUsedInQueries" xml:space="preserve">
    <value>Les expressions 'let!', 'use!' et 'do!' ne sont pas utilisées dans les requêtes</value>
  </data>
  <data name="parsEofInVerbatimString" xml:space="preserve">
    <value>Fin de fichier dans la chaîne textuelle ayant débuté à cet emplacement ou avant</value>
  </data>
  <data name="tcFieldIsReadonly" xml:space="preserve">
    <value>Ce champ est en lecture seule</value>
  </data>
  <data name="ilStructLayoutAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>Impossible de décoder l'attribut StructLayout</value>
  </data>
  <data name="csTypeIsNotDelegateType" xml:space="preserve">
    <value>Le type '{0}' n'est pas un type délégué CLI</value>
  </data>
  <data name="notAFunctionButMaybeIndexer" xml:space="preserve">
    <value>Cette expression n'est pas une fonction et ne peut pas être appliquée. Souhaitiez-vous accéder à l'indexeur via expr.[index] ?</value>
  </data>
  <data name="replaceWithSuggestion" xml:space="preserve">
    <value>Remplacer par '{0}'</value>
  </data>
  <data name="structOrClassFieldIsNotAccessible" xml:space="preserve">
    <value>Le champ de struct ou de classe '{0}' n'est pas accessible à partir de cet emplacement du code</value>
  </data>
  <data name="keywordDescriptionYieldBang" xml:space="preserve">
    <value>Utilisé dans une expression de calcul pour ajouter le résultat d'une expression de calcul donnée à une collection de résultats pour l'expression de calcul conteneur.</value>
  </data>
  <data name="nrInvalidExpression" xml:space="preserve">
    <value>Expression non valide '{0}'</value>
  </data>
  <data name="csTypeParameterCannotBeNullable" xml:space="preserve">
    <value>Impossible d'instancier ce paramètre de type en 'Nullable'. Il s'agit d'une restriction imposée pour garantir que la signification de 'null' dans certains langages CLI n'entraîne pas de confusion lors de l'utilisation conjointe de valeurs 'Nullable'.</value>
  </data>
  <data name="buildImplementationAlreadyGiven" xml:space="preserve">
    <value>Une implémentation du fichier ou du module '{0}' a déjà été fournie</value>
  </data>
  <data name="etIncorrectProvidedConstructor" xml:space="preserve">
    <value>Le fournisseur de type '{0}' a fourni un constructeur qui ne figure pas parmi les constructeurs de son type déclarant ' '{1}'</value>
  </data>
  <data name="tcInterfacesShouldUseInheritNotInterface" xml:space="preserve">
    <value>Les interfaces héritées d'autres interfaces doivent être déclarées avec 'inherit ...' à la place de 'interface ...'</value>
  </data>
  <data name="chkEntryPointUsage" xml:space="preserve">
    <value>Une fonction étiquetée avec l'attribut 'EntryPointAttribute' doit être la dernière déclaration du dernier fichier de la séquence de compilation.</value>
  </data>
  <data name="nrRecordDoesNotContainSuchLabel" xml:space="preserve">
    <value>Le type d'enregistrement '{0}' ne contient pas d'étiquette '{1}'.</value>
  </data>
  <data name="parsUnClosedBlockInHashLight" xml:space="preserve">
    <value>Bloc non fermé</value>
  </data>
  <data name="tcPropertyOrFieldNotFoundInAttribute" xml:space="preserve">
    <value>Impossible de trouver cette propriété ou ce champ dans ce type d'attribut personnalisé</value>
  </data>
  <data name="tastNamespaceAndModuleWithSameNameInAssembly" xml:space="preserve">
    <value>Un espace de noms et un module nommés tous les deux '{0}' sont présents dans deux parties de cet assembly</value>
  </data>
  <data name="optsTargetProfile" xml:space="preserve">
    <value>Spécifiez le profil de framework cible de cet assembly. Les valeurs valides sont mscorlib, netcore ou netstandard. Par défaut - mscorlib</value>
  </data>
  <data name="tcTypeAbbreviationsCheckedAtCompileTime" xml:space="preserve">
    <value>À partir de F# 4.1, l'accessibilité des abréviations de type est vérifiée au moment de la compilation. Changez l'accessibilité de l'abréviation de type. Si vous ignorez cet avertissement, cela risque d'entraîner des erreurs d'exécution.</value>
  </data>
  <data name="lexHashEndifMustBeFirst" xml:space="preserve">
    <value>La directive #endif doit être le premier caractère (autre qu'un espace blanc) d'une ligne</value>
  </data>
  <data name="ilSignInvalidRSAParams" xml:space="preserve">
    <value>Structure RSAParameters non valide - '{{0}}' attendu</value>
  </data>
  <data name="tcNoEqualityNeeded1" xml:space="preserve">
    <value>Le type struct, enregistrement ou union '{0}' ne prend pas en charge l'égalité structurelle, car le paramètre de type {1} ne satisfait pas la contrainte 'equality'. Ajoutez l'attribut 'NoEquality' au type '{2}' pour préciser que le type ne prend pas en charge l'égalité structurelle</value>
  </data>
  <data name="tcNoEqualityNeeded2" xml:space="preserve">
    <value>Le type struct, enregistrement ou union '{0}' ne prend pas en charge l'égalité structurelle, car le type '{1}' ne satisfait pas la contrainte 'equality'. Ajoutez l'attribut 'NoEquality' au type '{2}' pour préciser que le type ne prend pas en charge l'égalité structurelle</value>
  </data>
  <data name="tcAttributeIsNotValidForLanguageElementUseDo" xml:space="preserve">
    <value>L'utilisation de cet attribut n'est pas valide sur cet élément de langage. Les attributs d'assembly doivent être attachés à une déclaration 'do ()', si nécessaire, dans un module F#.</value>
  </data>
  <data name="tcThreadStaticAndContextStaticMustBeStatic" xml:space="preserve">
    <value>Les variables static de thread et de contexte doivent être statiques et recevoir l'attribut [&lt;DefaultValue&gt;] pour indiquer que la valeur est initialisée à la valeur par défaut pour chaque nouveau thread</value>
  </data>
  <data name="chkNoAddressOfArrayElementAtThisPoint" xml:space="preserve">
    <value>Impossible d'utiliser l'adresse d'un élément de tableau actuellement</value>
  </data>
  <data name="parsUnexpectedTypeParameter" xml:space="preserve">
    <value>Erreur de syntaxe : spécification du paramètre de type inattendue</value>
  </data>
  <data name="ilDefaultAugmentationAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>Impossible de décoder l'attribut DefaultAugmentation</value>
  </data>
  <data name="chkValueWithDefaultValueMustHaveDefaultValue" xml:space="preserve">
    <value>Le type d'un champ qui utilise l'attribut 'DefaultValue' doit admettre l'initialisation par défaut, c'est-à-dire qu'il doit avoir la valeur 'null' comme valeur appropriée ou être un type struct dont les champs admettent tous l'initialisation par défaut. Vous pouvez utiliser 'DefaultValue(false)' pour désactiver cette vérification</value>
  </data>
  <data name="keywordDescriptionOverride" xml:space="preserve">
    <value>Permet d'implémenter une version d'une méthode abstraite ou virtuelle qui diffère de la version de base.</value>
  </data>
  <data name="etUnexpectedExceptionFromProvidedTypeMember" xml:space="preserve">
    <value>Exception inattendue levée par le type fourni '{0}', membre '{1}' : {2}</value>
  </data>
  <data name="chkTyparMultipleClassConstraints" xml:space="preserve">
    <value>Une variable de type a été contrainte par plusieurs types de classes différents. Une variable de type ne peut avoir qu'une contrainte de classe.</value>
  </data>
  <data name="etMissingStaticArgumentsToMethod" xml:space="preserve">
    <value>La méthode fournie nécessite des paramètres statiques</value>
  </data>
  <data name="undefinedNameConstructorModuleOrNamespace" xml:space="preserve">
    <value>Le constructeur, le module ou l'espace de noms '{0}' n'est pas défini.</value>
  </data>
  <data name="tcTypeIsInaccessible" xml:space="preserve">
    <value>Ce type n'est pas accessible à partir de cet emplacement du code</value>
  </data>
  <data name="tcAttributesOfTypeSpecifyMultipleKindsForType" xml:space="preserve">
    <value>Les attributs de ce type spécifient plusieurs genres pour le type</value>
  </data>
  <data name="tastInvalidAddressOfMutableAcrossAssemblyBoundary" xml:space="preserve">
    <value>Cette opération accède à une valeur de niveau supérieur mutable définie dans un autre assembly d'une manière non prise en charge. Impossible d'accéder à la valeur via son adresse. Copiez l'expression dans une variable locale mutable, par exemple 'let mutable x = ...', et si nécessaire, réassignez la valeur une fois l'opération terminée</value>
  </data>
  <data name="parsUnexpectedEndOfFileTry" xml:space="preserve">
    <value>Fin d'entrée inattendue dans l'expression 'try'. 'try &lt;expr&gt; with &lt;rules&gt;' ou 'try &lt;expr&gt; finally &lt;expr&gt;' était attendu.</value>
  </data>
  <data name="parsUnexpectedEndOfFileFor" xml:space="preserve">
    <value>Fin d'entrée inattendue dans l'expression 'for'. 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;' était attendu.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleRepresentationsDiffer" xml:space="preserve">
    <value>Les {0} définitions pour le type '{1}' dans la signature et l'implémentation ne sont pas compatibles, car les représentations sont différentes</value>
  </data>
  <data name="crefQuotationsCantContainThisPatternMatch" xml:space="preserve">
    <value>Les quotations ne peuvent pas contenir ce genre de critère spécial</value>
  </data>
  <data name="parsExpectedNameAfterToken" xml:space="preserve">
    <value>Fin de type inattendue. Un nom était attendu après ce point.</value>
  </data>
  <data name="etProviderError" xml:space="preserve">
    <value>Le fournisseur de type '{0}' a signalé une erreur : {1}</value>
  </data>
  <data name="ilwriteMDBMemberMissing" xml:space="preserve">
    <value>Échec de la génération de MDB. Le membre compatible {0} est introuvable</value>
  </data>
  <data name="tcTypeAbbreviationsCannotHaveInterfaceDeclaration" xml:space="preserve">
    <value>Les abréviations de type ne peuvent pas avoir de déclarations d'interface</value>
  </data>
  <data name="augStructEqNeedsNoCompOrStructComp" xml:space="preserve">
    <value>L'attribut 'StructuralEquality' doit être utilisé conjointement avec les attributs 'NoComparison' ou 'StructuralComparison'</value>
  </data>
  <data name="chkSplicingOnlyInQuotations" xml:space="preserve">
    <value>Les opérateurs d'ajout d'expressions ne peuvent être utilisés qu'entre des quotations</value>
  </data>
  <data name="lexHashEndingNoMatchingIf" xml:space="preserve">
    <value>#endif n'a aucun #if correspondant</value>
  </data>
  <data name="tcAttributeIsNotValidForLanguageElement" xml:space="preserve">
    <value>L'utilisation de cet attribut n'est pas valide sur cet élément de langage</value>
  </data>
  <data name="optsChecked" xml:space="preserve">
    <value>Générer des contrôles de dépassement de capacité</value>
  </data>
  <data name="optsCopyrightCommunity" xml:space="preserve">
    <value>Distribué gratuitement sous licence Open Source du MIT. https://github.com/Microsoft/visualfsharp/blob/master/License.txt</value>
  </data>
  <data name="csMemberOverloadArityMismatch" xml:space="preserve">
    <value>Le membre ou le constructeur d'objet '{0}' n'accepte pas {1} argument(s). Une surcharge acceptant {2} arguments a été trouvée.</value>
  </data>
  <data name="etProviderHasWrongDesignerAssembly" xml:space="preserve">
    <value>L'attribut d'assembly '{0}' fait référence à un assembly de concepteur '{1}' qui ne peut pas être chargé ou qui n'existe pas. {2}</value>
  </data>
  <data name="etUnexpectedExceptionFromProvidedMemberMember" xml:space="preserve">
    <value>Exception inattendue levée par le membre '{0}' du type fourni '{1}', membre '{2}' : {3}</value>
  </data>
  <data name="estApplyStaticArgumentsForMethodNotImplemented" xml:space="preserve">
    <value>Un fournisseur de type a implémenté GetStaticParametersForMethod, mais ApplyStaticArgumentsForMethod n'a pas été implémenté ou est non valide</value>
  </data>
  <data name="optsHelpBannerResources" xml:space="preserve">
    <value>- RESSOURCES -</value>
  </data>
  <data name="fscQuotationLiteralsStaticLinking0" xml:space="preserve">
    <value>Le code dans cet assembly utilise des littéraux de citation. La liaison statique risque de ne pas inclure les composants qui utilisent des littéraux de citation, sauf si tous les assemblys sont compilés avec au moins F# 4.0.</value>
  </data>
  <data name="tcBinaryOperatorRequiresBody" xml:space="preserve">
    <value>'{0}' doit suivre une clause de sélection 'for' et être suivi du reste de la requête. Syntaxe : ... {1} ...</value>
  </data>
  <data name="fscDelaySignWarning" xml:space="preserve">
    <value>L'option '--delaysign' remplace l'attribut 'System.Reflection.AssemblyDelaySignAttribute' fourni dans un fichier source ou un module ajouté</value>
  </data>
  <data name="ilAddressOfLiteralFieldIsInvalid" xml:space="preserve">
    <value>L'acceptation de l'adresse d'un champ littéral n'est pas valide</value>
  </data>
  <data name="lexOutsideThirtyTwoBitSigned" xml:space="preserve">
    <value>Ce nombre se trouve en dehors de la plage autorisée pour les entiers signés 32 bits</value>
  </data>
  <data name="parsUnmatchedBracketBar" xml:space="preserve">
    <value>'[|' non apparié</value>
  </data>
  <data name="csMemberIsNotAccessible2" xml:space="preserve">
    <value>Le membre ou le constructeur d'objet '{0}' n'est pas {1}. Les membres privés ne peuvent être accessibles qu'à partir du type déclarant. Les membres protégés ne peuvent être accessibles qu'à partir d'un type d'extension et ne sont pas accessibles à partir d'expressions lambda internes.</value>
  </data>
  <data name="methodIsNotStatic" xml:space="preserve">
    <value>La méthode ou le constructeur d'objet '{0}' n'est pas statique</value>
  </data>
  <data name="fscQuotationLiteralsStaticLinking" xml:space="preserve">
    <value>Le code dans l'assembly '{0}' utilise des littéraux de citation. La liaison statique risque de ne pas inclure les composants qui utilisent des littéraux de citation, sauf si tous les assemblys sont compilés avec au moins F# 4.0.</value>
  </data>
  <data name="buildInvalidFilename" xml:space="preserve">
    <value>'{0}' n'est pas un nom de fichier valide</value>
  </data>
  <data name="optsPublicSign" xml:space="preserve">
    <value>Signer publiquement l'assembly en utilisant uniquement la partie publique de la clé de nom fort, et marquer l'assembly comme signé</value>
  </data>
  <data name="lexOutsideSixteenBitUnsigned" xml:space="preserve">
    <value>Ce nombre se trouve en dehors de la plage autorisée pour les entiers non signés 16 bits</value>
  </data>
  <data name="etProvidedAppliedTypeHadWrongName" xml:space="preserve">
    <value>Le fournisseur de type '{0}' a retourné un type non valide de 'ApplyStaticArguments'. Un type nommé '{1}' était attendu, mais un type nommé '{2}' a été retourné.</value>
  </data>
  <data name="abImplicitHeapAllocation" xml:space="preserve">
    <value>Le mutable local '{0}' est implicitement alloué en tant que cellule de référence, car il a été capturé par une clôture. Cet avertissement est fourni à titre d'information uniquement pour indiquer l'emplacement où les allocations implicites sont effectuées.</value>
  </data>
  <data name="parsParenFormIsForML" xml:space="preserve">
    <value>En F#, vous pouvez utiliser 'expr.[expr]'. Une annotation de type peut être requise pour indiquer que la première expression est un tableau</value>
  </data>
  <data name="tcObjectConstructorsIllegalInInterface" xml:space="preserve">
    <value>Les interfaces ne peuvent pas contenir de définitions de constructeurs d'objets</value>
  </data>
  <data name="optsInvalidSubSystemVersion" xml:space="preserve">
    <value>Version '{0}' non valide pour '--subsystemversion'. La version doit être 4.00 ou supérieure.</value>
  </data>
  <data name="tcNameArgumentsMustAppearLast" xml:space="preserve">
    <value>Les arguments nommés doivent apparaître après tous les autres arguments</value>
  </data>
  <data name="crefBoundVarUsedInSplice" xml:space="preserve">
    <value>La variable '{0}' est liée dans une quotation mais est utilisée dans le cadre d'une expression ajoutée. Cela n'est pas autorisé, car elle peut sortir de sa portée.</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInEnum" xml:space="preserve">
    <value>Impossible de résoudre l'ambigüité liée à l'utilisation d'une construction générique avec une contrainte 'enum' à cette position ou à proximité</value>
  </data>
  <data name="ilSignNoSignatureDirectory" xml:space="preserve">
    <value>Aucun répertoire de signature</value>
  </data>
  <data name="parsUnexpectedOperatorForUnitOfMeasure" xml:space="preserve">
    <value>Opérateur infixe inattendu dans l'expression de l'unité de mesure. Les opérateurs conformes sont '*', '/' et '^'.</value>
  </data>
  <data name="typeInfoProperty" xml:space="preserve">
    <value>propriété</value>
  </data>
  <data name="tcCannotInheritFromSealedType" xml:space="preserve">
    <value>Impossible d'hériter d'un type sealed</value>
  </data>
  <data name="tcConstructIsAmbiguousInSequenceExpression" xml:space="preserve">
    <value>Cette construction est ambiguë dans le cadre d'une expression de séquence. Les expressions imbriquées peuvent être écrites avec 'let _ = (...)' et les séquences imbriquées avec 'yield! seq {{... }}'.</value>
  </data>
  <data name="tcImplementsIStructuralEquatableExplicitly" xml:space="preserve">
    <value>Le type struct, enregistrement ou union '{0}' implémente explicitement l'interface 'System.IStructuralEquatable'. Appliquez l'attribut 'CustomEquality' au type.</value>
  </data>
  <data name="parsMemberIllegalInObjectImplementation" xml:space="preserve">
    <value>Ce membre n'est pas autorisé dans l'implémentation d'un objet</value>
  </data>
  <data name="impImportedAssemblyUsesNotPublicType" xml:space="preserve">
    <value>Un assembly importé utilise le type '{0}' mais ce type n'est pas public</value>
  </data>
  <data name="optsHelpBannerMisc" xml:space="preserve">
    <value>- DIVERS -</value>
  </data>
  <data name="tastUndefinedItemRefModuleNamespaceType" xml:space="preserve">
    <value>Le module/l'espace de noms '{0}' de l'unité de compilation '{1}' ne contenait pas l'espace de noms, le module ou le type '{2}'</value>
  </data>
  <data name="fscRemotingError" xml:space="preserve">
    <value>Le service de compilation résident n'a pas été utilisé en raison d'un problème lors de la communication avec le serveur.</value>
  </data>
  <data name="tcFieldValIllegalHere" xml:space="preserve">
    <value>Aucune déclaration de champ/valeur n'est autorisée ici</value>
  </data>
  <data name="tcInvalidNewConstraint" xml:space="preserve">
    <value>Les contraintes 'new' doivent accepter un argument de type 'unit' et retourner le type construit</value>
  </data>
  <data name="optsResident" xml:space="preserve">
    <value>Utilisez un service de compilation en arrière-plan résident pour améliorer les temps de démarrage du compilateur.</value>
  </data>
  <data name="tcInvalidConstraint" xml:space="preserve">
    <value>Contrainte non valide</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull" xml:space="preserve">
    <value>Les {0} définitions pour le type '{1}' dans la signature et l'implémentation ne sont pas compatibles, car l'implémentation indique que ce type peut utiliser des valeurs Null comme représentation, contrairement à la signature</value>
  </data>
  <data name="etErrorApplyingStaticArgumentsToMethod" xml:space="preserve">
    <value>Une erreur s'est produite durant l'application des arguments statiques à une méthode fournie</value>
  </data>
  <data name="optsResource" xml:space="preserve">
    <value>Incorporer la ressource managée spécifiée</value>
  </data>
  <data name="tcCouldNotFindOffsetToStringData" xml:space="preserve">
    <value>Méthode System.Runtime.CompilerServices.OffsetToStringData introuvable dans les références durant la construction d'une expression 'fixed'.</value>
  </data>
  <data name="tcMemberAndLocalClassBindingHaveSameName" xml:space="preserve">
    <value>Un membre et une liaison de classe locale se nomment tous les deux '{0}'</value>
  </data>
  <data name="tcBinaryOperatorRequiresVariable" xml:space="preserve">
    <value>'{0}' doit être suivi d'un nom de variable. Utilisation : {1}.</value>
  </data>
  <data name="tcTypeTestErased" xml:space="preserve">
    <value>Ce test de type avec un type fourni '{0}' n'est pas autorisé, car ce type fourni sera effacé et remplacé par '{1}' au moment de l'exécution.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationIsAbstract" xml:space="preserve">
    <value>Les {0} définitions pour le type '{1}' dans la signature et l'implémentation ne sont pas compatibles, car l'implémentation est une classe abstraite, contrairement à la signature. Ajoutez l'attribut [&lt;AbstractClass&gt;] à la signature.</value>
  </data>
  <data name="csArgumentLengthMismatch" xml:space="preserve">
    <value>Incompatibilité de longueur des arguments</value>
  </data>
  <data name="notAFunctionButMaybeDeclaration" xml:space="preserve">
    <value>Cette valeur n'est pas une fonction et ne peut pas être appliquée. Avez-vous oublié de terminer une déclaration ?</value>
  </data>
  <data name="typrelMemberCannotImplement" xml:space="preserve">
    <value>Impossible d'utiliser le membre '{0}' pour implémenter '{1}'. La signature requise est '{2}'.</value>
  </data>
  <data name="chkMultipleGenericInterfaceInstantiations" xml:space="preserve">
    <value>Ce type implémente la même interface à des instanciations génériques différentes '{0}' et '{1}'. Cela n'est pas autorisé dans cette version de F#.</value>
  </data>
  <data name="fscKeyNameWarning" xml:space="preserve">
    <value>L'option '--keycontainer' remplace l'attribut 'System.Reflection.AssemblyNameAttribute' fourni dans un fichier source ou un module ajouté</value>
  </data>
  <data name="tcGlobalsSystemTypeNotFound" xml:space="preserve">
    <value>Le type système '{0}' est obligatoire, mais aucune DLL système référencée ne contient ce type</value>
  </data>
  <data name="keywordDescriptionReturnBang" xml:space="preserve">
    <value>Permet d'indiquer une expression de calcul qui, une fois évaluée, fournit le résultat de l'expression de calcul qui la contient.</value>
  </data>
  <data name="memberOperatorDefinitionWithCurriedArguments" xml:space="preserve">
    <value>Le membre opérateur infixe '{0}' a des arguments curryfiés supplémentaires. Tuple de 2 arguments attendu. Exemple : static member (+) (x,y) = ...</value>
  </data>
  <data name="tcMemberNotPermittedInInterfaceImplementation" xml:space="preserve">
    <value>Ce membre n'est pas autorisé dans l'implémentation d'une interface</value>
  </data>
  <data name="memberOperatorDefinitionWithNonTripleArgument" xml:space="preserve">
    <value>Le membre opérateur infixe '{0}' a {1} argument initiaux. Tuple de 3 arguments attendu</value>
  </data>
  <data name="ilFieldHasOffsetForSequentialLayout" xml:space="preserve">
    <value>L'attribut FieldOffset ne peut être placé que sur des membres de types marqués avec StructLayout(LayoutKind.Explicit)</value>
  </data>
  <data name="tcConstructorCannotHaveTypeParameters" xml:space="preserve">
    <value>Un constructeur ne peut pas avoir de paramètres de type explicite. Utilisez une méthode de construction statique à la place.</value>
  </data>
  <data name="etPropertyHasGetterButNoCanRead" xml:space="preserve">
    <value>La propriété '{0}' sur le type fourni '{1}' a CanRead=false, mais GetGetMethod() a retourné une méthode</value>
  </data>
  <data name="tcJoinMustUseSimplePattern" xml:space="preserve">
    <value>Dans les requêtes, '{0}' doit utiliser un modèle simple</value>
  </data>
  <data name="tcUnexpectedConstByteArray" xml:space="preserve">
    <value>Const_bytearray inattendu</value>
  </data>
  <data name="tlrUnexpectedTExpr" xml:space="preserve">
    <value>Expr.TyChoose inattendu</value>
  </data>
  <data name="parsUnexpectedEndOfFileObjectMembers" xml:space="preserve">
    <value>Fin d'entrée inattendue dans les membres d'objet</value>
  </data>
  <data name="chkDuplicateMethodCurried" xml:space="preserve">
    <value>La méthode '{0}' a des arguments curryfiés mais elle comporte le même nom qu'une autre méthode dans le type '{1}'. Impossible de surcharger les méthodes ayant des arguments curryfiés. Utilisez une méthode qui accepte des arguments basés sur des tuples.</value>
  </data>
  <data name="fscBadAssemblyVersion" xml:space="preserve">
    <value>Un {0} a spécifié la version '{1}', mais cette valeur n'est pas valide et a été ignorée</value>
  </data>
  <data name="tcTypeParameterInvalidAsTypeConstructor" xml:space="preserve">
    <value>Impossible d'utiliser le paramètre de type en tant que constructeur de type</value>
  </data>
  <data name="ilMutableVariablesCannotEscapeMethod" xml:space="preserve">
    <value>Impossible d'utiliser les variables mutables en dehors de leur méthode</value>
  </data>
  <data name="tcMeasureDeclarationsRequireStaticMembers" xml:space="preserve">
    <value>Les déclarations de mesure ne peuvent avoir que des membres statiques</value>
  </data>
  <data name="tcInvalidOperatorDefinition" xml:space="preserve">
    <value>Normalement, l'opérateur '{0}' ne doit pas être redéfini. Utilisez un autre nom d'opérateur</value>
  </data>
  <data name="chkNoByrefAtThisPoint" xml:space="preserve">
    <value>Impossible d'utiliser la valeur typée byref '{0}' actuellement</value>
  </data>
  <data name="buildSearchDirectoryNotFound" xml:space="preserve">
    <value>Le répertoire de recherche '{0}' est introuvable</value>
  </data>
  <data name="tcConstructIsAmbiguousInComputationExpression" xml:space="preserve">
    <value>Cette construction est ambiguë dans le cadre d'une expression de calcul. Les expressions imbriquées peuvent être écrites avec 'let _ = (...)' et les calculs imbriqués avec 'let! res = builder {{ ... }}'.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureDefinesButImplDoesNot" xml:space="preserve">
    <value>Les {0} définitions pour le type '{1}' dans la signature et l'implémentation ne sont pas compatibles, car la signature définit le {2} '{3}' mais l'implémentation ne le fait pas (ou elle le fait mais dans un ordre différent)</value>
  </data>
  <data name="typeInfoFullName" xml:space="preserve">
    <value>Nom complet</value>
  </data>
  <data name="optsFullpaths" xml:space="preserve">
    <value>Messages de sortie avec chemins d'accès qualifiés complets</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldWasPresent" xml:space="preserve">
    <value>Les {0} définitions pour le type '{1}' dans la signature et l'implémentation ne sont pas compatibles, car le champ {2} était présent dans l'implémentation mais pas dans la signature</value>
  </data>
  <data name="optsNoCopyFsharpCore" xml:space="preserve">
    <value>Ne pas copier FSharp.Core.dll avec les fichiers binaires produits</value>
  </data>
  <data name="csGenericConstructRequiresUnmanagedType" xml:space="preserve">
    <value>Une construction générique requiert que le type '{0}' soit de type non managé</value>
  </data>
  <data name="typrelExplicitImplementationOfEquals" xml:space="preserve">
    <value>Le type struct, enregistrement ou union '{0}' a une implémentation explicite de 'Object.Equals'. Implémentez une substitution correspondante pour 'Object.GetHashCode()'</value>
  </data>
  <data name="tcIllegalFormForExplicitTypeDeclaration" xml:space="preserve">
    <value>Les déclarations de type explicite pour les constructeurs doivent être sous la forme 'ty1 * ... * tyN -&gt; resTy'. Des parenthèses peuvent être requises autour de 'resTy'</value>
  </data>
  <data name="keywordDescriptionRec" xml:space="preserve">
    <value>Permet d'indiquer qu'une fonction est récursive.</value>
  </data>
  <data name="keywordDescriptionVal" xml:space="preserve">
    <value>Utilisé dans une signature pour indiquer une valeur, ou dans un type pour déclarer un membre, dans des situations limitées.</value>
  </data>
  <data name="keywordDescriptionUse" xml:space="preserve">
    <value>Utilisé à la place de let pour les valeurs qui nécessitent l'appel de Dispose pour libérer des ressources.</value>
  </data>
  <data name="keywordDescriptionTry" xml:space="preserve">
    <value>Permet d'introduire un bloc de code pouvant générer une exception. Utilisé avec with ou finally.</value>
  </data>
  <data name="keywordDescriptionNew" xml:space="preserve">
    <value>Permet de déclarer, de définir ou d'appeler un constructeur qui crée ou peut créer un objet. Également utilisé dans les contraintes de paramètre générique pour indiquer qu'un type doit avoir un certain constructeur.</value>
  </data>
  <data name="keywordDescriptionNot" xml:space="preserve">
    <value>Il ne s'agit pas vraiment d'un mot clé. Toutefois, dans le cadre d'une combinaison, not struct est utilisé comme une contrainte de paramètre générique.</value>
  </data>
  <data name="keywordDescriptionLet" xml:space="preserve">
    <value>Permet d'associer, ou de lier, un nom à une valeur ou une fonction.</value>
  </data>
  <data name="keywordDescriptionFun" xml:space="preserve">
    <value>Utilisé dans les expressions lambda, également appelées fonctions anonymes.</value>
  </data>
  <data name="keywordDescriptionFor" xml:space="preserve">
    <value>Utilisé dans les constructions de boucle.</value>
  </data>
  <data name="keywordDescriptionEnd" xml:space="preserve">
    <value>Dans les définitions de type et les extensions de type, indique la fin d'une section de définitions de membre. En syntaxe détaillée, permet de spécifier la fin d'un bloc de code qui commence par le mot clé begin.</value>
  </data>
  <data name="chkGetterAndSetterHaveSamePropertyType" xml:space="preserve">
    <value>Les méthodes getter et setter d'une propriété doivent avoir le même type. La propriété '{0}' a une méthode getter de type '{1}' alors que sa méthode setter est de type '{2}'.</value>
  </data>
  <data name="tcInvalidTypeArgumentCount" xml:space="preserve">
    <value>Le nombre d'arguments de type ne correspond pas : '{0}' fournis, '{1}' attendus. Ceci peut-être dû à une erreur signalée précédemment.</value>
  </data>
  <data name="tcFieldRequiresName" xml:space="preserve">
    <value>Ce champ requiert un nom</value>
  </data>
  <data name="typeInfoGeneratedType" xml:space="preserve">
    <value>type généré</value>
  </data>
  <data name="buildInvalidVersionString" xml:space="preserve">
    <value>Chaîne de version non valide '{0}'</value>
  </data>
  <data name="tcInvalidTypeArgumentUsage" xml:space="preserve">
    <value>Impossible de spécifier des arguments de type ici</value>
  </data>
  <data name="lexOutsideNativeSigned" xml:space="preserve">
    <value>Ce nombre se trouve en dehors de la plage autorisée pour les entiers natifs signés</value>
  </data>
  <data name="tcTypeTestLossy" xml:space="preserve">
    <value>Ce test de type ou ce cast d'une classe de base va effacer le type fourni '{0}' et le remplacer par le type '{1}'</value>
  </data>
  <data name="parsInheritDeclarationsCannotHaveAsBindings" xml:space="preserve">
    <value>Les déclarations 'inherit' ne peuvent pas avoir de liaisons 'as'. Pour accéder aux membres de la classe de base lors de la substitution d'une méthode, la syntaxe 'base.SomeMember' peut être utilisée ; 'base' est un mot clé. Supprimez cette liaison 'as'.</value>
  </data>
  <data name="keywordDescriptionDelegate" xml:space="preserve">
    <value>Permet de déclarer un délégué.</value>
  </data>
  <data name="csMethodNotFound" xml:space="preserve">
    <value>Méthode ou constructeur d'objet '{0}' introuvable</value>
  </data>
  <data name="forBadWidth" xml:space="preserve">
    <value>Largeur incorrecte du spécificateur de format</value>
  </data>
  <data name="tcAllowNullTypesMayOnlyInheritFromAllowNullTypes" xml:space="preserve">
    <value>Les types avec l'attribut 'AllowNullLiteral' ne peuvent hériter que des types ou implémenter que les types qui autorisent également l'utilisation du littéral null</value>
  </data>
  <data name="tcStaticInitializerRequiresArgument" xml:space="preserve">
    <value>Un initialiseur statique requiert un argument</value>
  </data>
  <data name="tcSyntaxErrorUnexpectedQMark" xml:space="preserve">
    <value>Erreur de syntaxe - symbole '?' inattendu</value>
  </data>
  <data name="tcInvalidUseOfInterfaceType" xml:space="preserve">
    <value>Utilisation non valide d'un type interface</value>
  </data>
  <data name="parsSuccessivePatternsShouldBeSpacedOrTupled" xml:space="preserve">
    <value>Les modèles successifs doivent être séparés par des espaces ou être basés sur des tuples</value>
  </data>
  <data name="csRequiredSignatureIs" xml:space="preserve">
    <value>La signature requise est {0}</value>
  </data>
  <data name="elSysEnvExitDidntExit" xml:space="preserve">
    <value>System.Environment.Exit n'est pas sorti</value>
  </data>
  <data name="tcStaticOptimizationConditionalsOnlyForFSharpLibrary" xml:space="preserve">
    <value>Les conditions de l'optimisation statique sont uniquement utilisables dans la bibliothèque F#</value>
  </data>
  <data name="arrayElementHasWrongType" xml:space="preserve">
    <value>Tous les éléments d'une expression comportant un constructeur de tableau doivent avoir le même type. Cette expression était censée avoir le type '{0}', mais elle a ici le type '{1}'.</value>
  </data>
  <data name="csTypeCannotBeResolvedAtCompileTime" xml:space="preserve">
    <value>Impossible d'utiliser ici le paramètre de type déclaré '{0}', car le paramètre de type ne peut pas être résolu au moment de la compilation</value>
  </data>
  <data name="buildInvalidAssemblyName" xml:space="preserve">
    <value>'{0}' n'est pas un nom d'assembly valide</value>
  </data>
  <data name="tcInvalidActivePatternName" xml:space="preserve">
    <value>Nom non valide pour un modèle actif</value>
  </data>
  <data name="missingElseBranch" xml:space="preserve">
    <value>Il manque à l'expression 'if' une branche 'else'. La branche 'then' a le type '{0}'. Dans la mesure où 'if' est une expression, et non une instruction, ajoutez une branche 'else' qui retourne une valeur du même type.</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeSignature" xml:space="preserve">
    <value>Fin d'entrée inattendue dans la signature de type</value>
  </data>
  <data name="chkDuplicateMethod" xml:space="preserve">
    <value>Méthode dupliquée. La méthode '{0}' a le même nom et la même signature qu'une autre méthode dans le type '{1}'.</value>
  </data>
  <data name="typrelMethodIsOverconstrained" xml:space="preserve">
    <value>Cette méthode est contrainte de manière excessive dans ses paramètres de type</value>
  </data>
  <data name="patcMissingVariable" xml:space="preserve">
    <value>Variable manquante '{0}'</value>
  </data>
  <data name="parsInlineAssemblyCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Les modificateurs d'accessibilité ne sont pas autorisés sur les types de codes assembleur inline</value>
  </data>
  <data name="ilReflectedDefinitionsCannotUseSliceOperator" xml:space="preserve">
    <value>Les définitions réfléchies ne peuvent pas contenir d'utilisations de l'opérateur d'ajout de préfixe '%'</value>
  </data>
  <data name="tcInvalidUnitsOfMeasurePrefix" xml:space="preserve">
    <value>Impossible d'utiliser des unités de mesure en tant qu'arguments de préfixe pour un type. Réécrivez-les en tant qu'arguments postfixés dans des crochets pointus.</value>
  </data>
  <data name="csStructConstraintInconsistent" xml:space="preserve">
    <value>Les contraintes 'struct' et 'not struct' ne sont pas cohérentes</value>
  </data>
  <data name="tcLiteralDoesNotTakeArguments" xml:space="preserve">
    <value>Ce modèle de littéral n'accepte pas d'arguments</value>
  </data>
  <data name="parsInvalidDeclarationSyntax" xml:space="preserve">
    <value>Syntaxe de déclaration non valide</value>
  </data>
  <data name="csTypesDoNotSupportOperator" xml:space="preserve">
    <value>Aucun des types '{0}' ne prend en charge l'opérateur '{1}'</value>
  </data>
  <data name="tcTypesAreAlwaysSealedDelegate" xml:space="preserve">
    <value>Les types délégués sont toujours sealed</value>
  </data>
  <data name="parsExpectedExpressionAfterToken" xml:space="preserve">
    <value>Une expression était attendue après ce point</value>
  </data>
  <data name="chkTypeLessAccessibleThanType" xml:space="preserve">
    <value>Le type '{0}' est moins accessible que la valeur, le membre ou le type '{1}' dans lequel il est utilisé.</value>
  </data>
  <data name="optsDeterministic" xml:space="preserve">
    <value>Produire un assembly déterministe (en incluant le GUID et l'horodateur de la version du module)</value>
  </data>
  <data name="etUnexpectedNullFromProvidedTypeMember" xml:space="preserve">
    <value>Valeur 'null' inattendue retournée par le type fourni '{0}', membre '{1}'</value>
  </data>
  <data name="tcCouldNotFindIDisposable" xml:space="preserve">
    <value>Impossible de trouver Dispose sur IDisposable, ou il a été surchargé</value>
  </data>
  <data name="buildInvalidPrivacy" xml:space="preserve">
    <value>Paramètre de confidentialité '{0}' non reconnu pour la ressource managée, les options valides sont 'public' et 'private'</value>
  </data>
  <data name="optValueMarkedInlineCouldNotBeInlined" xml:space="preserve">
    <value>Impossible d'effectuer l'incorporation (inlining) d'une valeur marquée comme 'inline'</value>
  </data>
  <data name="csGenericConstructRequiresPublicDefaultConstructor" xml:space="preserve">
    <value>Une construction générique requiert que le type '{0}' ait un constructeur par défaut public</value>
  </data>
  <data name="csMemberIsNotInstance" xml:space="preserve">
    <value>{0} n'est pas un membre d'instance</value>
  </data>
  <data name="crefQuotationsCantContainThisConstant" xml:space="preserve">
    <value>Les quotations ne peuvent pas contenir ce genre de constante</value>
  </data>
  <data name="etIncorrectParameterExpression" xml:space="preserve">
    <value>Le fournisseur de type '{0}' a utilisé un paramètre non valide dans ParameterExpression : {1}</value>
  </data>
  <data name="tcNonUniformMemberUse" xml:space="preserve">
    <value>Le membre générique '{0}' a été utilisé au niveau d'une instanciation non uniforme avant ce point du programme. Réorganisez les membres afin que ce membre se produise en premier. Vous pouvez également spécifier le type complet du membre de façon explicite, y compris les types d'arguments, le type de retour et d'autres paramètres et contraintes génériques.</value>
  </data>
  <data name="chkCantStoreByrefValue" xml:space="preserve">
    <value>Un type doit stocker une valeur typée byref. Cela n'est pas autorisé par le langage CIL (Common Intermediate Language).</value>
  </data>
  <data name="fscNoImplementationFiles" xml:space="preserve">
    <value>Aucun fichier d'implémentation n'a été spécifié</value>
  </data>
  <data name="ValueNotContainedMutabilityInlineFlagsDiffer" xml:space="preserve">
    <value>Le module '{0}' contient\n    {1}    \nmais sa signature spécifie\n    {2}    \nLes indicateurs inline sont différents</value>
  </data>
  <data name="tcInvalidNamespaceModuleTypeUnionName" xml:space="preserve">
    <value>Nom d'espace de noms, de module, de type ou de cas d'union non valide</value>
  </data>
  <data name="tcTypeAbbreviationsMayNotHaveMembers" xml:space="preserve">
    <value>Les abréviations de type ne peuvent pas avoir de membres</value>
  </data>
  <data name="tcRecImplied" xml:space="preserve">
    <value>Le mot clé 'rec' sur ce module étant impliqué par une déclaration 'rec' externe, il est ignoré</value>
  </data>
  <data name="tcTypeIsNotARecordTypeNeedConstructor" xml:space="preserve">
    <value>Ce type n'est pas un type enregistrement. Les valeurs des types classe et struct doivent être créées à l'aide d'appels à des constructeurs d'objets.</value>
  </data>
  <data name="csExpectTypeWithOperatorButGivenFunction" xml:space="preserve">
    <value>Un type prenant en charge l'opérateur '{0}' est attendu mais un type de fonction a été reçu. Il manque peut-être un argument à une fonction.</value>
  </data>
  <data name="tcNamespaceCannotContainValues" xml:space="preserve">
    <value>Les espaces de noms ne peuvent pas contenir de valeurs. Utilisez un module pour conserver vos déclarations de valeur.</value>
  </data>
  <data name="noInvokeMethodsFound" xml:space="preserve">
    <value>Aucune méthode Invoke trouvée pour le type délégué</value>
  </data>
  <data name="parsIncompleteIf" xml:space="preserve">
    <value>Expression conditionnelle incomplète. 'if &lt;expr&gt; then &lt;expr&gt;' ou 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;' était attendu.</value>
  </data>
  <data name="tcCustomOperationMayNotBeUsedHere" xml:space="preserve">
    <value>Une opération personnalisée ne peut pas être utilisée en association avec les opérateurs 'use', 'try/with', 'try/finally', 'if/then/else' ou 'match' dans cette expression de calcul</value>
  </data>
  <data name="augStructCompNeedsStructEquality" xml:space="preserve">
    <value>L'attribut 'StructuralComparison' doit être utilisé conjointement avec l'attribut 'StructuralEquality'</value>
  </data>
  <data name="parsInvalidUseOfRec" xml:space="preserve">
    <value>Utilisation non valide du mot clé 'rec'</value>
  </data>
  <data name="tcEnumerationsMayNotHaveMembers" xml:space="preserve">
    <value>Les énumérations ne peuvent pas avoir de membres</value>
  </data>
  <data name="undefinedNameRecordLabelOrNamespace" xml:space="preserve">
    <value>L'étiquette d'enregistrement ou l'espace de noms '{0}' n'est pas défini.</value>
  </data>
  <data name="crefQuotationsCantContainGenericExprs" xml:space="preserve">
    <value>Les quotations ne peuvent pas contenir d'utilisations d'expressions génériques</value>
  </data>
  <data name="optsDCLONoDescription" xml:space="preserve">
    <value>L'option de ligne de commande '{0}' est déconseillée</value>
  </data>
  <data name="keywordDescriptionLetBang" xml:space="preserve">
    <value>Utilisé dans les flux de travail asynchrones pour lier un nom au résultat d'un calcul asynchrone ou, dans d'autres expressions de calcul, pour lier un nom à un résultat, qui correspond au type de calcul.</value>
  </data>
  <data name="typeInfoCallsWord" xml:space="preserve">
    <value>Appels</value>
  </data>
  <data name="lexHashElseNoMatchingIf" xml:space="preserve">
    <value>#else n'a aucun #if correspondant</value>
  </data>
  <data name="optsClirootDescription" xml:space="preserve">
    <value>Permet de substituer l'emplacement où le compilateur recherche mscorlib.dll et les composants .NET Framework</value>
  </data>
  <data name="csMemberSignatureMismatchArityType" xml:space="preserve">
    <value>Le membre ou le constructeur d'objet '{0}' accepte {1} argument(s) de type mais en reçoit ici {2}. La signature requise est '{3}'.</value>
  </data>
  <data name="itemNotFoundDuringDynamicCodeGen" xml:space="preserve">
    <value>{0} '{1}' introuvable dans l'assembly '{2}'. Cela est peut-être dû à une incompatibilité de version. Vous devrez peut-être référencer explicitement la version appropriée de cet assembly pour permettre à tous les composants référencés d'utiliser la version nécessaire.</value>
  </data>
  <data name="tcIllegalSyntaxInTypeExpression" xml:space="preserve">
    <value>Syntaxe non conforme dans l'expression de type</value>
  </data>
  <data name="lexOutsideIntegerRange" xml:space="preserve">
    <value>Ce nombre se trouve en dehors de la plage autorisée pour ce type d'entier</value>
  </data>
  <data name="activePatternIdentIsNotFunctionTyped" xml:space="preserve">
    <value>Le modèle actif '{0}' n'est pas une fonction</value>
  </data>
  <data name="chkGetterSetterDoNotMatchAbstract" xml:space="preserve">
    <value>La propriété '{0}' de type '{1}' a une méthode getter et une méthode setter qui ne correspondent pas. Si l'une est abstraite, l'autre doit l'être également.</value>
  </data>
  <data name="tcNoIntegerForLoopInQuery" xml:space="preserve">
    <value>Dans les requêtes, utilisez la forme 'for x in n .. m do …' pour couvrir les entiers</value>
  </data>
  <data name="parsEofInTripleQuoteString" xml:space="preserve">
    <value>La fin du fichier dans une chaîne à guillemets triples a commencé ici ou avant ici</value>
  </data>
  <data name="parsUnexpectedEndOfFileDefinition" xml:space="preserve">
    <value>Fin d'entrée inattendue dans la définition de valeur, de fonction ou de membre</value>
  </data>
  <data name="csCtorSignatureMismatchArityProp" xml:space="preserve">
    <value>Le constructeur d'objet '{0}' accepte {1} argument(s), mais il en reçoit {2} ici. La signature exigée est '{3}'. Si certains arguments sont destinés à affecter des valeurs aux propriétés, séparez ces arguments par une virgule (',').</value>
  </data>
  <data name="tcCallerInfoWrongType" xml:space="preserve">
    <value>'{0}' doit être appliqué à un argument de type '{1}', mais il a été appliqué à un argument de type '{2}'</value>
  </data>
  <data name="tcCannotCreateExtensionOfSealedType" xml:space="preserve">
    <value>Impossible de créer une extension d'un type sealed</value>
  </data>
  <data name="parsNoMatchingInForLet" xml:space="preserve">
    <value>Impossible de trouver un 'in' correspondant pour ce 'let'</value>
  </data>
  <data name="parsIgnoreVisibilityOnModuleAbbreviationAlwaysPrivate" xml:space="preserve">
    <value>L'attribut de visibilité '{0}' n'est pas autorisé pour l'abréviation du module. Les abréviations de module sont toujours privées.</value>
  </data>
  <data name="augNoCompCantImpIComp" xml:space="preserve">
    <value>Un type avec l'attribut 'NoComparison' ne doit généralement pas avoir une implémentation explicite de 'System.IComparable', 'System.IComparable&lt;_&gt;' ou 'System.Collections.IStructuralComparable'. Désactivez cet avertissement s'il résulte d'une action intentionnelle à des fins d'interopérabilité</value>
  </data>
  <data name="tcConstructRequiresComputationExpressions" xml:space="preserve">
    <value>Cette construction ne peut être utilisée que dans des expressions de calcul. Pour retourner une valeur à partir d'une fonction ordinaire, écrivez simplement l'expression sans 'return'.</value>
  </data>
  <data name="parsMutableOnAutoPropertyShouldBeGetSet" xml:space="preserve">
    <value>Les définitions de propriété ne doivent pas être déclarées comme étant mutables. Pour indiquer que cette propriété peut être définie, utilisez 'member val PropertyName = expr with get,set'.</value>
  </data>
  <data name="optsHelpBannerAdvanced" xml:space="preserve">
    <value>- AVANCÉ -</value>
  </data>
  <data name="FieldNotContainedStaticsDiffer" xml:space="preserve">
    <value>Le module contient le champ\n    {0}    \nmais sa signature spécifie\n    {1}    \nLes modificateurs 'static' sont différents</value>
  </data>
  <data name="chkUnionCaseCompiledForm" xml:space="preserve">
    <value>forme compilée du cas d'union</value>
  </data>
  <data name="buildAssemblyResolutionFailed" xml:space="preserve">
    <value>Échec de la résolution de l'assembly à cet emplacement ou à proximité</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldOrderDiffer" xml:space="preserve">
    <value>Les {0} définitions pour le type '{1}' dans la signature et l'implémentation ne sont pas compatibles, car l'ordre des champs est différent entre la signature et l'implémentation</value>
  </data>
  <data name="tcAbstractMembersIllegalInAugmentation" xml:space="preserve">
    <value>Les membres abstraits ne sont pas autorisés dans une augmentation. Ils doivent être définis dans le cadre du type lui-même</value>
  </data>
  <data name="parsUnexpectedEndOfFileThen" xml:space="preserve">
    <value>Fin d'entrée inattendue dans la branche 'then' d'une expression conditionnelle. 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;' était attendu.</value>
  </data>
  <data name="parsUnexpectedEndOfFileWith" xml:space="preserve">
    <value>Fin d'entrée inattendue dans l'expression 'match' ou 'try'</value>
  </data>
  <data name="parsUnexpectedEndOfFileElse" xml:space="preserve">
    <value>Fin d'entrée inattendue dans la branche 'else' d'une expression conditionnelle. 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;' était attendu.</value>
  </data>
  <data name="tcNoArgumentsForRecordValue" xml:space="preserve">
    <value>Aucun argument ne peut être fourni lors de la construction d'une valeur d'enregistrement</value>
  </data>
  <data name="lexhlpIdentifiersContainingAtSymbolReserved" xml:space="preserve">
    <value>Les identificateurs qui contiennent '@' sont réservés pour la génération de code F#</value>
  </data>
  <data name="tcLookupMayNotBeUsedHere" xml:space="preserve">
    <value>Impossible d'utiliser cette recherche ici</value>
  </data>
  <data name="tcMembersThatExtendInterfaceMustBePlacedInSeparateModule" xml:space="preserve">
    <value>Les membres qui étendent les types interface, délégués ou enum doivent être placés dans un module distinct de la définition du type. Ce module doit avoir l'attribut AutoOpen ou être ouvert explicitement par le code client afin de placer les membres d'extension dans la portée.</value>
  </data>
  <data name="tcNoInterfaceImplementationForConstructionExpression" xml:space="preserve">
    <value>Impossible de fournir des implémentations d'interfaces pour des expressions de construction</value>
  </data>
  <data name="tcNotSufficientlyGenericBecauseOfScope" xml:space="preserve">
    <value>Ce code n'est pas suffisamment générique. Impossible de généraliser la variable de type {0}, car elle sort de sa portée.</value>
  </data>
  <data name="parsEofInIfOcaml" xml:space="preserve">
    <value>Fin de fichier dans la section IF-OCAML ayant débuté à cet emplacement ou avant</value>
  </data>
  <data name="tcOnlyClassesCanHaveAbstract" xml:space="preserve">
    <value>Seules les classes peuvent recevoir l'attribut 'AbstractClass'</value>
  </data>
  <data name="chkSystemVoidOnlyInTypeof" xml:space="preserve">
    <value>'System.Void' ne peut être utilisé que sous la forme 'typeof&lt;System.Void&gt;' en F#</value>
  </data>
  <data name="parsMultiArgumentGenericTypeFormDeprecated" xml:space="preserve">
    <value>La syntaxe '(typ,...,typ) ident' n'est pas utilisée pour le code F#. Utilisez 'ident&lt;typ,...,typ&gt;' à la place</value>
  </data>
  <data name="tcStructTypesCannotContainAbstractMembers" xml:space="preserve">
    <value>Les types struct ne peuvent pas contenir de membres abstraits</value>
  </data>
  <data name="tcNewMemberHidesAbstractMemberWithSuffix" xml:space="preserve">
    <value>Ce nouveau membre masque le membre abstrait '{0}', une fois les tuples, fonctions, les unités de mesure et/ou les types fournis effacés. Renommez le membre ou utilisez 'override' à la place.</value>
  </data>
  <data name="tastUnexpectedDecodeOfInterfaceDataVersionAttribute" xml:space="preserve">
    <value>Décodage inattendu de InterfaceDataVersionAttribute</value>
  </data>
  <data name="lexfltSeparatorTokensOfPatternMatchMisaligned" xml:space="preserve">
    <value>Les jetons '|' qui séparent les règles de ce critère spécial sont décalés d'une colonne. Réalignez votre code ou effectuez une mise en retrait supplémentaire.</value>
  </data>
  <data name="ValueNotContainedMutabilityArityNotInferred" xml:space="preserve">
    <value>Le module '{0}' contient\n    {1}    \nmais sa signature spécifie\n    {2}    \nAucune arité n'a été déduite pour cette valeur</value>
  </data>
  <data name="tcUnexpectedPropertyInSyntaxTree" xml:space="preserve">
    <value>Spécification de propriété au niveau source inattendue dans l'arborescence de syntaxe</value>
  </data>
  <data name="tcExtraneousFieldsGivenValues" xml:space="preserve">
    <value>Des champs superflus ont reçu des valeurs</value>
  </data>
  <data name="keywordDescriptionDowncast" xml:space="preserve">
    <value>Permet de convertir en un type inférieur dans la chaîne d'héritage.</value>
  </data>
  <data name="tupleRequiredInAbstractMethod" xml:space="preserve">
    <value>\nUn type de tuple est nécessaire pour un ou plusieurs arguments. Mettez des parenthèses supplémentaires autour des arguments fournis, ou passez en revue la définition de l'interface.</value>
  </data>
  <data name="tcUnexpectedBigRationalConstant" xml:space="preserve">
    <value>Constante rationnelle importante inattendue</value>
  </data>
  <data name="ilSignBadImageFormat" xml:space="preserve">
    <value>Format d'image incorrect</value>
  </data>
  <data name="etEmptyNamespaceNotAllowed" xml:space="preserve">
    <value>Un nom d'espace vide a été trouvé par le fournisseur de type '{0}'. Utilisez 'null' pour l'espace de noms global.</value>
  </data>
  <data name="ModuleContainsConstructorButNamesDiffer" xml:space="preserve">
    <value>Le module contient le constructeur\n    {0}    \nmais sa signature spécifie\n    {1}    \nLes noms sont différents</value>
  </data>
  <data name="customOperationTextLikeJoin" xml:space="preserve">
    <value>{0} var in collection {1} (outerKey = innerKey). Notez que les parenthèses sont obligatoires après '{2}'</value>
  </data>
  <data name="parsInOrEqualExpected" xml:space="preserve">
    <value>'in' ou '=' attendu</value>
  </data>
  <data name="tastUnexpectedDecodeOfInternalsVisibleToAttribute" xml:space="preserve">
    <value>Décodage inattendu de InternalsVisibleToAttribute</value>
  </data>
  <data name="ppparsIncompleteExpression" xml:space="preserve">
    <value>Expression de préprocesseur incomplète</value>
  </data>
  <data name="tcExprUndelayed" xml:space="preserve">
    <value>TcExprUndelayed : différé</value>
  </data>
  <data name="etDirectReferenceToGeneratedTypeNotAllowed" xml:space="preserve">
    <value>Une référence directe au type généré '{0}' n'est pas autorisée. À la place, utilisez une définition de type, par exemple 'type TypeAlias = &lt;chemin&gt;'. Ceci indique qu'un fournisseur de type ajoute les types générés à votre assembly.</value>
  </data>
  <data name="lexWrongNestedHashEndif" xml:space="preserve">
    <value>Erreur de syntaxe. Imbrication incorrecte de #endif, jetons inattendus devant.</value>
  </data>
  <data name="optsWarnOn" xml:space="preserve">
    <value>Activer les avertissements spécifiques qui peuvent être désactivés par défaut</value>
  </data>
  <data name="tcNamedActivePattern" xml:space="preserve">
    <value>{0} est un modèle actif. Il ne peut pas être traité comme un cas d'union discriminé avec des champs nommés.</value>
  </data>
  <data name="tcTypesAreAlwaysSealedRecord" xml:space="preserve">
    <value>Les types enregistrement sont toujours sealed</value>
  </data>
  <data name="tcInvalidSignatureForSet" xml:space="preserve">
    <value>Signature non valide pour le membre défini</value>
  </data>
  <data name="tcNoWhileInQuery" xml:space="preserve">
    <value>Les expressions 'while' ne peuvent pas être utilisées dans les requêtes</value>
  </data>
  <data name="lexInvalidCharLiteral" xml:space="preserve">
    <value>Littéral de caractère non valide</value>
  </data>
  <data name="tcReturnValuesCannotHaveNames" xml:space="preserve">
    <value>Les valeurs de retour ne peuvent pas avoir de noms</value>
  </data>
  <data name="tcCannotInheritFromErasedType" xml:space="preserve">
    <value>Impossible d'hériter d'un type fourni effacé</value>
  </data>
  <data name="etErasedTypeUsedInGeneration" xml:space="preserve">
    <value>Le fournisseur '{0}' a retourné un type non généré '{1}' dans le contexte d'un ensemble de type générés. Envisagez d'ajuster le fournisseur de type de manière à retourner uniquement les types générés.</value>
  </data>
  <data name="tcInvalidEnumConstraint" xml:space="preserve">
    <value>Une contrainte 'enum' doit être sous la forme 'enum&lt;type&gt;'</value>
  </data>
  <data name="ValueNotContainedMutabilityAbstractsDiffer" xml:space="preserve">
    <value>Le module '{0}' contient\n    {1}    \nmais sa signature spécifie\n    {2}    \nL'un est abstrait mais pas l'autre</value>
  </data>
  <data name="tcInvalidMethodNameForEquality" xml:space="preserve">
    <value>Le nom '({0})' ne doit pas être utilisé en tant que nom de membre. Pour définir une sémantique d'égalité pour un type, substituez le membre 'Object.Equals'. Si vous définissez un membre statique à utiliser à partir d'autres langages CLI, utilisez le nom '{1}' à la place.</value>
  </data>
  <data name="lexOusideDecimal" xml:space="preserve">
    <value>Ce nombre se trouve en dehors de la plage autorisée pour les littéraux décimaux</value>
  </data>
  <data name="etTooManyStaticParameters" xml:space="preserve">
    <value>Paramètres statiques trop nombreux. {0} paramètres au maximum étaient attendus, mais {1} paramètres non nommés et {2} paramètres nommés ont été reçus.</value>
  </data>
  <data name="parsNoEqualShouldFollowNamespace" xml:space="preserve">
    <value>Aucun symbole '=' ne doit suivre une déclaration 'namespace'</value>
  </data>
  <data name="tcPredefinedTypeCannotBeUsedAsSuperType" xml:space="preserve">
    <value>Impossible d'utiliser les types System.ValueType, System.Enum, System.Delegate, System.MulticastDelegate et System.Array en tant que super types dans une classe ou une expression d'objet</value>
  </data>
  <data name="buildMultipleToplevelModules" xml:space="preserve">
    <value>Ce fichier contient plusieurs déclarations ayant la forme 'module SomeNamespace.SomeModule'. Seule une déclaration de cette forme est autorisée dans un fichier. Modifiez votre fichier pour utiliser une déclaration d'espace de noms initiale et/ou utilisez 'module ModuleName = ...' pour définir vos modules.</value>
  </data>
  <data name="tcCannotInheritFromInterfaceType" xml:space="preserve">
    <value>Impossible d'hériter du type interface. Utilisez interface ... with à la place.</value>
  </data>
  <data name="optsCrossoptimize" xml:space="preserve">
    <value>Activer ou désactiver les optimisations entre modules</value>
  </data>
  <data name="FieldNotContainedAccessibilitiesDiffer" xml:space="preserve">
    <value>Le module contient le champ\n    {0}    \nmais sa signature spécifie\n    {1}    \nL'accessibilité spécifiée dans la signature est supérieure à celle spécifiée dans l'implémentation</value>
  </data>
  <data name="keywordDescriptionSelect" xml:space="preserve">
    <value>Utilisé dans les expressions de requête pour spécifier les champs ou colonnes à extraire. Notez qu'il s'agit d'un mot clé contextuel, ce qui signifie qu'il ne s'agit pas réellement d'un mot réservé et qu'il se comporte uniquement comme un mot clé dans le contexte approprié.</value>
  </data>
  <data name="chkNoAddressFieldAtThisPoint" xml:space="preserve">
    <value>Impossible d'utiliser l'adresse du champ '{0}' actuellement</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInUnmanaged" xml:space="preserve">
    <value>Impossible de résoudre l'ambigüité liée à l'utilisation d'une construction générique avec une contrainte 'unmanaged' à cette position ou à proximité</value>
  </data>
  <data name="tcThisTypeMayNotHaveACLIMutableAttribute" xml:space="preserve">
    <value>Cette définition de type ne peut pas avoir d'attribut 'CLIMutable'. Seuls les types d'enregistrements peuvent avoir cet attribut.</value>
  </data>
  <data name="lexOutsideSixtyFourBitSigned" xml:space="preserve">
    <value>Ce nombre se trouve en dehors de la plage autorisée pour les entiers signés 64 bits</value>
  </data>
  <data name="parsEnumFieldsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Les modificateurs d'accessibilité ne sont pas autorisés sur les champs d'énumération</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleNumbersDiffer" xml:space="preserve">
    <value>Les {0} définitions pour le type '{1}' dans la signature et l'implémentation ne sont pas compatibles, car le nombre de {2} est différent</value>
  </data>
  <data name="tcInvalidTypeExtension" xml:space="preserve">
    <value>Extension de type non valide</value>
  </data>
  <data name="buildProblemWithFilename" xml:space="preserve">
    <value>Problème avec le nom de fichier '{0}' : {1}</value>
  </data>
  <data name="lexHashEndifRequiredForElse" xml:space="preserve">
    <value>#endif requis pour #else</value>
  </data>
  <data name="keywordDescriptionStruct" xml:space="preserve">
    <value>Permet de déclarer un type structure. Utilisé également dans les contraintes de paramètre générique. Utilisé pour la compatibilité OCaml dans les définitions de module.</value>
  </data>
  <data name="keywordDescriptionStatic" xml:space="preserve">
    <value>Permet d'indiquer une méthode ou une propriété qui peut être appelée sans instance d'un type, ou un membre de valeur partagé entre toutes les instances d'un type.</value>
  </data>
  <data name="tcEntryPointAttributeRequiresFunctionInModule" xml:space="preserve">
    <value>L'attribut 'EntryPointAttribute' ne peut être utilisé que sur les définitions de fonctions dans les modules</value>
  </data>
  <data name="DefaultParameterValueNotAppropriateForArgument" xml:space="preserve">
    <value>La valeur par défaut n'a pas le même type que l'argument. L'attribut DefaultParameterValue et tous les attributs facultatifs seront ignorés. Remarque : 'null' doit être annoté avec le type approprié, par ex., 'DefaultParameterValue(null:obj)'.</value>
  </data>
  <data name="csIncorrectGenericInstantiation" xml:space="preserve">
    <value>Instanciation générique incorrecte. Aucun membre {0} nommé '{1}' n'accepte {2} arguments génériques.</value>
  </data>
  <data name="tcNamespaceCannotContainExtensionMembers" xml:space="preserve">
    <value>Les espaces de noms ne peuvent pas contenir de membres d'extension sauf dans le groupe de déclarations de fichiers et d'espaces de noms où le type est défini. Utilisez un module pour conserver les déclarations des membres d'extension.</value>
  </data>
  <data name="keywordDescriptionReturn" xml:space="preserve">
    <value>Permet d'indiquer une valeur à fournir en tant que résultat d'une expression de calcul.</value>
  </data>
  <data name="valueIsNotAccessible" xml:space="preserve">
    <value>La valeur '{0}' n'est pas accessible à partir de cet emplacement du code</value>
  </data>
  <data name="lexfltIncorrentIndentationOfIn" xml:space="preserve">
    <value>La mise en retrait de ce jeton 'in' est incorrecte par rapport au 'let' correspondant</value>
  </data>
  <data name="impTypeRequiredUnavailable" xml:space="preserve">
    <value>Le type '{0}' est requis ici et n'est pas disponible. Vous devez ajouter une référence à l'assembly '{1}'.</value>
  </data>
  <data name="tcOperatorDoesntAcceptInto" xml:space="preserve">
    <value>L'opérateur '{0}' n'accepte pas l'utilisation de 'into'</value>
  </data>
  <data name="csMemberIsNotStatic" xml:space="preserve">
    <value>{0} n'est pas un membre statique</value>
  </data>
  <data name="tcAnonymousTypeInvalidInDeclaration" xml:space="preserve">
    <value>Les variables de type anonyme ne sont pas autorisées dans cette déclaration</value>
  </data>
  <data name="tcRecordFieldInconsistentTypes" xml:space="preserve">
    <value>Cet enregistrement contient des champs de types incohérents</value>
  </data>
  <data name="tcTypeDefinitionsWithImplicitConstructionMustHaveLocalBindingsBeforeMembers" xml:space="preserve">
    <value>Les liaisons 'let' et 'do' doivent précéder les définitions de membre et d'interface dans les définitions de type</value>
  </data>
  <data name="buildDirectivesInModulesAreIgnored" xml:space="preserve">
    <value>Les directives contenues dans les modules sont ignorées</value>
  </data>
  <data name="lexOutsideSixteenBitSigned" xml:space="preserve">
    <value>Ce nombre se trouve en dehors de la plage autorisée pour les entiers signés 16 bits</value>
  </data>
  <data name="optsProblemWithCodepage" xml:space="preserve">
    <value>Problème avec la page de codes '{0}' : {1}</value>
  </data>
  <data name="tcAttributeExpressionsMustBeConstructorCalls" xml:space="preserve">
    <value>Les expressions d'attribut doivent être des appels aux constructeurs d'objets</value>
  </data>
  <data name="tcDelegateConstructorMustBePassed" xml:space="preserve">
    <value>Une valeur de fonction unique doit être passée à un constructeur délégué</value>
  </data>
  <data name="csIndexArgumentMismatch" xml:space="preserve">
    <value>Cet indexeur attend {0} arguments mais en reçoit ici {1}</value>
  </data>
  <data name="ifExpression" xml:space="preserve">
    <value>L'expression 'if' doit avoir le type '{0}' pour répondre aux exigences de type du contexte. Elle a le type '{1}'.</value>
  </data>
  <data name="tcAbbreviatedTypesCannotBeSealed" xml:space="preserve">
    <value>Impossible de donner aux types abrégés l'attribut 'Sealed'</value>
  </data>
  <data name="optsOptimize" xml:space="preserve">
    <value>Activer les optimisations (forme abrégée : -O)</value>
  </data>
  <data name="tcOverrideArityMismatch" xml:space="preserve">
    <value>Cette substitution n'accepte pas le même nombre d'arguments que le membre abstrait correspondant. Les membres abstraits suivants ont été trouvés : {0}</value>
  </data>
  <data name="parsUnmatchedBracket" xml:space="preserve">
    <value>'[' non apparié</value>
  </data>
  <data name="tcLiteralCannotBeInline" xml:space="preserve">
    <value>Impossible de marquer une valeur littérale 'inline'</value>
  </data>
  <data name="augNoEqualityNeedsNoComparison" xml:space="preserve">
    <value>L'attribut 'NoEquality' doit être utilisé conjointement avec l'attribut 'NoComparison'</value>
  </data>
  <data name="crefQuotationsCantRequireByref" xml:space="preserve">
    <value>Les quotations ne peuvent pas contenir d'expressions qui requièrent des pointeurs byref</value>
  </data>
  <data name="tcUnexpectedSlashInType" xml:space="preserve">
    <value>/ inattendu dans le type</value>
  </data>
  <data name="tcTypesAreAlwaysSealedAssemblyCode" xml:space="preserve">
    <value>Les types de codes assembleur sont toujours sealed</value>
  </data>
  <data name="buildNoInputsSpecified" xml:space="preserve">
    <value>Absence d'entrée spécifiée</value>
  </data>
  <data name="tcNonZeroConstantCannotHaveGenericUnit" xml:space="preserve">
    <value>Les constantes différentes de zéro ne peuvent pas avoir d'unités génériques. Pour un zéro générique, écrivez 0.0&lt;_&gt;.</value>
  </data>
  <data name="parsInvalidProperty" xml:space="preserve">
    <value>Méthode getter ou setter de propriété non valide</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureDeclaresDiffer" xml:space="preserve">
    <value>Les {0} définitions pour le type '{1}' dans la signature et l'implémentation ne sont pas compatibles, car la signature déclare {2} alors que l'implémentation déclare {3}</value>
  </data>
  <data name="etIllegalCharactersInNamespaceName" xml:space="preserve">
    <value>Le caractère '{0}' n'est pas autorisé dans le nom d'espace de noms fourni '{1}'</value>
  </data>
  <data name="buildInvalidHashIDirective" xml:space="preserve">
    <value>Directive non valide. '#I \"&lt;chemin&gt;\"' attendu.</value>
  </data>
  <data name="lexOutsideThirtyTwoBitUnsigned" xml:space="preserve">
    <value>Ce nombre se trouve en dehors de la plage autorisée pour les entiers non signés 32 bits</value>
  </data>
  <data name="chkPropertySameNameMethod" xml:space="preserve">
    <value>La propriété '{0}' a le même nom qu'une méthode dans le type '{1}'.</value>
  </data>
  <data name="typeInfoEvent" xml:space="preserve">
    <value>événement</value>
  </data>
  <data name="typeInfoField" xml:space="preserve">
    <value>champ</value>
  </data>
  <data name="tastRecursiveValuesMayNotBeInConstructionOfTuple" xml:space="preserve">
    <value>Impossible de faire apparaître directement les valeurs définies de manière récursive dans le cadre de la construction d'une valeur basée sur un tuple dans une liaison récursive</value>
  </data>
  <data name="optsDCLOHtmlDoc" xml:space="preserve">
    <value>L'option de ligne de commande '{0}' est déconseillée. La génération de documents HTML fait désormais partie de F# Power Pack, via l'outil FsHtmlDoc.exe.</value>
  </data>
  <data name="tcAttributesAreNotPermittedOnLetBindings" xml:space="preserve">
    <value>Les attributs ne sont pas autorisés sur les liaisons 'let' dans les expressions</value>
  </data>
  <data name="ValueNotContainedMutabilityParameterCountsDiffer" xml:space="preserve">
    <value>Le module '{0}' contient\n    {1}    \nmais sa signature spécifie\n    {2}    \nLe nombre de paramètres de type respectifs est différent</value>
  </data>
  <data name="tcMemberIsNotSufficientlyGeneric" xml:space="preserve">
    <value>Ce membre n'est pas suffisamment générique</value>
  </data>
  <data name="keywordDescriptionTrueFalse" xml:space="preserve">
    <value>Utilisé comme littéral booléen.</value>
  </data>
  <data name="crefQuotationsCantContainDescendingForLoops" xml:space="preserve">
    <value>Les quotations ne peuvent pas contenir d'ordre décroissant pour les boucles</value>
  </data>
  <data name="optsBaseaddress" xml:space="preserve">
    <value>Adresse de base de la bibliothèque à générer</value>
  </data>
  <data name="buildProblemReadingAssembly" xml:space="preserve">
    <value>Problème lors de la lecture de l'assembly '{0}' : {1}</value>
  </data>
  <data name="etNullMember" xml:space="preserve">
    <value>Le type fourni '{0}' a retourné un membre Null</value>
  </data>
  <data name="impReferencedTypeCouldNotBeFoundInAssembly" xml:space="preserve">
    <value>Une référence au type '{0}' a été trouvée dans l'assembly '{1}', mais le type est introuvable dans cet assembly</value>
  </data>
  <data name="tcGenericParameterHasBeenConstrained" xml:space="preserve">
    <value>Un paramètre de type générique a été utilisé d'une façon qui le contraint à être toujours '{0}'</value>
  </data>
  <data name="ValueNotContainedMutabilityOverridesDiffer" xml:space="preserve">
    <value>Le module '{0}' contient\n    {1}    \nmais sa signature spécifie\n    {2}    \nL'un est marqué en tant que substitution mais pas l'autre</value>
  </data>
  <data name="tcExpressionCountMisMatch" xml:space="preserve">
    <value>{0} expressions attendues, {1} obtenue(s)</value>
  </data>
  <data name="tcDeclaredTypeParametersForExtensionDoNotMatchOriginal" xml:space="preserve">
    <value>Un ou plusieurs des paramètres de type déclarés pour cette extension de type ont une contrainte de type manquante ou incorrecte qui ne correspond pas aux contraintes de type d'origine sur '{0}'</value>
  </data>
  <data name="tcAtLeastOneOverrideIsInvalid" xml:space="preserve">
    <value>Au moins une substitution n'a pas implémenté correctement son membre abstrait correspondant</value>
  </data>
  <data name="fscAssemblyVersionAttributeIgnored" xml:space="preserve">
    <value>'AssemblyVersionAttribute' a été ignoré, car une version a été indiquée à l'aide d'une option en ligne de commande</value>
  </data>
  <data name="tcDefaultValueAttributeRequiresVal" xml:space="preserve">
    <value>L'attribut 'DefaultValue' ne peut être utilisé que sur les déclarations 'val'</value>
  </data>
  <data name="tcTypesAreAlwaysSealedStruct" xml:space="preserve">
    <value>Les types struct sont toujours sealed</value>
  </data>
  <data name="tcTypesCannotInheritFromMultipleConcreteTypes" xml:space="preserve">
    <value>Les types ne peuvent pas hériter de plusieurs types concrets</value>
  </data>
  <data name="tcUnexpectedTypeArguments" xml:space="preserve">
    <value>Arguments de type inattendus</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleMissingInterface" xml:space="preserve">
    <value>Les {0} définitions pour le type '{1}' dans la signature et l'implémentation ne sont pas compatibles, car la signature requiert que le type prenne en charge l'interface {2} mais l'interface n'a pas été implémentée</value>
  </data>
  <data name="optsHelpBannerCodeGen" xml:space="preserve">
    <value>- GÉNÉRATION DE CODE -</value>
  </data>
  <data name="tcUnexpectedConstUint16Array" xml:space="preserve">
    <value>Const_uint16array inattendu</value>
  </data>
  <data name="tcMemberUsedInInvalidWay" xml:space="preserve">
    <value>Le membre '{0}' est utilisé de manière incorrecte. Une utilisation de '{1}' a été déduite avant la définition de '{2}'. Il s'agit d'une référence anticipée non valide.</value>
  </data>
  <data name="descriptionWordIs" xml:space="preserve">
    <value>est</value>
  </data>
  <data name="tcUnsupportedAttribute" xml:space="preserve">
    <value>Impossible d'utiliser cet attribut dans cette version de F#</value>
  </data>
  <data name="tcAttributesInvalidInPatterns" xml:space="preserve">
    <value>Les attributs ne sont pas autorisés dans les modèles</value>
  </data>
  <data name="tcCannotOverrideSealedMethod" xml:space="preserve">
    <value>Impossible de remplacer le membre hérité '{0}', car il est sealed</value>
  </data>
  <data name="tcTypeHasNoNestedTypes" xml:space="preserve">
    <value>Ce type n'a aucun type imbriqué</value>
  </data>
  <data name="buildUnexpectedFileNameCharacter" xml:space="preserve">
    <value>Le nom de fichier '{0}' contient le caractère non valide '{1}'</value>
  </data>
  <data name="undefinedNameFieldConstructorOrMember" xml:space="preserve">
    <value>Le champ, le constructeur ou le membre '{0}' n'est pas défini.</value>
  </data>
  <data name="chkReflectedDefCantSplice" xml:space="preserve">
    <value>Les termes [&lt;ReflectedDefinition&gt;] ne peuvent pas contenir d'utilisations de l'opérateur d'ajout de préfixe '%'</value>
  </data>
  <data name="csTypeInstantiationLengthMismatch" xml:space="preserve">
    <value>Incompatibilité de longueur de l'instanciation de type</value>
  </data>
  <data name="parsSetterAtMostTwoArguments" xml:space="preserve">
    <value>Une propriété de méthode setter peut avoir au maximum deux groupes d'arguments</value>
  </data>
  <data name="optsNowarn" xml:space="preserve">
    <value>Désactiver des messages d'avertissement déterminés</value>
  </data>
  <data name="optsNologo" xml:space="preserve">
    <value>Supprimer le message de copyright du compilateur</value>
  </data>
  <data name="ilFieldDoesNotHaveValidOffsetForStructureLayout" xml:space="preserve">
    <value>Le type '{0}' a été marqué comme ayant une disposition Explicit, mais le champ '{1}' n'a pas été marqué avec l'attribut 'FieldOffset'</value>
  </data>
  <data name="FieldNotContainedTypesDiffer" xml:space="preserve">
    <value>Le module contient le champ\n    {0}    \nmais sa signature spécifie\n    {1}    \nLes types sont différents</value>
  </data>
  <data name="chkNoFirstClassSplicing" xml:space="preserve">
    <value>Les utilisations de première classe de l'opérateur d'ajout d'expression ne sont pas autorisées</value>
  </data>
  <data name="tcTypeCastErased" xml:space="preserve">
    <value>Ce cast d'une classe de base va effacer le type fourni '{0}' et le remplacer par le type '{1}'.</value>
  </data>
  <data name="tcMemberFoundIsNotAbstractOrVirtual" xml:space="preserve">
    <value>Le type {0} contient le membre '{1}', mais il ne s'agit pas d'une méthode virtuelle ou abstraite pouvant être substituée ou implémentée.</value>
  </data>
  <data name="tcAttribArgsDiffer" xml:space="preserve">
    <value>L'attribut '{0}' est présent dans l'implémentation et dans la signature, mais les arguments de l'attribut sont différents. Seul l'attribut de la signature sera inclus dans le code compilé.</value>
  </data>
  <data name="cannotResolveNullableOperators" xml:space="preserve">
    <value>Impossible de résoudre l'opérateur '{0}'. Essayez d'ouvrir le module 'Microsoft.FSharp.Linq.NullableOperators'.</value>
  </data>
  <data name="buildUnrecognizedOption" xml:space="preserve">
    <value>Option non reconnue : '{0}'</value>
  </data>
  <data name="typeInfoExtension" xml:space="preserve">
    <value>extension</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldInImplButNotSig" xml:space="preserve">
    <value>Les définitions de l'exception ne sont pas compatibles, car le champ '{0}' était présent dans l'implémentation mais pas dans la signature. Le module contient la définition de l'exception\n    {1}    \nmais sa signature spécifie\n\t{2}.</value>
  </data>
  <data name="csMethodFoundButIsNotStatic" xml:space="preserve">
    <value>Le type '{0}' a une méthode '{1}' (nom complet '{2}'), mais la méthode n'est pas statique</value>
  </data>
  <data name="chkErrorContainsCallToRethrow" xml:space="preserve">
    <value>Les appels à 'reraise' ne peuvent se produire directement que dans un gestionnaire de try-with</value>
  </data>
  <data name="tcTypesAreAlwaysSealedEnum" xml:space="preserve">
    <value>Les types enum sont toujours sealed</value>
  </data>
  <data name="csArgumentTypesDoNotMatch" xml:space="preserve">
    <value>Les types des arguments ne correspondent pas</value>
  </data>
  <data name="forLIsUnnecessary" xml:space="preserve">
    <value>Le 'l' ou 'L' dans ce spécificateur de format est inutile. En F#, vous pouvez utiliser %d, %x, %o ou %u à la place, qui sont surchargés pour fonctionner avec tous les types entiers de base.</value>
  </data>
  <data name="keywordDescriptionPublic" xml:space="preserve">
    <value>Autorise l'accès à un membre en dehors du type.</value>
  </data>
  <data name="csNullableTypeDoesNotHaveNull" xml:space="preserve">
    <value>Le type '{0}' n'a pas la valeur 'null' comme valeur appropriée. Pour créer une valeur null pour un type Nullable, utilisez 'System.Nullable()'.</value>
  </data>
  <data name="optRecursiveValValue" xml:space="preserve">
    <value>ValValue {0} récursive</value>
  </data>
  <data name="chkNoByrefsOfByrefs" xml:space="preserve">
    <value>Le type '{0}' est interdit, car dans byref&lt;T&gt;, T ne peut pas contenir de types byref.</value>
  </data>
  <data name="optsDefine" xml:space="preserve">
    <value>Définir les symboles de compilation conditionnelle (forme abrégée : -d)</value>
  </data>
  <data name="parsAttributesIllegalOnInherit" xml:space="preserve">
    <value>Les attributs ne sont pas autorisés dans les déclarations 'inherit'</value>
  </data>
  <data name="etPropertyCanWriteButHasNoSetter" xml:space="preserve">
    <value>La propriété '{0}' sur le type fourni '{1}' a CanWrite=true, mais aucune valeur n'a été retournée par GetSetMethod()</value>
  </data>
  <data name="ExceptionDefsNotCompatibleExceptionDeclarationsDiffer" xml:space="preserve">
    <value>Les définitions de l'exception ne sont pas compatibles, car les déclarations de l'exception sont différentes. Le module contient la définition de l'exception\n    {0}    \nmais sa signature spécifie\n\t{1}.</value>
  </data>
  <data name="buildExpectedSigdataFile" xml:space="preserve">
    <value>FSharp.Core.sigdata introuvable avec FSharp.Core. Fichier attendu dans {0}. Effectuez une mise à niveau vers une version plus récente de FSharp.Core, où ce fichier n'est plus nécessaire.</value>
  </data>
  <data name="pplexExpectedSingleLineComment" xml:space="preserve">
    <value>Commentaire sur une seule ligne ou fin de ligne attendu</value>
  </data>
  <data name="etProviderReturnedNull" xml:space="preserve">
    <value>Le fournisseur de type a retourné 'null', qui n'est pas une valeur de retour valide de '{0}'</value>
  </data>
  <data name="lexHashIfMustHaveIdent" xml:space="preserve">
    <value>La directive #if doit être immédiatement suivie d'un identificateur</value>
  </data>
  <data name="typrelNoImplementationGivenWithSuggestion" xml:space="preserve">
    <value>Aucune implémentation n'a été fournie pour '{0}'. Remarquez que tous les membres d'interface doivent être implémentés et listés sous une déclaration 'interface' appropriée, par exemple 'interface ... with member ...'.</value>
  </data>
  <data name="parsExpectedExpressionAfterLet" xml:space="preserve">
    <value>Le bloc qui suit ce '{0}' est inachevé. Chaque bloc de code est une expression et doit avoir un résultat. '{1}' ne peut pas être l'élément de code final d'un bloc. Donnez à ce bloc un résultat explicite.</value>
  </data>
  <data name="parsUnexpectedEndOfFileWhile" xml:space="preserve">
    <value>Fin d'entrée inattendue dans l'expression 'while'. 'while &lt;expr&gt; do &lt;expr&gt;' était attendu.</value>
  </data>
  <data name="tcMeasureDefinitionsCannotHaveTypeParameters" xml:space="preserve">
    <value>Les déclarations de mesure ne peuvent pas avoir de paramètres de type</value>
  </data>
  <data name="buildDifferentVersionMustRecompile" xml:space="preserve">
    <value>La DLL compilée F# '{0}' doit être recompilée pour pouvoir être utilisée avec cette version de F#</value>
  </data>
  <data name="parsUnexpectedEndOfFileMatch" xml:space="preserve">
    <value>Fin d'entrée inattendue dans l'expression 'match'. 'match &lt;expr&gt; with | &lt;pat&gt; -&gt; &lt;expr&gt; | &lt;pat&gt; -&gt; &lt;expr&gt;…' était attendu.</value>
  </data>
  <data name="tcInterfaceTypesAndDelegatesCannotContainFields" xml:space="preserve">
    <value>Les types interface et les types délégués ne peuvent pas contenir de champs</value>
  </data>
  <data name="buildCompilingExtensionIsForML" xml:space="preserve">
    <value>Les extensions de fichiers '.ml' et '.mli' sont utilisées pour la compatibilité ML</value>
  </data>
  <data name="typeInfoNamespace" xml:space="preserve">
    <value>espace de noms</value>
  </data>
  <data name="csMemberSignatureMismatch" xml:space="preserve">
    <value>Le membre ou le constructeur d'objet '{0}' requiert {1} argument(s). La signature requise est '{2}'.</value>
  </data>
  <data name="tcMeasureDeclarationsRequireStaticMembersNotConstructors" xml:space="preserve">
    <value>Les déclarations de mesure ne peuvent avoir que des membres statiques : les constructeurs ne sont pas disponibles</value>
  </data>
  <data name="tcStaticInitializersIllegalInInterface" xml:space="preserve">
    <value>Les interfaces ne peuvent pas contenir de définitions d'initialiseurs statiques</value>
  </data>
  <data name="crefNoInnerGenericsInQuotations" xml:space="preserve">
    <value>Les fonctions génériques internes ne sont pas autorisées dans les expressions quotées. Ajoutez des contraintes de type jusqu'à ce que cette fonction ne soit plus générique.</value>
  </data>
  <data name="optsUnknownArgumentToTheTestSwitch" xml:space="preserve">
    <value>Inconnu --argument de test : '{0}'</value>
  </data>
  <data name="csTypeInferenceMaxDepth" xml:space="preserve">
    <value>Problème d'inférence de type trop complexe (profondeur d'itération maximale atteinte). Ajoutez d'autres annotations de type.</value>
  </data>
  <data name="undefinedNameValueNamespaceTypeOrModule" xml:space="preserve">
    <value>La valeur, l'espace de noms, le type ou le module '{0}' n'est pas défini.</value>
  </data>
  <data name="ModuleContainsConstructorButDataFieldsDiffer" xml:space="preserve">
    <value>Le module contient le constructeur\n    {0}    \nmais sa signature spécifie\n    {1}    \nLe nombre de champs de données respectifs est différent</value>
  </data>
  <data name="tcStructsMayNotContainDoBindings" xml:space="preserve">
    <value>Les structs ne peuvent pas contenir de liaisons 'do', car le constructeur par défaut des structs n'exécute pas ces liaisons</value>
  </data>
  <data name="keywordDescriptionUpcast" xml:space="preserve">
    <value>Permet de convertir en un type supérieur dans la chaîne d'héritage.</value>
  </data>
  <data name="customOperationTextLikeGroupJoin" xml:space="preserve">
    <value>{0} var in collection {1} (outerKey = innerKey) dans le groupe. Notez que les parenthèses sont obligatoires après '{2}'</value>
  </data>
  <data name="tcDefaultStructConstructorCall" xml:space="preserve">
    <value>Le constructeur d'initialisation à zéro par défaut d'un type struct ne peut être utilisé que si tous les champs du type struct admettent l'initialisation par défaut</value>
  </data>
  <data name="tcGenericTypesCannotHaveStructLayout" xml:space="preserve">
    <value>Impossible de donner aux types génériques l'attribut 'StructLayout'</value>
  </data>
  <data name="tcExplicitObjectConstructorSyntax" xml:space="preserve">
    <value>Un constructeur d'objet explicite doit utiliser la syntaxe 'new(args) = expr'</value>
  </data>
  <data name="keywordDescriptionUntypedQuotation" xml:space="preserve">
    <value>Délimite une quotation de code non typé.</value>
  </data>
  <data name="tcStructsMayNotContainLetBindings" xml:space="preserve">
    <value>Les structs ne peuvent pas contenir de définitions de valeur, car le constructeur par défaut des structs n'exécute pas ces liaisons. Ajoutez des arguments supplémentaires au constructeur principal du type.</value>
  </data>
  <data name="lexOutsideEightBitSigned" xml:space="preserve">
    <value>Ce nombre se trouve en dehors de la plage autorisée pour les entiers signés 8 bits</value>
  </data>
  <data name="etUnsupportedMemberKind" xml:space="preserve">
    <value>Membre non valide '{0}' sur le type fourni '{1}'. Seuls les propriétés, les méthodes et les constructeurs sont autorisés</value>
  </data>
  <data name="tcFieldRequiresAssignment" xml:space="preserve">
    <value>Aucune assignation spécifiée pour le champ '{0}' de type '{1}'</value>
  </data>
  <data name="csTypeDoesNotSupportOperator" xml:space="preserve">
    <value>Le type '{0}' ne prend pas en charge l'opérateur '{1}'</value>
  </data>
  <data name="chkNoAddressStaticFieldAtThisPoint" xml:space="preserve">
    <value>Impossible d'utiliser l'adresse du champ statique '{0}' actuellement</value>
  </data>
  <data name="tcOpenUsedWithPartiallyQualifiedPath" xml:space="preserve">
    <value>Cette déclaration ouvre l'espace de noms ou le module '{0}' via un chemin d'accès partiellement qualifié. Modifiez ce code pour utiliser le chemin d'accès complet de l'espace de noms. Cette modification garantit la fiabilité de votre code au fur et à mesure de l'ajout de nouvelles constructions aux bibliothèques F# et CLI.</value>
  </data>
  <data name="tcDoBangIllegalInSequenceExpression" xml:space="preserve">
    <value>Impossible d'utiliser 'do!' dans des expressions de séquence</value>
  </data>
  <data name="buildImplementationAlreadyGivenDetail" xml:space="preserve">
    <value>Une implémentation du fichier ou du module '{0}' a déjà été fournie. L'ordre de compilation est significatif en F# en raison de l'inférence de type. Vous pouvez modifier l'ordre de vos fichiers pour placer le fichier de signature avant l'implémentation. Dans Visual Studio, les fichiers font l'objet d'une vérification de type dans l'ordre où ils apparaissent dans le fichier projet, lequel peut être modifié manuellement ou à l'aide de l'Explorateur de solutions.</value>
  </data>
  <data name="invalidNamespaceForProvidedType" xml:space="preserve">
    <value>espace de noms non valide pour le type fourni</value>
  </data>
  <data name="tcTypeDefinitionIsCyclicThroughInheritance" xml:space="preserve">
    <value>Cette définition de type implique une référence cyclique immédiate via un champ struct ou une relation d'héritage</value>
  </data>
  <data name="tcNonLiteralCannotBeUsedInPattern" xml:space="preserve">
    <value>Cette valeur n'est pas un littéral. Impossible de l'utiliser dans un modèle</value>
  </data>
  <data name="tcStructsMustDeclareTypesOfImplicitCtorArgsExplicitly" xml:space="preserve">
    <value>Chaque argument du constructeur principal d'un struct doit recevoir un type, par exemple 'type S(x1:int, x2: int) = ...'. Ces arguments déterminent les champs du struct.</value>
  </data>
  <data name="tcMutableValuesMayNotHaveGenericParameters" xml:space="preserve">
    <value>Les valeurs mutables ne peuvent pas avoir de paramètres génériques</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInDelegate" xml:space="preserve">
    <value>Impossible de résoudre l'ambigüité liée à l'utilisation d'une construction générique avec une contrainte 'delegate' à cette position ou à proximité</value>
  </data>
  <data name="tcInvalidDelegateSpecification" xml:space="preserve">
    <value>Les spécifications des délégués doivent être sous la forme 'typ -&gt; typ'</value>
  </data>
  <data name="chkNoReflectedDefinitionOnStructMember" xml:space="preserve">
    <value>ReflectedDefinitionAttribute ne peut pas être appliqué à un membre d'instance sur un type struct, car le membre d'instance utilise un paramètre byref 'this' implicite</value>
  </data>
  <data name="parsGetAndOrSetRequired" xml:space="preserve">
    <value>'get' et/ou 'set' requis</value>
  </data>
  <data name="forDoesNotSupportPrefixFlag" xml:space="preserve">
    <value>'{0}' ne prend pas en charge l'indicateur de préfixe '{1}'</value>
  </data>
  <data name="tcTypeParameterHasBeenConstrained" xml:space="preserve">
    <value>Ce paramètre de type a été utilisé d'une façon qui le contraint à être toujours '{0}'</value>
  </data>
  <data name="tcNamedArgumentsCannotBeUsedInMemberTraits" xml:space="preserve">
    <value>Impossible de fournir des arguments nommés aux appels de membres de trait</value>
  </data>
  <data name="toolLocationHelperUnsupportedFrameworkVersion" xml:space="preserve">
    <value>La version spécifiée du .NET Framework ('{0}') n'est pas prise en charge. Spécifiez une valeur issue de l'énumération Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</value>
  </data>
  <data name="tcLiteralAttributeRequiresConstantValue" xml:space="preserve">
    <value>Une déclaration ne peut être que l'attribut [&lt;Literal&gt;] si une valeur de constante est également fournie, par exemple 'val x : int = 1'</value>
  </data>
  <data name="buildInvalidSourceFileExtension" xml:space="preserve">
    <value>L'extension de fichier de '{0}' n'est pas reconnue. Les fichiers sources doivent avoir l'extension .fs, .fsi, .fsx, .fsscript, .ml ou .mli.</value>
  </data>
  <data name="tcInheritDeclarationMissingArguments" xml:space="preserve">
    <value>Cette déclaration 'inherit' spécifie le type hérité mais aucun argument. Fournissez des arguments, par exemple 'inherit BaseType(args)'.</value>
  </data>
  <data name="optsPdb" xml:space="preserve">
    <value>Nommer le fichier de débogage de sortie</value>
  </data>
  <data name="optsLib" xml:space="preserve">
    <value>Spécifier un répertoire pour le chemin d'accès Include utilisé pour résoudre les fichiers sources et les assemblys (forme abrégée : -I)</value>
  </data>
  <data name="optsSig" xml:space="preserve">
    <value>Imprimer l'interface déduite de l'assembly dans un fichier</value>
  </data>
  <data name="optsBuildModule" xml:space="preserve">
    <value>Générer un module qui peut être ajouté à un autre assembly</value>
  </data>
  <data name="parsActivePatternCaseContainsPipe" xml:space="preserve">
    <value>Le caractère '|' n'est pas autorisé dans des identificateurs de cas de modèle actif</value>
  </data>
  <data name="parsAccessibilityModsIllegalForAbstract" xml:space="preserve">
    <value>Les modificateurs d'accessibilité ne sont pas autorisés sur ce membre. Les emplacements abstraits ont toujours la même visibilité que le type englobant.</value>
  </data>
  <data name="commaInsteadOfSemicolonInRecord" xml:space="preserve">
    <value>Un ';' sert à séparer les valeurs de champs des enregistrements. Remplacez ',' par ';'.</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInOverloadedOperator" xml:space="preserve">
    <value>Impossible de résoudre l'ambigüité inhérente à l'utilisation de l'opérateur '{0}' à cet emplacement du programme ou à proximité. Utilisez des annotations de type pour résoudre l'ambigüité.</value>
  </data>
  <data name="undefinedNameType" xml:space="preserve">
    <value>Le type '{0}' n'est pas défini.</value>
  </data>
  <data name="keywordDescriptionInline" xml:space="preserve">
    <value>Permet d'indiquer une fonction qui doit être intégrée directement dans le code de l'appelant.</value>
  </data>
  <data name="tcNotValidEnumCaseName" xml:space="preserve">
    <value>Nom non valide pour un cas d'énumération</value>
  </data>
  <data name="tcInstanceMemberRequiresTarget" xml:space="preserve">
    <value>Ce membre d'instance nécessite un paramètre pour représenter l'objet appelé. Rendez le membre statique ou utilisez la notation 'member x.Member(args) = ...'.</value>
  </data>
  <data name="etNoStaticParameterWithName" xml:space="preserve">
    <value>Il n'existe aucun paramètre statique nommé '{0}'</value>
  </data>
  <data name="augNoEqNeedsNoObjEquals" xml:space="preserve">
    <value>Un type avec l'attribut 'NoEquality' ne doit généralement pas avoir une implémentation explicite de 'Object.Equals(obj)'. Désactivez cet avertissement s'il résulte d'une action intentionnelle à des fins d'interopérabilité</value>
  </data>
  <data name="tastValueHasBeenCopied" xml:space="preserve">
    <value>La valeur a été copiée pour garantir que la valeur d'origine n'est pas mutée par cette opération</value>
  </data>
  <data name="tcConstrainedTypeVariableCannotBeGeneralized" xml:space="preserve">
    <value>Impossible de généraliser une ou plusieurs variables de type classe ou fonction explicite pour cette liaison, car elles sont contraintes par d'autres types</value>
  </data>
  <data name="csCandidates" xml:space="preserve">
    <value>Candidats : {0}</value>
  </data>
  <data name="parsUnmatchedWith" xml:space="preserve">
    <value>'with' non apparié ou format incorrect du bloc 'with'</value>
  </data>
  <data name="listElementHasWrongType" xml:space="preserve">
    <value>Tous les éléments d'une expression comportant un constructeur de liste doivent avoir le même type. Cette expression était censée avoir le type '{0}', mais elle a ici le type '{1}'.</value>
  </data>
  <data name="tcExplicitTypeSpecificationCannotBeUsedForExceptionConstructors" xml:space="preserve">
    <value>Impossible d'utiliser des spécifications de type explicite pour des constructeurs d'exception</value>
  </data>
  <data name="nrRecordTypeNeedsQualifiedAccess" xml:space="preserve">
    <value>Le type d'enregistrement du champ d'enregistrement '{0}' a été défini avec RequireQualifiedAccessAttribute. Incluez le nom du type d'enregistrement ('{1}') dans le nom que vous utilisez.</value>
  </data>
  <data name="tcFormalArgumentIsNotOptional" xml:space="preserve">
    <value>L'argument formel correspondant n'est pas facultatif</value>
  </data>
  <data name="typrelInvalidValue" xml:space="preserve">
    <value>Valeur non valide</value>
  </data>
  <data name="ArgumentsInSigAndImplMismatch" xml:space="preserve">
    <value>Les noms d'arguments dans la signature '{0}' et l'implémentation '{1}' ne correspondent pas. Le nom d'argument du fichier de signature va être utilisé. Cela peut entraîner des problèmes durant le débogage ou le profilage.</value>
  </data>
  <data name="chkUnusedValue" xml:space="preserve">
    <value>La valeur '{0}' est inutilisée</value>
  </data>
  <data name="buildOptionRequiresParameter" xml:space="preserve">
    <value>L'option requiert un paramètre : {0}</value>
  </data>
  <data name="tcInvalidDeclaration" xml:space="preserve">
    <value>Déclaration non valide</value>
  </data>
  <data name="lexOutsideNativeUnsigned" xml:space="preserve">
    <value>Ce nombre se trouve en dehors de la plage autorisée pour les entiers natifs non signés</value>
  </data>
  <data name="undefinedNamePatternDiscriminator" xml:space="preserve">
    <value>Le discriminateur de modèle '{0}' n'est pas défini.</value>
  </data>
  <data name="parsUnexpectedEndOfFile" xml:space="preserve">
    <value>Fin d'entrée inattendue</value>
  </data>
  <data name="tastTwoModulesWithSameNameInAssembly" xml:space="preserve">
    <value>Deux modules nommés '{0}' sont présents dans deux parties de cet assembly</value>
  </data>
  <data name="moreThanOneInvokeMethodFound" xml:space="preserve">
    <value>Plusieurs méthodes Invoke trouvées pour le type délégué</value>
  </data>
  <data name="notAFunctionButMaybeIndexerWithName" xml:space="preserve">
    <value>Cette valeur n'est pas une fonction et ne peut pas être appliquée. Souhaitiez-vous accéder à l'indexeur via {0}.[index] ?</value>
  </data>
  <data name="tcParameterInferredByref" xml:space="preserve">
    <value>Le paramètre '{0}' a été déduit pour avoir un type byref. Les paramètres de type byref doivent avoir une annotation de type explicite, par exemple 'x1: byref&lt;int&gt;'. Lorsqu'il est utilisé, un paramètre byref est déréférencé implicitement.</value>
  </data>
  <data name="tcStaticMemberShouldNotHaveThis" xml:space="preserve">
    <value>Ce membre statique ne doit pas avoir de paramètre 'this'. Utilisez la notation 'member Member(args) = ...'.</value>
  </data>
  <data name="csGenericConstructRequiresNonAbstract" xml:space="preserve">
    <value>Une construction générique requiert que le type '{0}' soit non abstrait</value>
  </data>
  <data name="optsNoOpt" xml:space="preserve">
    <value>Inclure uniquement les informations d'optimisation essentielles à l'implémentation de constructions inline. Empêche l'incorporation (inlining) entre modules mais améliore la compatibilité binaire.</value>
  </data>
  <data name="tcRepresentationOfTypeHiddenBySignature" xml:space="preserve">
    <value>La représentation de ce type est masquée par la signature. Un attribut tel que [&lt;Sealed&gt;], [&lt;Class&gt;] ou [&lt;Interface&gt;] doit lui être fourni pour indiquer les caractéristiques du type.</value>
  </data>
  <data name="forDoesNotSupportZeroFlag" xml:space="preserve">
    <value>Le format '{0}' ne prend pas en charge l'indicateur '0'</value>
  </data>
  <data name="checkNotSufficientlyGenericBecauseOfScope" xml:space="preserve">
    <value>La variable de type {0} est sortie de sa portée à cause de l'inférence de type. Envisagez d'ajouter une déclaration de paramètre de type explicite ou d'ajuster votre code pour qu'il soit moins générique.</value>
  </data>
  <data name="optsDebug" xml:space="preserve">
    <value>Spécifiez le type de débogage : full, portable, embedded, pdbonly. ('{0}' est la valeur par défaut si aucun type de débogage n'est spécifié. Cette valeur permet d'attacher un débogueur à un programme en cours d'exécution, 'portable' est un format multiplateforme, 'embedded' est un format multiplateforme incorporé dans le fichier de sortie).</value>
  </data>
  <data name="parsOnlyHashDirectivesAllowed" xml:space="preserve">
    <value>Seules les directives du compilateur '#' peuvent être présentes avant la première déclaration 'namespace'</value>
  </data>
  <data name="optLocalValueNotFoundDuringOptimization" xml:space="preserve">
    <value>Valeur locale {0} introuvable durant l'optimisation</value>
  </data>
  <data name="etIncorrectProvidedMethod" xml:space="preserve">
    <value>Le fournisseur de type '{0}' a fourni une méthode avec un nom '{1}' et un jeton de métadonnées '{2}' qui ne figure pas parmi ses méthodes du type déclarant '{3}'</value>
  </data>
  <data name="tcOperatorIncorrectSyntax" xml:space="preserve">
    <value>Syntaxe incorrecte pour '{0}'. Utilisation : {1}.</value>
  </data>
  <data name="lexInvalidFloat" xml:space="preserve">
    <value>Nombre à virgule flottante non valide</value>
  </data>
  <data name="tcConstructorsIllegalInAugmentation" xml:space="preserve">
    <value>Les constructeurs ne sont pas autorisés en tant que membres d'extension. Ils doivent être définis dans le cadre de la définition d'origine du type</value>
  </data>
  <data name="csCtorHasNoArgumentOrReturnProperty" xml:space="preserve">
    <value>Le constructeur d'objet '{0}' n'a aucun argument ou aucune propriété de retour définissable '{1}'. {2}.</value>
  </data>
  <data name="invalidPlatformTarget" xml:space="preserve">
    <value>La plateforme 'anycpu32bitpreferred' peut uniquement être utilisée avec des cibles EXE. Vous devez utiliser 'anycpu' à la place.</value>
  </data>
  <data name="FieldNotContainedNamesDiffer" xml:space="preserve">
    <value>Le module contient le champ\n    {0}    \nmais sa signature spécifie\n    {1}    \nLes noms sont différents</value>
  </data>
  <data name="ValueNotContainedMutabilityStaticsDiffer" xml:space="preserve">
    <value>Le module '{0}' contient\n    {1}    \nmais sa signature spécifie\n    {2}    \nL'un est statique mais pas l'autre</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationIsNotSealed" xml:space="preserve">
    <value>Les {0} définitions pour le type '{1}' dans la signature et l'implémentation ne sont pas compatibles, car le type de l'implémentation n'est pas sealed alors que la signature implique le contraire. Ajoutez l'attribut [&lt;Sealed&gt;] à l'implémentation.</value>
  </data>
  <data name="tcTryIllegalInSequenceExpression" xml:space="preserve">
    <value>Impossible d'utiliser 'try'/'with' dans des expressions de séquence</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInSig" xml:space="preserve">
    <value>Les {0} définitions pour le type '{1}' dans la signature et l'implémentation ne sont pas compatibles, car le membre abstrait '{2}' était présent dans l'implémentation mais pas dans la signature</value>
  </data>
  <data name="typrelExplicitImplementationOfGetHashCode" xml:space="preserve">
    <value>Le type struct, enregistrement ou union '{0}' a une implémentation explicite de 'Object.GetHashCode'. Implémentez une substitution correspondante pour 'Object.Equals(obj)'</value>
  </data>
  <data name="keywordDescriptionMember" xml:space="preserve">
    <value>Permet de déclarer une propriété ou une méthode dans un type d'objet.</value>
  </data>
  <data name="keywordDescriptionModule" xml:space="preserve">
    <value>Permet d'associer un nom à un groupe de types, valeurs et fonctions connexes, pour le séparer de manière logique du reste du code.</value>
  </data>
  <data name="ValueNotContainedMutabilityTypesDiffer" xml:space="preserve">
    <value>Le module '{0}' contient\n    {1}    \nmais sa signature spécifie\n    {2}    \nLes types sont différents</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleParameterCountsDiffer" xml:space="preserve">
    <value>Les {0} définitions pour le type '{1}' dans la signature et l'implémentation ne sont pas compatibles, car le nombre de paramètres de type respectifs est différent</value>
  </data>
  <data name="tcDelegatesCannotBeCurried" xml:space="preserve">
    <value>Les spécifications des délégués ne doivent pas être des types curryfiés. Utilisez 'typ * ... * typ -&gt; typ' pour les délégués à arguments multiples et 'typ -&gt; (typ -&gt; typ)' pour les délégués qui retournent des valeurs de fonction.</value>
  </data>
  <data name="optValueMarkedInlineButIncomplete" xml:space="preserve">
    <value>La valeur '{0}' a été marquée comme inline mais son implémentation utilise une fonction interne ou privée qui n'est pas suffisamment accessible</value>
  </data>
  <data name="tcPropertyIsNotStatic" xml:space="preserve">
    <value>La propriété '{0}' n'est pas statique</value>
  </data>
  <data name="tcInvalidObjectSequenceOrRecordExpression" xml:space="preserve">
    <value>Expression d'objet, de séquence ou d'enregistrement non valide</value>
  </data>
  <data name="tcTypeParametersInferredAreNotStable" xml:space="preserve">
    <value>Les paramètres de type déduits pour cette valeur ne sont pas stables sous l'action de suppression des abréviations de type. Cela est dû à l'utilisation des abréviations de type qui suppriment ou réorganisent les paramètres de type, par exemple \n\ttype taggedInt&lt;'a&gt; = int or\n\ttype swap&lt;'a,'b&gt; = 'b * 'a.\nDéclarez explicitement les paramètres de type pour cette valeur, par exemple\n\tlet f&lt;'a,'b&gt; ((x,y) : swap&lt;'b,'a&gt;) : swap&lt;'a,'b&gt; = (y,x).</value>
  </data>
  <data name="tcImplementsIStructuralComparableExplicitly" xml:space="preserve">
    <value>Le type struct, enregistrement ou union '{0}' implémente explicitement l'interface 'System.IStructuralComparable'. Appliquez l'attribut 'CustomComparison' au type.</value>
  </data>
  <data name="parsSyntaxError" xml:space="preserve">
    <value>Erreur de syntaxe</value>
  </data>
  <data name="tcInvalidRelationInJoin" xml:space="preserve">
    <value>Relation de jointure non valide dans '{0}'. 'expr &lt;op&gt; expr' où &lt;op&gt; est =, =?, ?= ou ?=? était attendu.</value>
  </data>
  <data name="parsFieldBinding" xml:space="preserve">
    <value>Les liaisons de champs doivent avoir la forme 'id = expr;'</value>
  </data>
  <data name="tcEventIsNotStatic" xml:space="preserve">
    <value>L'événement '{0}' n'est pas statique</value>
  </data>
  <data name="customOperationTextLikeZip" xml:space="preserve">
    <value>{0} var in collection</value>
  </data>
  <data name="keywordDescriptionYield" xml:space="preserve">
    <value>Utilisé dans une expression de séquence pour produire une valeur pour une séquence.</value>
  </data>
  <data name="tcNoTryFinallyInQuery" xml:space="preserve">
    <value>Les expressions 'try/finally' ne peuvent pas être utilisées dans les requêtes</value>
  </data>
  <data name="tcIDisposableTypeShouldUseNew" xml:space="preserve">
    <value>Il est recommandé que les objets prenant en charge l'interface IDisposable soient créés avec la syntaxe 'new Type(args)', au lieu de 'Type(args)' ou de 'Type' comme une valeur de fonction représentant le constructeur, pour indiquer que des ressources peuvent être détenues par la valeur générée</value>
  </data>
  <data name="tcLiteralCannotBeMutable" xml:space="preserve">
    <value>Impossible de marquer une valeur littérale 'mutable'</value>
  </data>
  <data name="keywordDescriptionWhile" xml:space="preserve">
    <value>Introduit une construction de boucle.</value>
  </data>
  <data name="csMethodIsNotAStaticMethod" xml:space="preserve">
    <value>{0} n'est pas une méthode statique</value>
  </data>
  <data name="parsAttributesAreNotPermittedOnInterfaceImplementations" xml:space="preserve">
    <value>Les attributs ne sont pas autorisés dans les implémentations d'interfaces</value>
  </data>
  <data name="tcExpressionRequiresSequence" xml:space="preserve">
    <value>Cette forme d'expression ne peut être utilisée que dans des expressions de séquence et de calcul</value>
  </data>
  <data name="crefQuotationsCantFetchUnionIndexes" xml:space="preserve">
    <value>Les quotations ne peuvent pas contenir d'expressions qui récupèrent des index de cas d'union</value>
  </data>
  <data name="keywordDescriptionClass" xml:space="preserve">
    <value>En syntaxe détaillée, indique le début d'une définition de classe.</value>
  </data>
  <data name="keywordDescriptionBegin" xml:space="preserve">
    <value>En syntaxe détaillée, indique le début d'un bloc de code.</value>
  </data>
  <data name="tcObjectConstructorsOnTypeParametersCannotTakeArguments" xml:space="preserve">
    <value>Impossible de fournir des arguments aux appels de constructeurs d'objets sur les paramètres de type</value>
  </data>
  <data name="keywordDescriptionMatch" xml:space="preserve">
    <value>Permet de créer une branche en comparant une valeur à un modèle.</value>
  </data>
  <data name="tcUnexpectedConditionInImportedAssembly" xml:space="preserve">
    <value>Condition inattendue dans l'assembly importé : impossible de décoder l'attribut AttributeUsage</value>
  </data>
  <data name="tcUnionCaseDoesNotTakeArguments" xml:space="preserve">
    <value>Ce cas d'union n'accepte pas d'arguments</value>
  </data>
  <data name="keywordDescriptionGlobal" xml:space="preserve">
    <value>Permet de référencer l'espace de noms .NET de niveau supérieur.</value>
  </data>
  <data name="tcRequireBuilderMethod" xml:space="preserve">
    <value>Cette construction de contrôle ne peut être utilisée que si le générateur d'expressions de calcul définit une méthode '{0}'</value>
  </data>
  <data name="tcImplicitMeasureFollowingSlash" xml:space="preserve">
    <value>Produit implicite de mesures après /</value>
  </data>
  <data name="tcTPFieldMustBeLiteral" xml:space="preserve">
    <value>Champ fourni non valide. Les champs fournis de types fournis effacés doivent être des littéraux.</value>
  </data>
  <data name="tcUnrecognizedQueryOperator" xml:space="preserve">
    <value>Cet opérateur de requête est inconnu. Les opérateurs de requête sont des identificateurs, tels que 'select', 'where', 'sortBy', 'thenBy', 'groupBy', 'groupValBy', 'join', 'groupJoin', 'sumBy' et 'averageBy', définis à l'aide de méthodes correspondantes sur le type 'QueryBuilder'.</value>
  </data>
  <data name="csNoMemberTakesTheseArguments" xml:space="preserve">
    <value>Aucun membre ou constructeur d'objet {0} nommé '{1}' n'accepte {2} arguments</value>
  </data>
  <data name="tcInvalidTypeForUnitsOfMeasure" xml:space="preserve">
    <value>Unités de mesure prises en charge uniquement pour les types float, float32, decimal et integer signés</value>
  </data>
  <data name="tcFieldIsNotStatic" xml:space="preserve">
    <value>Le champ '{0}' n'est pas statique</value>
  </data>
  <data name="parsNamespaceOrModuleNotBoth" xml:space="preserve">
    <value>Les fichiers doivent commencer par un espace de noms ou une déclaration de module, par exemple 'namespace SomeNamespace.SubNamespace' ou 'module SomeNamespace.SomeModule', mais pas les deux. Pour définir un module dans un espace de noms, utilisez 'module SomeModule = ...'</value>
  </data>
  <data name="ilSignatureForExternalFunctionContainsTypeParameters" xml:space="preserve">
    <value>La signature de cette fonction externe contient des paramètres de type. Appliquez une contrainte à l'argument et aux types de retour pour indiquer les types de la fonction C correspondante.</value>
  </data>
  <data name="followingPatternMatchClauseHasWrongType" xml:space="preserve">
    <value>Toutes les branches d'une expression comportant des critères spéciaux doivent avoir le même type. Cette expression était censée avoir le type '{0}', mais elle a ici le type '{1}'.</value>
  </data>
  <data name="typrelMethodIsSealed" xml:space="preserve">
    <value>La méthode '{0}' est sealed et ne peut pas être substituée</value>
  </data>
  <data name="parsUnmatched" xml:space="preserve">
    <value>'{0}' non apparié</value>
  </data>
  <data name="tcRequireVarConstRecogOrLiteral" xml:space="preserve">
    <value>Ceci n'est pas une variable, une constante, un module de reconnaissance actif ou un littéral</value>
  </data>
  <data name="tcUndefinedField" xml:space="preserve">
    <value>Le champ '{0}' a une valeur, mais n'est pas présent dans le type '{1}'</value>
  </data>
  <data name="crefQuotationsCantContainStaticFieldRef" xml:space="preserve">
    <value>Les quotations ne peuvent pas contenir d'expressions qui récupèrent des champs statiques</value>
  </data>
  <data name="tcStaticLetBindingsRequireClassesWithImplicitConstructors" xml:space="preserve">
    <value>Les définitions de valeur statiques peuvent uniquement être utilisées dans les types comportant un constructeur principal. Ajoutez des arguments à la définition de type, par exemple 'type X(args) = …'.</value>
  </data>
  <data name="parsAttributeOnIncompleteCode" xml:space="preserve">
    <value>La cible du code est introuvable pour cet attribut, peut-être parce que le code après l'attribut est incomplet.</value>
  </data>
  <data name="buildInvalidModuleOrNamespaceName" xml:space="preserve">
    <value>Nom de module ou d'espace de noms non valide</value>
  </data>
  <data name="typeInfoCustomOperation" xml:space="preserve">
    <value>opération personnalisée</value>
  </data>
  <data name="keywordDescriptionAssert" xml:space="preserve">
    <value>Permet de vérifier le code durant le débogage.</value>
  </data>
  <data name="buildImplicitModuleIsNotLegalIdentifier" xml:space="preserve">
    <value>Les déclarations de ce fichier vont être placées dans un module implicite '{0}' en fonction du nom de fichier '{1}'. Toutefois, il ne s'agit pas d'un identificateur F# valide ; par conséquent, le contenu ne sera pas accessible à partir des autres fichiers. Renommez le fichier ou ajoutez une déclaration 'module' ou 'namespace' en haut du fichier.</value>
  </data>
  <data name="fscKeyFileCouldNotBeOpened" xml:space="preserve">
    <value>Impossible d'ouvrir le fichier de clé '{0}'</value>
  </data>
  <data name="crefQuotationsCantContainArrayPatternMatching" xml:space="preserve">
    <value>Les quotations ne peuvent pas contenir de critères spéciaux de tableau</value>
  </data>
  <data name="tcTupleStructMismatch" xml:space="preserve">
    <value>L'un des tuples est de type struct, l'autre tuple est de type référence</value>
  </data>
  <data name="csMemberSignatureMismatch4" xml:space="preserve">
    <value>Le membre ou le constructeur d'objet '{0}' requiert {1} argument(s) supplémentaire(s). La signature requise est '{2}'. Voici certains noms des arguments manquants : {3}.</value>
  </data>
  <data name="csMemberSignatureMismatch3" xml:space="preserve">
    <value>Le membre ou le constructeur d'objet '{0}' requiert {1} argument(s). La signature requise est '{2}'. Voici certains noms des arguments manquants : {3}.</value>
  </data>
  <data name="csMemberSignatureMismatch2" xml:space="preserve">
    <value>Le membre ou le constructeur d'objet '{0}' requiert {1} argument(s) supplémentaire(s). La signature requise est '{2}'.</value>
  </data>
  <data name="parsUnmatchedLetBang" xml:space="preserve">
    <value>Définition de valeur incomplète. S'il s'agit d'une expression, le corps de l'expression doit être mis en retrait sur la même colonne que le mot-clé 'let!'.</value>
  </data>
  <data name="parsMissingTypeArgs" xml:space="preserve">
    <value>Argument de type ou argument statique attendu</value>
  </data>
  <data name="fscTwoResourceManifests" xml:space="preserve">
    <value>Options conflictuelles spécifiées : 'win32manifest' et 'win32res'. Seule l'une de ces options peut être utilisée.</value>
  </data>
  <data name="chkDuplicateProperty" xml:space="preserve">
    <value>Propriété dupliquée. La propriété '{0}' a le même nom et la même signature qu'une autre propriété dans le type '{1}'.</value>
  </data>
  <data name="optsPreferredUiLang" xml:space="preserve">
    <value>Spécifiez le nom de culture de la langue de sortie par défaut (exemple : es-ES, ja-JP)</value>
  </data>
  <data name="tcSeqResultsUseYield" xml:space="preserve">
    <value>Dans les expressions de séquence, les résultats sont générés à l'aide de 'yield'</value>
  </data>
  <data name="optsStrongKeyFile" xml:space="preserve">
    <value>Spécifier un fichier de clé de nom fort</value>
  </data>
  <data name="parsUnexpectedIdentifier" xml:space="preserve">
    <value>Identificateur inattendu : '{0}'</value>
  </data>
  <data name="lexInvalidLineNumber" xml:space="preserve">
    <value>Numéro de ligne non valide : '{0}'</value>
  </data>
  <data name="csOptionalArgumentNotPermittedHere" xml:space="preserve">
    <value>Arguments facultatifs non autorisés ici</value>
  </data>
  <data name="experimentalConstruct" xml:space="preserve">
    <value>Cette construction est expérimentale</value>
  </data>
  <data name="parsAugmentationsIllegalOnDelegateType" xml:space="preserve">
    <value>Les augmentations ne sont pas autorisées sur le type délégué moduleDefns</value>
  </data>
  <data name="buildArgInvalidInt" xml:space="preserve">
    <value>'{0}' n'est pas un argument entier valide</value>
  </data>
  <data name="buildExplicitCoreLibRequiresNoFramework" xml:space="preserve">
    <value>Lorsque mscorlib.dll ou FSharp.Core.dll est explicitement référencé, l'option {0} doit également être passée</value>
  </data>
  <data name="parsTypeAnnotationsOnGetSet" xml:space="preserve">
    <value>Les annotations de type des méthodes getter et setter d'une propriété doivent être spécifiées après 'get()' ou 'set(v)', par exemple 'with get() : string = ...'</value>
  </data>
  <data name="optsBuildWindows" xml:space="preserve">
    <value>Générer un fichier exécutable Windows</value>
  </data>
  <data name="optsNameOfOutputFile" xml:space="preserve">
    <value>Nom du fichier de sortie (forme abrégée : -o)</value>
  </data>
  <data name="optsSourceLinkRequirePortablePDBs" xml:space="preserve">
    <value>Commutateur --sourcelink uniquement pris en charge durant l'émission d'un fichier PDB portable (--debug:portable ou --debug:embedded)</value>
  </data>
  <data name="CallerMemberNameIsOverriden" xml:space="preserve">
    <value>L'attribut CallerMemberNameAttribute appliqué au paramètre '{0}' n'a aucun effet. Il est remplacé par CallerFilePathAttribute.</value>
  </data>
  <data name="etBadUnnamedStaticArgs" xml:space="preserve">
    <value>Les arguments statiques nommés doivent suivre tous les arguments statiques non nommés</value>
  </data>
  <data name="optsBuildConsole" xml:space="preserve">
    <value>Générer un fichier exécutable console</value>
  </data>
  <data name="tcAllImplementedInterfacesShouldBeDeclared" xml:space="preserve">
    <value>Toutes les interfaces implémentées doivent être déclarées dans la déclaration initiale du type</value>
  </data>
  <data name="tcUnexpectedPropertySpec" xml:space="preserve">
    <value>Spécification de propriété au niveau source inattendue</value>
  </data>
  <data name="tcCannotCallAbstractBaseMember" xml:space="preserve">
    <value>Impossible d'appeler un membre de base abstrait : '{0}'</value>
  </data>
  <data name="tcConditionalAttributeRequiresMembers" xml:space="preserve">
    <value>L'attribut 'ConditionalAttribute' ne peut être utilisé que sur des membres</value>
  </data>
  <data name="augCustomCompareNeedsIComp" xml:space="preserve">
    <value>Un type avec l'attribut 'CustomComparison' doit avoir au moins une implémentation explicite de 'System.IComparable' ou 'System.Collections.IStructuralComparable'</value>
  </data>
  <data name="ValueNotContainedMutabilityDotNetNamesDiffer" xml:space="preserve">
    <value>Le module '{0}' contient\n    {1}    \nmais sa signature spécifie\n    {2}    \nLes noms de membres CLI sont différents</value>
  </data>
  <data name="tcDefaultAmbiguous" xml:space="preserve">
    <value>La méthode implémentée par cette valeur par défaut est ambiguë</value>
  </data>
  <data name="tastopsMaxArrayThirtyTwo" xml:space="preserve">
    <value>F# prend en charge les rangs de tableau compris entre 1 et 32. La valeur {0} n'est pas autorisée.</value>
  </data>
  <data name="crefQuotationsCantContainThisType" xml:space="preserve">
    <value>Les quotations ne peuvent pas contenir ce genre de type</value>
  </data>
  <data name="assemblyResolutionNetFramework" xml:space="preserve">
    <value>.NET Framework</value>
  </data>
  <data name="tcObjectExpressionsCanOnlyOverrideAbstractOrVirtual" xml:space="preserve">
    <value>Seules les substitutions de membres abstraits et virtuels peuvent être spécifiées dans les expressions d'objet</value>
  </data>
  <data name="optsWriteXml" xml:space="preserve">
    <value>Écrire le xmldoc de l'assembly dans le fichier donné</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldIsInImplButNotSig" xml:space="preserve">
    <value>Les {0} définitions pour le type '{1}' dans la signature et l'implémentation ne sont pas compatibles, car le champ '{2}' était présent dans l'implémentation mais pas dans la signature. Les types struct doivent désormais révéler leurs champs dans la signature relative au type ; toutefois, les champs peuvent continuer à être étiquetés 'private' ou 'internal'.</value>
  </data>
  <data name="unionCaseIsNotAccessible" xml:space="preserve">
    <value>Le cas d'union '{0}' n'est pas accessible à partir de cet emplacement du code</value>
  </data>
  <data name="augOnlyCertainTypesCanHaveAttrs" xml:space="preserve">
    <value>Seuls les types enregistrement, union, exception et struct peuvent être augmentés avec les attributs 'ReferenceEquality', 'StructuralEquality' et 'StructuralComparison'</value>
  </data>
  <data name="ilSignInvalidSignatureSize" xml:space="preserve">
    <value>Taille de signature non valide</value>
  </data>
  <data name="optsWin32manifest" xml:space="preserve">
    <value>Spécifier un fichier manifeste Win32</value>
  </data>
  <data name="tcInvalidIndexerExpression" xml:space="preserve">
    <value>Expression d'indexeur non valide</value>
  </data>
  <data name="parsTypeNameCannotBeEmpty" xml:space="preserve">
    <value>Le nom de type ne peut pas être vide.</value>
  </data>
  <data name="buildCouldNotFindSourceFile" xml:space="preserve">
    <value>Le fichier source '{0}' est introuvable</value>
  </data>
  <data name="tcExpectModuleOrNamespaceParent" xml:space="preserve">
    <value>Parent de module ou d'espace de noms attendu {0}</value>
  </data>
  <data name="tcOnlySimpleBindingsCanBeUsedInConstructionExpressions" xml:space="preserve">
    <value>Seules les liaisons simples sous la forme 'id = expr' peuvent être utilisées dans les expressions de construction</value>
  </data>
  <data name="keywordDescriptionExtern" xml:space="preserve">
    <value>Indique qu'un élément de programme déclaré est défini dans une autre ressource binaire ou un autre assembly.</value>
  </data>
  <data name="optsSourceLink" xml:space="preserve">
    <value>Fichier d'informations sur le lien source à incorporer dans le fichier PDB portable</value>
  </data>
  <data name="tcNewRequiresObjectConstructor" xml:space="preserve">
    <value>'new' ne peut être utilisé qu'avec des constructeurs d'objets</value>
  </data>
  <data name="csCodeLessGeneric" xml:space="preserve">
    <value>Ce code est moins générique que ne l'indiquaient ses annotations. Une unité de mesure spécifiée à l'aide de '_' a été déterminée comme étant égale à '1', c'est-à-dire sans dimension. Rendez le code générique ou supprimez l'utilisation de '_'.</value>
  </data>
  <data name="tcIllegalStructTypeForConstantExpression" xml:space="preserve">
    <value>Cette expression littérale n'est pas valide. L'attribut [&lt;Literal&gt;] sera ignoré.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull2" xml:space="preserve">
    <value>Les {0} définitions pour le type '{1}' dans la signature et l'implémentation ne sont pas compatibles, car la signature indique que ce type peut utiliser des valeurs Null comme valeurs supplémentaires, contrairement à l'implémentation</value>
  </data>
  <data name="tcTryWithMayNotBeUsedInQueries" xml:space="preserve">
    <value>Les expressions 'try/with' ne peuvent pas être utilisées dans les requêtes</value>
  </data>
  <data name="optsStandalone" xml:space="preserve">
    <value>Lier statiquement la bibliothèque F# et toutes les DLL référencées qui en dépendent dans l'assembly en cours de génération</value>
  </data>
  <data name="tcAttributeAutoOpenWasIgnored" xml:space="preserve">
    <value>L'attribut 'AutoOpen(\"{0}\")' de l'assembly '{1}' ne faisait pas référence à un module ou un espace de noms valide dans cet assembly et a été ignoré</value>
  </data>
  <data name="tcFieldIsNotMutable" xml:space="preserve">
    <value>Ce champ n'est pas mutable</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypeIsDifferentKind" xml:space="preserve">
    <value>Les {0} définitions pour le type '{1}' dans la signature et l'implémentation ne sont pas compatibles, car les types sont de différents genres</value>
  </data>
  <data name="tcEnumerationsCannotHaveInterfaceDeclaration" xml:space="preserve">
    <value>Les énumérations ne peuvent pas avoir de déclarations d'interface</value>
  </data>
  <data name="optsBuildLibrary" xml:space="preserve">
    <value>Générer une bibliothèque (forme abrégée : -a)</value>
  </data>
  <data name="buildCouldNotResolveAssembly" xml:space="preserve">
    <value>Impossible de résoudre l'assembly '{0}'</value>
  </data>
  <data name="csMemberNotAccessible" xml:space="preserve">
    <value>Le constructeur de membre ou d'objet '{0}' acceptant {1} arguments n'est pas accessible à partir de cet emplacement du code. Toutes les versions accessibles de la méthode '{2}' acceptent {3} arguments.</value>
  </data>
  <data name="optsShortFormOf" xml:space="preserve">
    <value>Forme abrégée de '{0}'</value>
  </data>
  <data name="tcDefaultImplementationForInterfaceHasAlreadyBeenAdded" xml:space="preserve">
    <value>Une implémentation par défaut de cette interface a déjà été ajoutée, car l'implémentation explicite de l'interface n'a pas été spécifiée lors de la définition du type</value>
  </data>
  <data name="tcFieldNameIsUsedModeThanOnce" xml:space="preserve">
    <value>Le champ nommé '{0}' est utilisé plusieurs fois.</value>
  </data>
  <data name="fscDeterministicDebugRequiresPortablePdb" xml:space="preserve">
    <value>Les builds déterministes ne prennent en charge que les fichiers PDB portables (--debug:portable ou --debug:embedded)</value>
  </data>
  <data name="tcInvalidObjectExpressionSyntaxForm" xml:space="preserve">
    <value>Expression d'objet non valide. Les objets sans substitutions ou interfaces doivent utiliser la forme d'expression 'new Type(args)' sans accolades.</value>
  </data>
  <data name="typeInfoFromFirst" xml:space="preserve">
    <value>de {0}</value>
  </data>
  <data name="keywordDescriptionDownto" xml:space="preserve">
    <value>Dans une expression for, permet de compter en sens inverse.</value>
  </data>
  <data name="tcTypeIsNotARecordType" xml:space="preserve">
    <value>Ce type n'est pas un type enregistrement</value>
  </data>
  <data name="crefQuotationsCantContainAddressOf" xml:space="preserve">
    <value>Les quotations ne peuvent pas contenir d'expressions qui acceptent l'adresse d'un champ</value>
  </data>
  <data name="tcImplementsIComparableExplicitly" xml:space="preserve">
    <value>Le type struct, enregistrement ou union '{0}' implémente explicitement l'interface 'System.IComparable'. Vous devez appliquer l'attribut 'CustomComparison' au type.</value>
  </data>
  <data name="tcIfThenElseMayNotBeUsedWithinQueries" xml:space="preserve">
    <value>Les expressions if/then/else ne peuvent pas être utilisées au sein des requêtes. Utilisez soit une expression if/then, soit une expression de séquence.</value>
  </data>
  <data name="etStaticParameterAlreadyHasValue" xml:space="preserve">
    <value>Une valeur a déjà été attribuée au paramètre statique '{0}'</value>
  </data>
  <data name="optsEmbedSource" xml:space="preserve">
    <value>Incorporer des fichiers sources spécifiques dans le fichier PDB portable</value>
  </data>
  <data name="chkByrefUsedInInvalidWay" xml:space="preserve">
    <value>La variable typée byref '{0}' est utilisée de manière incorrecte. Impossible de capturer les types byref par des fermetures ou de les passer à des fonctions internes.</value>
  </data>
  <data name="tcPropertyCannotBeSet1" xml:space="preserve">
    <value>Impossible de définir la propriété '{0}'</value>
  </data>
  <data name="tcPropertyCannotBeSet0" xml:space="preserve">
    <value>Impossible de définir cette propriété</value>
  </data>
  <data name="chkNoFirstClassAddressOf" xml:space="preserve">
    <value>Les utilisations de première classe d'opérateurs d'adresses ne sont pas autorisées</value>
  </data>
  <data name="ValueNotContainedMutabilityOneIsConstructor" xml:space="preserve">
    <value>Le module '{0}' contient\n    {1}    \nmais sa signature spécifie\n    {2}    \nL'un est un constructeur/une propriété mais pas l'autre</value>
  </data>
  <data name="tcObjectConstructionCanOnlyBeUsedInClassTypes" xml:space="preserve">
    <value>Les expressions de construction d'objet ne peuvent être utilisées que pour implémenter des constructeurs dans les types classe</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldInSigButNotImpl" xml:space="preserve">
    <value>Les définitions de l'exception ne sont pas compatibles, car le champ '{0}' était requis par la signature mais n'était pas spécifiée par l'implémentation. Le module contient la définition de l'exception\n    {1}    \nmais sa signature spécifie\n\t{2}.</value>
  </data>
  <data name="tcNumericLiteralRequiresModule" xml:space="preserve">
    <value>Ce littéral numérique requiert qu'un module '{0}' définissant les fonctions FromZero, FromOne, FromInt32, FromInt64 et FromString se trouve dans la portée</value>
  </data>
  <data name="tcConstructorsIllegalForThisType" xml:space="preserve">
    <value>Impossible de définir des constructeurs pour ce type</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldRequiredButNotSpecified" xml:space="preserve">
    <value>Les {0} définitions pour le type '{1}' dans la signature et l'implémentation ne sont pas compatibles, car le champ {2} a été demandé par la signature mais n'a pas été spécifié par l'implémentation</value>
  </data>
  <data name="tcOptionalArgsOnlyOnMembers" xml:space="preserve">
    <value>Les arguments facultatifs ne sont autorisés que sur les membres de type</value>
  </data>
  <data name="etProvidedTypeReferenceMissingArgument" xml:space="preserve">
    <value>Il manque une valeur pour le paramètre statique '{0}' dans une référence à un type fourni. Vous devrez peut-être recompiler un ou plusieurs assemblys référencés.</value>
  </data>
  <data name="elseBranchHasWrongType" xml:space="preserve">
    <value>Toutes les branches d'une expression 'if' doivent avoir le même type. Cette expression était censée avoir le type '{0}', mais elle a ici le type '{1}'.</value>
  </data>
  <data name="erasedTo" xml:space="preserve">
    <value>Effacé de</value>
  </data>
  <data name="tcTypeParameterArityMismatch" xml:space="preserve">
    <value>Cette valeur, ce type ou cette méthode attend {0} paramètre(s) de type mais en a reçu {1}</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldOrderDiffers" xml:space="preserve">
    <value>Les définitions de l'exception ne sont pas compatibles, car l'ordre des champs est différent entre la signature et l'implémentation. Le module contient la définition de l'exception\n    {0}    \nmais sa signature spécifie\n\t{1}.</value>
  </data>
  <data name="tcCustomOperationMayNotBeUsedInConjunctionWithNonSimpleLetBindings" xml:space="preserve">
    <value>Une opération personnalisée ne peut pas être utilisée en association avec une liaison sans valeur ou 'let' récursive dans une autre partie de cette expression de calcul</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectNumberOfTypeParameters" xml:space="preserve">
    <value>Le membre '{0}' n'a pas le nombre approprié de paramètres de type de méthode. La signature requise est '{1}'.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleDotNetTypeRepresentationIsHidden" xml:space="preserve">
    <value>Les {0} définitions pour le type '{1}' dans la signature et l'implémentation ne sont pas compatibles, car une représentation de type CLI est masquée par une signature</value>
  </data>
  <data name="tcStructuralComparisonNotSatisfied1" xml:space="preserve">
    <value>Le type struct, enregistrement ou union '{0}' a l'attribut 'StructuralComparison' mais le paramètre de type '{1}' ne satisfait pas la contrainte 'comparison'. Ajoutez la contrainte 'comparison' au paramètre de type</value>
  </data>
  <data name="tcStructuralComparisonNotSatisfied2" xml:space="preserve">
    <value>Le type struct, enregistrement ou union '{0}' a l'attribut 'StructuralComparison' mais le type de composant '{1}' ne satisfait pas la contrainte 'comparison'</value>
  </data>
  <data name="chkNoAddressOfAtThisPoint" xml:space="preserve">
    <value>Impossible d'utiliser l'adresse de la variable '{0}' actuellement</value>
  </data>
  <data name="typeInfoUnionCase" xml:space="preserve">
    <value>cas d'union</value>
  </data>
  <data name="assemblyResolutionGAC" xml:space="preserve">
    <value>Global Assembly Cache</value>
  </data>
  <data name="typrelDuplicateInterface" xml:space="preserve">
    <value>Interface dupliquée ou redondante</value>
  </data>
  <data name="optsInvalidResponseFile" xml:space="preserve">
    <value>Fichier réponse non valide '{0}' ('{1}')</value>
  </data>
  <data name="tcInvalidUseBangBinding" xml:space="preserve">
    <value>Les liaisons 'use!' doivent respecter le format 'use! &lt;var&gt; = &lt;expr&gt;'</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypeIsHidden" xml:space="preserve">
    <value>Les {0} définitions pour le type '{1}' dans la signature et l'implémentation ne sont pas compatibles, car une représentation de type est masquée par une signature</value>
  </data>
  <data name="tcInvalidSequenceExpressionSyntaxForm" xml:space="preserve">
    <value>Expression d'enregistrement, de séquence ou de calcul non valide. Les expressions de séquence doivent avoir le format 'seq {{ ... }}'</value>
  </data>
  <data name="etEventNoAdd" xml:space="preserve">
    <value>L'événement '{0}' sur le type fourni '{1}' n'a pas de valeur de GetAddMethod()</value>
  </data>
  <data name="keywordDescriptionInterface" xml:space="preserve">
    <value>Permet de déclarer et d'implémenter des interfaces.</value>
  </data>
  <data name="ValueNotContainedMutabilityExtensionsDiffer" xml:space="preserve">
    <value>Le module '{0}' contient\n    {1}    \nmais sa signature spécifie\n    {2}    \nL'un est un membre d'extension mais pas l'autre</value>
  </data>
  <data name="parsSetSyntax" xml:space="preserve">
    <value>Les méthodes setter d'une propriété doivent être définies via 'set value = ', 'set idx value = ' ou 'set (idx1,...,idxN) value = ... '</value>
  </data>
  <data name="tcInvalidArgForParameterizedPattern" xml:space="preserve">
    <value>Argument non valide pour l'étiquette de modèle paramétrable</value>
  </data>
  <data name="ilSignInvalidBitLen" xml:space="preserve">
    <value>Longueur de bit non valide</value>
  </data>
  <data name="lexHashIfMustBeFirst" xml:space="preserve">
    <value>La directive #if doit être le premier caractère (autre qu'un espace blanc) d'une ligne</value>
  </data>
  <data name="etMultipleStaticParameterWithName" xml:space="preserve">
    <value>Il existe plusieurs paramètres statiques nommés '{0}'</value>
  </data>
  <data name="tcVolatileFieldsMustBeMutable" xml:space="preserve">
    <value>Les champs volatiles doivent être marqués comme 'mutable' et ne peuvent pas être des champs static de thread</value>
  </data>
  <data name="tcReturnTypesForUnionMustBeSameAsType" xml:space="preserve">
    <value>Les types de retour des cas d'union doivent être identiques au type défini, jusqu'aux abréviations</value>
  </data>
  <data name="tcOverridesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Les modificateurs d'accessibilité ne sont pas autorisés pour les substitutions ou les implémentations d'interfaces</value>
  </data>
  <data name="lexIndentOffForML" xml:space="preserve">
    <value>Utilisez un fichier avec l'extension '.ml' ou '.mli' à la place</value>
  </data>
  <data name="tcAbstractPropertyMissingGetOrSet" xml:space="preserve">
    <value>Cette propriété substitue ou implémente une propriété abstraite mais cette dernière n'a pas de {0} correspondant</value>
  </data>
  <data name="ilUnexpectedUnrealizedValue" xml:space="preserve">
    <value>Erreur du compilateur : valeur non réalisée inattendue</value>
  </data>
  <data name="etProvidedTypeReferenceInvalidText" xml:space="preserve">
    <value>Une référence à un type fourni a une valeur non valide '{0}' pour un paramètre statique. Vous devrez peut-être recompiler un ou plusieurs assemblys référencés.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleSignaturesDiffer" xml:space="preserve">
    <value>Les définitions de l'exception ne sont pas compatibles, car les abréviations de l'exception sont différentes entre la signature et l'implémentation. Le module contient la définition de l'exception\n    {0}    \nmais sa signature spécifie\n\t{1}.</value>
  </data>
  <data name="chkInvalidCustAttrVal" xml:space="preserve">
    <value>Valeur d'attribut personnalisé non valide (n'est pas une constante ou un littéral)</value>
  </data>
  <data name="tcExceptionAbbreviationsShouldNotHaveArgumentList" xml:space="preserve">
    <value>Les abréviations d'exceptions ne doivent pas avoir de listes d'arguments</value>
  </data>
  <data name="tcInvalidPropertyType" xml:space="preserve">
    <value>Cette propriété a un type non valide. Les propriétés qui acceptent plusieurs arguments d'indexeur doivent avoir des types sous la forme 'ty1 * ty2 -&gt; ty3'. Les propriétés qui retournent des fonctions doivent avoir des types sous la forme '(ty1 -&gt; ty2)'.</value>
  </data>
  <data name="chkNoByrefAsTopValue" xml:space="preserve">
    <value>Une valeur typée byref doit être stockée ici. Les valeurs byref liées à let de niveau supérieur ne sont pas autorisées.</value>
  </data>
  <data name="tcMultipleVisibilityAttributesWithLet" xml:space="preserve">
    <value>Plusieurs attributs de visibilité ont été spécifiés pour cet identificateur. Les liaisons 'let' dans les classes sont toujours privées, à l'instar des liaisons 'let' dans les expressions.</value>
  </data>
  <data name="crefQuotationsCantContainGenericFunctions" xml:space="preserve">
    <value>Les citations ne peuvent pas contenir de définitions de fonction déduites ou déclarées comme étant génériques. Ajoutez des contraintes de type pour rendre cette expression citée valide.</value>
  </data>
  <data name="forBadPrecision" xml:space="preserve">
    <value>Précision incorrecte du spécificateur de format</value>
  </data>
  <data name="tcTypeHasNoAccessibleConstructor" xml:space="preserve">
    <value>Ce type n'a aucun constructeur d'objet accessible</value>
  </data>
  <data name="etEmptyNamespaceOfTypeNotAllowed" xml:space="preserve">
    <value>Le type '{0}' du fournisseur de type '{1}' a un espace de noms vide. Utilisez 'null' pour l'espace de noms global.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull2" xml:space="preserve">
    <value>Les {0} définitions pour le type '{1}' dans la signature et l'implémentation ne sont pas compatibles, car l'implémentation indique que ce type peut utiliser des valeurs Null comme valeurs supplémentaires, contrairement à la signature</value>
  </data>
  <data name="tcConstructorRequiresArguments" xml:space="preserve">
    <value>Ce constructeur d'objet requiert des arguments</value>
  </data>
  <data name="parsVisibilityIllegalOnInherit" xml:space="preserve">
    <value>Les modificateurs d'accessibilité ne sont pas autorisés sur une déclaration 'inherits'</value>
  </data>
  <data name="tcTypeRequiresDefinition" xml:space="preserve">
    <value>Ce type requiert une définition</value>
  </data>
  <data name="ilLiteralFieldsCannotBeSet" xml:space="preserve">
    <value>Impossible de définir les champs littéral</value>
  </data>
  <data name="keywordDescriptionTo" xml:space="preserve">
    <value>Utilisé dans les boucles for pour indiquer une portée.</value>
  </data>
  <data name="keywordDescriptionOr" xml:space="preserve">
    <value>Utilisé avec les conditions booléennes en tant qu'opérateur or booléen. Équivaut à ||. Utilisé également dans les contraintes de membre.</value>
  </data>
  <data name="keywordDescriptionOf" xml:space="preserve">
    <value>Utilisé dans les unions discriminées pour indiquer le type des catégories de valeurs, ainsi que dans les déclarations de délégué et d'exception.</value>
  </data>
  <data name="keywordDescriptionIf" xml:space="preserve">
    <value>Utilisé dans les constructions de création de branche conditionnelle.</value>
  </data>
  <data name="keywordDescriptionIn" xml:space="preserve">
    <value>Utilisé pour les expressions de séquence et, en syntaxe détaillée, pour séparer les expressions des liaisons.</value>
  </data>
  <data name="keywordDescriptionAs" xml:space="preserve">
    <value>Permet de donner un nom d'objet à l'objet de classe actuel. Permet également de nommer un modèle complet dans un critère spécial.</value>
  </data>
  <data name="keywordDescriptionDo" xml:space="preserve">
    <value>Utilisé dans les constructions de boucles ou pour exécuter du code impératif.</value>
  </data>
  <data name="ValueNotContainedMutabilityAttributesDiffer" xml:space="preserve">
    <value>Le module '{0}' contient\n    {1}    \nmais sa signature spécifie\n    {2}    \nLes attributs de mutabilité sont différents</value>
  </data>
  <data name="tcAbbreviationsFordotNetExceptionsMustHaveMatchingObjectConstructor" xml:space="preserve">
    <value>Les abréviations des types d'exceptions CIL (Common Intermediate Language) doivent avoir un constructeur d'objet correspondant</value>
  </data>
  <data name="lexInvalidNumericLiteral" xml:space="preserve">
    <value>Littéral numérique non valide. Littéraux numériques valides : 1, 0x1, 0b0001 (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).</value>
  </data>
  <data name="augCustomEqNeedsNoCompOrCustomComp" xml:space="preserve">
    <value>L'attribut 'CustomEquality' doit être utilisé conjointement avec les attributs 'NoComparison' ou 'CustomComparison'</value>
  </data>
  <data name="parsGetterAtMostOneArgument" xml:space="preserve">
    <value>Une propriété de méthode getter peut avoir au maximum un groupe d'arguments</value>
  </data>
  <data name="tcThisValueMayNotBeInlined" xml:space="preserve">
    <value>Cette déclaration de membre, de fonction ou de valeur ne peut pas être déclarée comme étant 'inline'</value>
  </data>
  <data name="parsInvalidPrefixOperator" xml:space="preserve">
    <value>Opérateur de préfixe non valide</value>
  </data>
  <data name="parsUnexpectedSemicolon" xml:space="preserve">
    <value>Point-virgule inattendu à cet emplacement</value>
  </data>
  <data name="tcCustomOperationNotUsedCorrectly2" xml:space="preserve">
    <value>'{0}' n'est pas utilisé correctement. Utilisation : {1}. Il s'agit d'une opération personnalisée dans cette requête ou expression de calcul.</value>
  </data>
  <data name="typrelOverrideWasAmbiguous" xml:space="preserve">
    <value>La substitution pour '{0}' était ambigüe</value>
  </data>
  <data name="optsStrongKeyContainer" xml:space="preserve">
    <value>Spécifier un conteneur de clé de nom fort</value>
  </data>
  <data name="tcObjectOfIndeterminateTypeUsedRequireTypeConstraint" xml:space="preserve">
    <value>L'opérateur 'expr.[idx]' a été utilisé sur un objet de type indéterminé basé sur des informations situées avant ce point du programme. Ajoutez des contraintes de type supplémentaires</value>
  </data>
  <data name="optsHelpBannerErrsAndWarns" xml:space="preserve">
    <value>- ERREURS ET AVERTISSEMENTS -</value>
  </data>
  <data name="optsSimpleresolution" xml:space="preserve">
    <value>Résoudre les références d'assembly à l'aide des règles basées sur les répertoires au lieu de la résolution MSBuild</value>
  </data>
  <data name="chkDuplicateMethodInheritedTypeWithSuffix" xml:space="preserve">
    <value>Méthode dupliquée. La méthode abstract '{0}' a le même nom et la même signature qu'une méthode abstract d'un type hérité, une fois les tuples, fonctions, unités de mesure et/ou types fournis effacés.</value>
  </data>
  <data name="tcUnitsOfMeasureInvalidInTypeConstructor" xml:space="preserve">
    <value>Impossible d'utiliser l'unité de mesure dans l'application de constructeur de type</value>
  </data>
  <data name="tcObjectConstructionExpressionCanOnlyImplementConstructorsInObjectModelTypes" xml:space="preserve">
    <value>Les expressions de construction d'objet (c'est-à-dire les expressions d'enregistrement avec des spécifications d'héritage) ne peuvent être utilisées que pour implémenter des constructeurs dans les types de modèles objet. Utilisez 'new ObjectType(args)' pour construire des instances de types de modèles objet hors des constructeurs</value>
  </data>
  <data name="lexCharNotAllowedInOperatorNames" xml:space="preserve">
    <value>'{0}' n'est pas autorisé en tant que caractère dans les noms d'opérateurs et est réservé pour un usage futur</value>
  </data>
  <data name="tcUseMayNotBeUsedInQueries" xml:space="preserve">
    <value>Les expressions 'use' ne peuvent pas être utilisées dans les requêtes</value>
  </data>
  <data name="tcTypeCannotBeEnumerated" xml:space="preserve">
    <value>Le type '{0}' n'est pas un type dont les valeurs peuvent être énumérées avec cette syntaxe. En d'autres termes, il n'est pas compatible avec seq&lt;_&gt;, IEnumerable&lt;_&gt; ou IEnumerable, et n'a pas de méthode GetEnumerator</value>
  </data>
  <data name="nrUnexpectedEmptyLongId" xml:space="preserve">
    <value>Identificateur long vide inattendu</value>
  </data>
  <data name="buildInvalidHashrDirective" xml:space="preserve">
    <value>Directive non valide. '#r \"&lt;fichier-ou-assembly&gt;\"' attendu</value>
  </data>
  <data name="checkNotSufficientlyGenericBecauseOfScopeAnon" xml:space="preserve">
    <value>Une variable de type d'inférence est sortie de sa portée à cause de l'inférence de type. Envisagez d'ajouter des annotations de type pour que votre code soit moins générique.</value>
  </data>
  <data name="csTypeDoesNotSupportConversion" xml:space="preserve">
    <value>Le type '{0}' ne prend pas en charge une conversion vers le type '{1}'</value>
  </data>
  <data name="optsClirootDeprecatedMsg" xml:space="preserve">
    <value>L'option de ligne de commande '--cliroot' est déconseillée. Utilisez une référence explicite à une copie spécifique de mscorlib.dll à la place.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleNamesDiffer" xml:space="preserve">
    <value>Les {0} définitions dans la signature et l'implémentation ne sont pas compatibles, car les noms sont différents. Le type est appelé '{1}' dans le fichier de signature et '{2}' dans l'implémentation.</value>
  </data>
  <data name="ilxgenUnexpectedArgumentToMethodHandleOfDuringCodegen" xml:space="preserve">
    <value>Argument non valide passé à 'methodhandleof' pendant la génération du code</value>
  </data>
  <data name="parsUnexpectedSymbolEqualsInsteadOfIn" xml:space="preserve">
    <value>Symbole '=' inattendu dans l'expression. Souhaitiez-vous utiliser 'for x in y .. z do' à la place ?</value>
  </data>
  <data name="nrNoConstructorsAvailableForType" xml:space="preserve">
    <value>Aucun constructeur n'est disponible pour le type '{0}'</value>
  </data>
  <data name="tcDuplicateSpecOfInterface" xml:space="preserve">
    <value>Spécification dupliquée d'une interface</value>
  </data>
  <data name="fscAssemblyNotFoundInDependencySet" xml:space="preserve">
    <value>L'assembly '{0}' est introuvable dans le jeu de dépendances du fichier binaire cible. Les racines liées de manière statique doivent être spécifiées à l'aide d'un nom d'assembly, sans extension DLL ou EXE. Si cet assembly a été référencé explicitement, il est possible qu'il n'ait pas été réellement requis par le fichier binaire généré. Dans ce cas, il ne doit pas être lié de manière statique.</value>
  </data>
  <data name="typrelTypeImplementsIComparableShouldOverrideObjectEquals" xml:space="preserve">
    <value>Le type '{0}' implémente 'System.IComparable'. Ajoutez également une substitution explicite pour 'Object.Equals'</value>
  </data>
  <data name="keyworkDescriptionAnd" xml:space="preserve">
    <value>Utilisé dans les liaisons mutuellement récursives, dans les déclarations de propriété et avec plusieurs contraintes sur des paramètres génériques.</value>
  </data>
  <data name="tcInvalidConstantExpression" xml:space="preserve">
    <value>Expression constante non valide</value>
  </data>
  <data name="optsResponseFileNotFound" xml:space="preserve">
    <value>Le fichier réponse '{0}' est introuvable dans '{1}'</value>
  </data>
  <data name="undefinedNameNamespace" xml:space="preserve">
    <value>L'espace de noms '{0}' n'est pas défini.</value>
  </data>
  <data name="csTypesDoNotSupportOperatorNullable" xml:space="preserve">
    <value>Aucun des types '{0}' ne prend en charge l'opérateur '{1}'. Envisagez d'ouvrir le module 'Microsoft.FSharp.Linq.NullableOperators'.</value>
  </data>
  <data name="parsDoCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Les modificateurs d'accessibilité ne sont pas autorisés sur les liaisons 'do' mais '{0}' a été spécifié.</value>
  </data>
  <data name="pplexUnexpectedChar" xml:space="preserve">
    <value>Caractère '{0}' inattendu dans l'expression de préprocesseur</value>
  </data>
  <data name="parsOnlyOneWithAugmentationAllowed" xml:space="preserve">
    <value>Une seule augmentation 'with' est autorisée</value>
  </data>
  <data name="tcParameterRequiresName" xml:space="preserve">
    <value>Un paramètre avec des attributs doit également être nommé, par exemple '[&lt;Attribute&gt;] Name : Type'</value>
  </data>
  <data name="tcFieldsDoNotDetermineUniqueRecordType" xml:space="preserve">
    <value>Les étiquettes et le type attendu du champ de cette expression d'enregistrement ou ce modèle d'enregistrement ne déterminent pas de manière unique un type enregistrement correspondant</value>
  </data>
  <data name="tcRequireActivePatternWithOneResult" xml:space="preserve">
    <value>Seuls les modèles actifs qui retournent un seul résultat peuvent accepter des arguments</value>
  </data>
  <data name="memberOperatorDefinitionWithNonPairArgument" xml:space="preserve">
    <value>Le membre opérateur infixe '{0}' a 1 argument initial ou {1} arguments initiaux. Tuple de 2 arguments attendu. Exemple : static member (+) (x,y) = ...</value>
  </data>
  <data name="typeInfoArgument" xml:space="preserve">
    <value>argument</value>
  </data>
  <data name="mlCompatMessage" xml:space="preserve">
    <value>Cette construction est pour la compatibilité ML. {0}. Vous pouvez désactiver cet avertissement en utilisant '--mlcompatibility' ou '--nowarn:62'.</value>
  </data>
  <data name="forHashSpecifierIsInvalid" xml:space="preserve">
    <value>Le modificateur de mise en forme # n'est pas valide en F#</value>
  </data>
  <data name="optsDelaySign" xml:space="preserve">
    <value>Différer la signature de l'assembly en utilisant uniquement la partie publique de la clé de nom fort</value>
  </data>
  <data name="keywordDescriptionException" xml:space="preserve">
    <value>Permet de déclarer un type d'exception.</value>
  </data>
  <data name="tcOverloadsCannotHaveCurriedArguments" xml:space="preserve">
    <value>Une ou plusieurs des surcharges de cette méthode comporte des arguments curryfiés. Recréez ces membres pour qu'ils acceptent des arguments basés sur des tuples.</value>
  </data>
  <data name="nrGlobalUsedOnlyAsFirstName" xml:space="preserve">
    <value>'global' ne peut être utilisé que comme premier nom dans un chemin d'accès qualifié</value>
  </data>
  <data name="tcInvalidTypeForLiteralEnumeration" xml:space="preserve">
    <value>Les littéraux énumérés doivent être de type int, uint, int16, uint16, int64, uint64, byte, sbyte ou char</value>
  </data>
  <data name="pickleMissingDefinition" xml:space="preserve">
    <value>Une erreur s'est produite lors de la lecture du nœud de métadonnées F# à la position {0} dans la table '{1}' de l'assembly '{2}'. Le nœud n'avait pas de déclaration correspondante. Veuillez signaler cet avertissement. Vous devrez peut-être recompiler l'assembly F# que vous utilisez actuellement.</value>
  </data>
  <data name="buildErrorOpeningBinaryFile" xml:space="preserve">
    <value>Erreur lors de l'ouverture du fichier binaire '{0}' : {1}</value>
  </data>
  <data name="tcInvalidMemberNameCtor" xml:space="preserve">
    <value>Nom de membre non valide. Les membres ne peuvent pas être appelés '.ctor' ou '.cctor'</value>
  </data>
  <data name="forBadFormatSpecifierGeneral" xml:space="preserve">
    <value>Spécificateur de format incorrect : '{0}'</value>
  </data>
  <data name="tcFieldNotLiteralCannotBeUsedInPattern" xml:space="preserve">
    <value>Ce champ n'est pas un littéral. Impossible de l'utiliser dans un modèle</value>
  </data>
  <data name="tcOnlyRecordFieldsAndSimpleLetCanBeMutable" xml:space="preserve">
    <value>Seuls les champs d'enregistrement et les liaisons 'let' simples non récursives peuvent être marqués comme mutables</value>
  </data>
  <data name="buildInvalidHashloadDirective" xml:space="preserve">
    <value>Directive non valide. '#load \"&lt;fichier&gt;\" ... \"&lt;fichier&gt;\"' attendu.</value>
  </data>
  <data name="csMethodFoundButIsStatic" xml:space="preserve">
    <value>Le type '{0}' a une méthode '{1}' (nom complet '{2}'), mais la méthode est statique</value>
  </data>
  <data name="tcNoMemberFoundForOverride" xml:space="preserve">
    <value>Impossible de trouver un membre abstrait ou membre d'interface qui corresponde à cette substitution</value>
  </data>
  <data name="tcInvalidPattern" xml:space="preserve">
    <value>Modèle non valide</value>
  </data>
  <data name="parsForDoExpected" xml:space="preserve">
    <value>'do' est manquant dans l'expression 'for'. 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;' était attendu.</value>
  </data>
  <data name="tcOverridingMethodRequiresAllOrNoTypeParameters" xml:space="preserve">
    <value>Vous devez déclarer explicitement tous les paramètres de type, ou aucun d'entre eux, lors de la substitution d'une méthode abstraite générique</value>
  </data>
  <data name="etUnsupportedProvidedExpression" xml:space="preserve">
    <value>Expression '{0}' non prise en charge retournée par le fournisseur de type. Si vous êtes l'auteur de ce fournisseur de type, envisagez de l'ajuster pour présenter une expression fournie différente.</value>
  </data>
  <data name="optsSubSystemVersion" xml:space="preserve">
    <value>Spécifier la version du sous-système de cet assembly</value>
  </data>
  <data name="tastUnexpectedByRef" xml:space="preserve">
    <value>Utilisation inattendue d'une variable typée byref</value>
  </data>
  <data name="optFailedToInlineValue" xml:space="preserve">
    <value>Impossible d'effectuer l'incorporation (inlining) de la valeur '{0}' marquée comme 'inline', peut-être en raison d'une valeur récursive marquée comme 'inline'</value>
  </data>
  <data name="keywordDescriptionRightArrow" xml:space="preserve">
    <value>Dans les types de fonction, délimite les arguments et les valeurs renvoyées. Produit une expression (dans les expressions de séquence). Équivaut au mot clé yield. Utilisé dans les expressions match</value>
  </data>
  <data name="tcStructsCannotHaveConstructorWithNoArguments" xml:space="preserve">
    <value>Les structs ne peuvent pas avoir de constructeur d'objet sans arguments. Il s'agit d'une restriction imposée à tous les langages CLI, car les structs prennent automatiquement en charge un constructeur par défaut.</value>
  </data>
  <data name="ilSignInvalidAlgId" xml:space="preserve">
    <value>algId non valide - 'Exponent' attendu</value>
  </data>
  <data name="returnUsedInsteadOfReturnBang" xml:space="preserve">
    <value>Utilisez 'return!' à la place de 'return'.</value>
  </data>
  <data name="derefInsteadOfNot" xml:space="preserve">
    <value>L'opérateur '!' est utilisé pour déréférencer une cellule ref. Songez à utiliser 'not expr' ici.</value>
  </data>
  <data name="optsNoInterface" xml:space="preserve">
    <value>N'ajouter aucune ressource à l'assembly généré contenant les métadonnées spécifiques F#</value>
  </data>
  <data name="parsUnexpectedInfixOperator" xml:space="preserve">
    <value>Opérateur infixe inattendu dans l'expression de type</value>
  </data>
  <data name="optsEmbeddedSourceRequirePortablePDBs" xml:space="preserve">
    <value>Commutateur --embed uniquement pris en charge durant l'émission d'un fichier PDB portable (--debug:portable ou --debug:embedded)</value>
  </data>
  <data name="parsInvalidPrefixOperatorDefinition" xml:space="preserve">
    <value>Définition d'opérateur non valide. Les définitions d'opérateur de préfixe doivent utiliser un nom d'opérateur de préfixe valide.</value>
  </data>
  <data name="tcUnnamedArgumentsDoNotFormPrefix" xml:space="preserve">
    <value>Les arguments sans nom ne forment pas le préfixe des arguments de la méthode nommée</value>
  </data>
  <data name="invalidFullNameForProvidedType" xml:space="preserve">
    <value>nom complet non valide pour le type fourni</value>
  </data>
  <data name="lexHashElseMustBeFirst" xml:space="preserve">
    <value>La directive #else doit être le premier caractère (autre qu'un espace blanc) d'une ligne</value>
  </data>
  <data name="tcUnionCaseFieldCannotBeUsedMoreThanOnce" xml:space="preserve">
    <value>Le champ de cas ou d'exception d'union '{0}' ne peut pas être utilisé plusieurs fois.</value>
  </data>
  <data name="parsUnionCasesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Les modificateurs d'accessibilité ne sont pas autorisés sur les cas d'union. Utilisez 'type U = internal ...' ou 'type U = private ...' pour fournir une accessibilité à l'ensemble de la représentation.</value>
  </data>
  <data name="chkErrorUseOfByref" xml:space="preserve">
    <value>Une instanciation de type implique un type byref. Cela n'est pas autorisé par les règles du langage CIL (Common Intermediate Language).</value>
  </data>
  <data name="tcUnknownUnion" xml:space="preserve">
    <value>Cas d'union inconnu</value>
  </data>
  <data name="tcInvalidMethodNameForRelationalOperator" xml:space="preserve">
    <value>Le nom '({0})' ne doit pas être utilisé en tant que nom de membre. Pour définir une sémantique de comparaison pour un type, implémentez l'interface 'System.IComparable'. Si vous définissez un membre statique à utiliser à partir d'autres langages CLI, utilisez le nom '{1}' à la place.</value>
  </data>
  <data name="tcTypeAbbreviationsCannotHaveAugmentations" xml:space="preserve">
    <value>Les abréviations de type ne peuvent pas avoir d'augmentations</value>
  </data>
  <data name="ModuleContainsConstructorButAccessibilityDiffers" xml:space="preserve">
    <value>Le module contient le constructeur\n    {0}    \nmais sa signature spécifie\n    {1}    \nL'accessibilité spécifiée dans la signature est supérieure à celle spécifiée dans l'implémentation</value>
  </data>
  <data name="ValueNotContainedMutabilityAritiesDiffer" xml:space="preserve">
    <value>Le module '{0}' contient\n    {1}    \nmais sa signature spécifie\n    {2}    \nLes arités sont différentes entre la signature et l'implémentation. La signature spécifie que '{3}' est une définition de fonction ou une expression lambda qui accepte au moins {4} argument(s) mais l'implémentation est une valeur de fonction calculée. Pour déclarer qu'une valeur de fonction calculée est une implémentation autorisée, mettez simplement son type entre parenthèses dans la signature, par exemple\n\tval {5}: int -&gt; (int -&gt; int)\nau lieu de\n\tval {6}: int -&gt; int -&gt; int.</value>
  </data>
  <data name="typeInfoOtherOverloads" xml:space="preserve">
    <value>et {0} autres surcharges</value>
  </data>
  <data name="csTypeIsNotEnumType" xml:space="preserve">
    <value>Le type '{0}' n'est pas un type enum CLI</value>
  </data>
  <data name="parsModuleAbbreviationMustBeSimpleName" xml:space="preserve">
    <value>Une abréviation de module doit être un nom simple et non un chemin d'accès</value>
  </data>
  <data name="tastRecursiveValuesMayNotAppearInConstructionOfType" xml:space="preserve">
    <value>Impossible de faire apparaître les valeurs récursives directement en tant que construction du type '{0}' dans une liaison récursive. Cette fonctionnalité a été supprimée du langage F#. Utilisez un type enregistrement à la place.</value>
  </data>
  <data name="buildProductNameCommunity" xml:space="preserve">
    <value>Compilateur F# pour F# {0}</value>
  </data>
  <data name="typrelNamedArgumentHasBeenAssignedMoreThenOnce" xml:space="preserve">
    <value>Plusieurs valeurs ont été assignées à un argument nommé</value>
  </data>
  <data name="fscIgnoringMixedWhenLinking" xml:space="preserve">
    <value>L'assembly mixte managé/non managé '{0}' est ignoré lors de la liaison statique</value>
  </data>
  <data name="tcOnlyStructsCanHaveStructLayout" xml:space="preserve">
    <value>Seuls les structs et les classes sans constructeurs principaux peuvent recevoir l'attribut 'StructLayout'</value>
  </data>
  <data name="tcExpectedTypeParameter" xml:space="preserve">
    <value>Paramètre de type attendu à la place d'un paramètre d'unité de mesure</value>
  </data>
  <data name="keywordDescriptionDefault" xml:space="preserve">
    <value>Indique l'implémentation d'une méthode abstraite et s'utilise avec une déclaration de méthode abstraite pour créer une méthode virtuelle.</value>
  </data>
  <data name="parsEofInTripleQuoteStringInComment" xml:space="preserve">
    <value>La fin du fichier dans la chaîne à guillemets triples incorporée dans un commentaire a commencé ici ou avant ici</value>
  </data>
  <data name="optsUseHighEntropyVA" xml:space="preserve">
    <value>Activer la randomisation du format d'espace d'adresse d'entropie élevée</value>
  </data>
  <data name="ilSignPrivateKeyExpected" xml:space="preserve">
    <value>Clé privée attendue</value>
  </data>
  <data name="typeInfoActivePatternResult" xml:space="preserve">
    <value>résultat du modèle actif</value>
  </data>
  <data name="tcUnsupportedMutRecDecl" xml:space="preserve">
    <value>Cette déclaration n'est pas prise en charge dans les groupes de déclarations récursives</value>
  </data>
  <data name="ppparsMissingToken" xml:space="preserve">
    <value>Jeton '{0}' manquant dans l'expression de préprocesseur</value>
  </data>
  <data name="fscTooManyErrors" xml:space="preserve">
    <value>Fermeture en cours : trop d'erreurs</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectNumberOfArguments" xml:space="preserve">
    <value>Le membre '{0}' n'a pas le nombre approprié d'arguments. La signature requise est '{1}'.</value>
  </data>
  <data name="augInvalidAttrs" xml:space="preserve">
    <value>Ce type utilise un mélange non valide des attributs 'NoEquality', 'ReferenceEquality', 'StructuralEquality', 'NoComparison' et 'StructuralComparison'</value>
  </data>
  <data name="tcLetAndDoRequiresImplicitConstructionSequence" xml:space="preserve">
    <value>Cette définition ne peut être utilisée que dans un type avec un constructeur principal. Ajoutez des arguments à votre définition de type, par exemple, e.g. 'type X(args) =…'.</value>
  </data>
  <data name="chkAttrHasAllowMultiFalse" xml:space="preserve">
    <value>Le type d'attribut '{0}' a 'AllowMultiple=false'. Impossible d'attacher plusieurs instances de cet attribut à un élément de langage unique.</value>
  </data>
  <data name="tcUseYieldBangForMultipleResults" xml:space="preserve">
    <value>Dans les expressions de séquence, les résultats multiples sont générés à l'aide de 'yield!'</value>
  </data>
  <data name="csTypeDoesNotSupportOperatorNullable" xml:space="preserve">
    <value>Le type '{0}' ne prend pas en charge l'opérateur '{1}'. Ouvrez le module 'Microsoft.FSharp.Linq.NullableOperators'.</value>
  </data>
  <data name="tcStructsInterfacesEnumsDelegatesMayNotInheritFromOtherTypes" xml:space="preserve">
    <value>Les structs, interfaces, enums et délégués ne peuvent pas hériter d'autres types</value>
  </data>
  <data name="impInvalidNumberOfGenericArguments" xml:space="preserve">
    <value>Nombre d'arguments génériques non valide pour le type '{0}' dans le type fourni. '{1}' arguments étaient attendus, '{2}' ont été fournis.</value>
  </data>
  <data name="tcMethodNotAccessible" xml:space="preserve">
    <value>La méthode '{0}' n'est pas accessible à partir de cet emplacement du code</value>
  </data>
  <data name="ilSignInvalidMagicValue" xml:space="preserve">
    <value>Valeur magique non valide dans l'en-tête CLR</value>
  </data>
  <data name="tcInvalidOptionalAssignmentToPropertyOrField" xml:space="preserve">
    <value>Assignation facultative non valide pour une propriété ou un champ</value>
  </data>
  <data name="csNoMemberTakesTheseArguments3" xml:space="preserve">
    <value>Aucun membre ou constructeur d'objet {0} nommé '{1}' n'accepte {2} arguments. L'argument nommé '{3}' ne correspond pas à un argument ou une propriété de retour définissable pour une surcharge.</value>
  </data>
  <data name="csNoMemberTakesTheseArguments2" xml:space="preserve">
    <value>Aucun membre ou constructeur d'objet {0} nommé '{1}' n'accepte {2} arguments. Notez que l'appel de ce membre fournit également {3} arguments nommés.</value>
  </data>
  <data name="nrInvalidFieldLabel" xml:space="preserve">
    <value>Étiquette de champ non valide</value>
  </data>
  <data name="ilMarshalAsAttributeCannotBeDecoded" xml:space="preserve">
    <value>Impossible de décoder l'attribut MarshalAs</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleILDiffer" xml:space="preserve">
    <value>Les {0} définitions pour le type '{1}' dans la signature et l'implémentation ne sont pas compatibles, car les représentations IL (Intermediate Language) sont différentes</value>
  </data>
  <data name="buildUnexpectedTypeArgs" xml:space="preserve">
    <value>Le type non générique '{0}' n'attend aucun argument de type mais reçoit ici {1} argument(s) de type</value>
  </data>
  <data name="undefinedNameValueConstructorNamespaceOrType" xml:space="preserve">
    <value>La valeur, le constructeur, l'espace de noms ou le type '{0}' n'est pas défini.</value>
  </data>
  <data name="typeInfoNamespaceOrModule" xml:space="preserve">
    <value>espace de noms/module</value>
  </data>
  <data name="recursiveClassHierarchy" xml:space="preserve">
    <value>Hiérarchie de classes récursive dans le type '{0}'</value>
  </data>
  <data name="chkUnusedThisVariable" xml:space="preserve">
    <value>La référence d'objet récursive '{0}' n'est pas utilisée. La présence d'une référence d'objet récursive ajoute des vérifications de l'initialisation du runtime aux membres de ce type et des types dérivés. Supprimez cette référence d'objet récursive.</value>
  </data>
  <data name="augTypeCantHaveRefEqAndStructAttrs" xml:space="preserve">
    <value>Un type ne peut pas avoir à la fois les attributs 'ReferenceEquality' et 'StructuralEquality' ou 'StructuralComparison'</value>
  </data>
  <data name="tcConstructRequiresComputationExpression" xml:space="preserve">
    <value>Cette construction ne peut être utilisée que dans des expressions de calcul</value>
  </data>
  <data name="tastValueMustBeLocalAndMutable" xml:space="preserve">
    <value>Une valeur doit être mutable pour pouvoir muter le contenu ou accepter l'adresse d'un type valeur, par exemple 'let mutable x = ...'</value>
  </data>
  <data name="tcExceptionAbbreviationsMustReferToValidExceptions" xml:space="preserve">
    <value>Les abréviations d'exceptions doivent faire référence à des exceptions existantes ou des types F# dérivant de System.Exception</value>
  </data>
  <data name="optsEmbedAllSource" xml:space="preserve">
    <value>Incorporer tous les fichiers sources dans le fichier PDB portable</value>
  </data>
  <data name="tcOnlySimplePatternsInLetRec" xml:space="preserve">
    <value>Seuls les modèles de variable simples peuvent être liés dans les constructions 'let rec'</value>
  </data>
  <data name="parsSuccessiveArgsShouldBeSpacedOrTupled" xml:space="preserve">
    <value>Les arguments successifs doivent être séparés par des espaces ou être basés sur des tuples. En outre, les arguments impliquant des applications de fonction ou de méthode doivent être mis entre parenthèses</value>
  </data>
  <data name="tcNotAnException" xml:space="preserve">
    <value>N'est pas une exception</value>
  </data>
  <data name="tcInvalidIndexIntoActivePatternArray" xml:space="preserve">
    <value>Erreur interne. Index non valide dans le tableau du modèle actif</value>
  </data>
  <data name="fscAssumeStaticLinkContainsNoDependencies" xml:space="preserve">
    <value>L'assembly '{0}' a été référencé transitivement et n'a pas pu être résolu automatiquement. La liaison statique suppose que cette DLL n'a pas de dépendances par rapport à la bibliothèque F# ou toute autre DLL liée de manière statique. Ajoutez une référence explicite à cette DLL.</value>
  </data>
  <data name="fscAssemblyCultureAttributeError" xml:space="preserve">
    <value>Erreur lors de l'émission de l'attribut 'System.Reflection.AssemblyCultureAttribute' -- Les exécutables ne peuvent pas être des assemblys satellites. La culture doit toujours être vide</value>
  </data>
  <data name="parsInterfacesHaveSameVisibilityAsEnclosingType" xml:space="preserve">
    <value>Les interfaces ont toujours la même visibilité que le type englobant</value>
  </data>
  <data name="ValueNotContainedMutabilityOneIsTypeFunction" xml:space="preserve">
    <value>Le module '{0}' contient\n    {1}    \nmais sa signature spécifie\n    {2}    \nL'un est une fonction de type mais pas l'autre. La signature requiert des paramètres de type explicite s'ils sont présents dans l'implémentation.</value>
  </data>
  <data name="parsSyntaxModuleStructEndDeprecated" xml:space="preserve">
    <value>La syntaxe 'module ... = struct .. end' n'est pas utilisée pour le code F#. Utilisez 'module ... = begin .. end'</value>
  </data>
  <data name="tcVolatileOnlyOnClassLetBindings" xml:space="preserve">
    <value>L'attribut 'VolatileField' ne peut être utilisé que sur les liaisons 'let' dans les classes</value>
  </data>
  <data name="FieldNotContainedLiteralsDiffer" xml:space="preserve">
    <value>Le module contient le champ\n    {0}    \nmais sa signature spécifie\n    {1}    \nLes modificateurs 'literal' sont différents</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbbreviationsDiffer" xml:space="preserve">
    <value>Les {0} définitions pour le type '{1}' dans la signature et l'implémentation ne sont pas compatibles, car les abréviations sont différentes : {2} par opposition à {3}</value>
  </data>
  <data name="tcExplicitStaticInitializerSyntax" xml:space="preserve">
    <value>Un initialiseur statique explicite doit utiliser la syntaxe 'static new(args) = expr'</value>
  </data>
  <data name="tcOnlyFunctionsCanBeInline" xml:space="preserve">
    <value>Seules les fonctions peuvent être marquées comme 'inline'</value>
  </data>
  <data name="tcTypeIsNotInterfaceType0" xml:space="preserve">
    <value>Ce type n'est pas un type interface</value>
  </data>
  <data name="tcTypeIsNotInterfaceType1" xml:space="preserve">
    <value>Le type '{0}' n'est pas un type interface</value>
  </data>
  <data name="chkObjCtorsCantUseExceptionHandling" xml:space="preserve">
    <value>Les constructeurs d'objets ne peuvent pas utiliser directement try/with et try/finally avant l'initialisation de l'objet. Cela inclut les constructions telles que 'for x in ...' qui peuvent conduire aux utilisations de ces constructions. Il s'agit d'une limitation imposée par le langage CIL (Common Intermediate Language).</value>
  </data>
  <data name="tcReturnMayNotBeUsedInQueries" xml:space="preserve">
    <value>'return' et 'return!' ne peuvent pas être utilisés dans les requêtes</value>
  </data>
  <data name="parsRecordFieldsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Les modificateurs d'accessibilité ne sont pas autorisés sur les champs de type enregistrement. Utilisez 'type R = internal ...' ou 'type R = private ...' pour fournir une accessibilité à l'ensemble de la représentation.</value>
  </data>
  <data name="keywordDescriptionUseBang" xml:space="preserve">
    <value>Utilisé à la place de let! dans les flux de travail asynchrones et autres expressions de calcul pour les valeurs qui nécessitent l'appel de Dispose pour libérer des ressources.</value>
  </data>
  <data name="tcInheritIllegalHere" xml:space="preserve">
    <value>Aucune déclaration d'héritage n'est autorisée ici</value>
  </data>
  <data name="etNullMemberDeclaringType" xml:space="preserve">
    <value>Les infos de membre '{1}' du type fourni '{0}' ont un type déclarant Null</value>
  </data>
  <data name="etProvidedAppliedMethodHadWrongName" xml:space="preserve">
    <value>Le fournisseur de type '{0}' a retourné une méthode non valide à partir de 'ApplyStaticArgumentsForMethod'. La méthode nommée '{1}' était attendue, mais la méthode nommée '{2}' a été retournée.</value>
  </data>
  <data name="lexInvalidUnicodeLiteral" xml:space="preserve">
    <value>\U{0} n'est pas une séquence d'échappement de caractères Unicode valide</value>
  </data>
  <data name="nrTypeInstantiationNeededToDisambiguateTypesWithSameName" xml:space="preserve">
    <value>Il existe plusieurs types nommés '{0}' qui acceptent divers nombres de paramètres génériques. Fournissez une instanciation de type pour lever l'ambiguïté de la résolution de type. Exemple : '{1}'.</value>
  </data>
  <data name="typrelModuleNamespaceAttributesDifferInSigAndImpl" xml:space="preserve">
    <value>Les attributs de l'espace de noms ou du module sont différents entre la signature et l'implémentation</value>
  </data>
  <data name="typrelNeedExplicitImplementation" xml:space="preserve">
    <value>L'interface '{0}' est incluse dans plusieurs types interface implémentés explicitement. Ajoutez une implémentation explicite de cette interface.</value>
  </data>
  <data name="eventHasNonStandardType" xml:space="preserve">
    <value>L'événement '{0}' a un type non standard. Si cet événement est déclaré dans un autre langage CLI, vous pouvez accéder à cet événement à l'aide des méthodes explicites {1} et {2} de l'événement. Si cet événement est déclaré en F#, faites du type de l'événement une instanciation de 'IDelegateEvent&lt;_&gt;' ou 'IEvent&lt;_,_&gt;'.</value>
  </data>
  <data name="tcReservedSyntaxForAugmentation" xml:space="preserve">
    <value>La syntaxe 'type X with …' est réservée aux augmentations. Les types dont les représentations sont masquées mais qui possèdent des membres sont désormais déclarés dans les signatures via 'type X = …'. Vous pouvez également ajouter l'attribut '[&lt;Sealed&gt;] à la définition de type dans la signature</value>
  </data>
  <data name="undefinedNameSuggestionsIntro" xml:space="preserve">
    <value>Peut-être souhaitez-vous l'une des options suivantes :</value>
  </data>
  <data name="undefinedNameRecordLabel" xml:space="preserve">
    <value>L'étiquette d'enregistrement '{0}' n'est pas définie.</value>
  </data>
  <data name="tcTypeTestLosesMeasures" xml:space="preserve">
    <value>Ce test de type ou ce cast d'une classe de base va ignorer l'unité de mesure '{0}'</value>
  </data>
  <data name="ilSignInvalidPKBlob" xml:space="preserve">
    <value>Objet blob de clé publique non valide</value>
  </data>
  <data name="fscStaticLinkingNoProfileMismatches" xml:space="preserve">
    <value>Les liens statiques ne doivent pas être utilisés sur un assembly qui référence mscorlib (par ex., un assembly .NET Framework) pendant la génération d'un assembly qui référence System.Runtime (par ex., un assembly .NET Core ou portable).</value>
  </data>
  <data name="ValueNotContainedMutabilityGenericParametersDiffer" xml:space="preserve">
    <value>Le module '{0}' contient\n    {1}    \nmais sa signature spécifie\n    {2}    \nLe nombre de paramètres génériques est différent entre la signature et l'implémentation (la signature déclare {3} mais l'implémentation déclare {4}</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectKindsOfGenericParameters" xml:space="preserve">
    <value>Le membre '{0}' n'a pas les genres appropriés de paramètres génériques. La signature requise est '{1}'.</value>
  </data>
  <data name="typrelSigImplNotCompatibleParamCountsDiffer" xml:space="preserve">
    <value>La signature et l'implémentation ne sont pas compatibles, car le nombre de paramètres de type respectifs est différent</value>
  </data>
  <data name="tcTypeExceptionOrModule" xml:space="preserve">
    <value>type, exception ou module</value>
  </data>
  <data name="tcExpressionWithIfRequiresParenthesis" xml:space="preserve">
    <value>Cette expression de liste ou de tableau comprend un élément sous la forme 'if ... then ... else'. Mettez cette expression entre parenthèses pour indiquer qu'il s'agit d'un élément individuel de la liste ou du tableau, afin de lever l'ambigüité par rapport à une liste générée à l'aide d'une expression de séquence</value>
  </data>
  <data name="csTypeDoesNotHaveNull" xml:space="preserve">
    <value>Le type '{0}' n'a pas la valeur 'null' comme valeur appropriée</value>
  </data>
  <data name="parsVisibilityDeclarationsShouldComePriorToIdentifier" xml:space="preserve">
    <value>Les modificateurs d'accessibilité doivent être placés immédiatement avant l'identificateur qui nomme une construction</value>
  </data>
  <data name="parsUnmatchedUse" xml:space="preserve">
    <value>Définition de valeur incomplète. S'il s'agit d'une expression, le corps de l'expression doit être mis en retrait sur la même colonne que le mot-clé 'use'.</value>
  </data>
  <data name="parsUnmatchedLet" xml:space="preserve">
    <value>Définition de valeur ou de fonction incomplète. S'il s'agit d'une expression, le corps de l'expression doit être mis en retrait sur la même colonne que le mot-clé 'let'.</value>
  </data>
  <data name="tcUnionCaseConstructorDoesNotHaveFieldWithGivenName" xml:space="preserve">
    <value>Le cas ou l'exception d'union '{0}' ne possède pas de champ nommé '{1}'.</value>
  </data>
  <data name="tcInvalidMemberName" xml:space="preserve">
    <value>Le nom '({0})' ne doit pas être utilisé en tant que nom de membre. Si vous définissez un membre statique à utiliser à partir d'autres langages CLI, utilisez le nom '{1}' à la place.</value>
  </data>
  <data name="etProviderDoesNotHaveValidConstructor" xml:space="preserve">
    <value>Le fournisseur de type n'a pas de constructeur valide. Un constructeur sans argument ou prenant un argument de type 'TypeProviderConfig' était attendu.</value>
  </data>
  <data name="tcRecordsUnionsAbbreviationsStructsMayNotHaveAllowNullLiteralAttribute" xml:space="preserve">
    <value>Les types enregistrement, union, abréviation et struct ne peuvent pas avoir l'attribut 'AllowNullLiteral'</value>
  </data>
  <data name="tcExpressionFormRequiresRecordTypes" xml:space="preserve">
    <value>La forme d'expression {{ expr with ... }} ne peut être utilisée qu'avec des types enregistrement. Pour générer des types d'objets, utilisez {{ new Type(...) with ... }}</value>
  </data>
  <data name="typrelNoImplementationGiven" xml:space="preserve">
    <value>Aucune implémentation n'a été fournie pour '{0}'</value>
  </data>
  <data name="tcUnionCaseExpectsTupledArguments" xml:space="preserve">
    <value>Ce cas d'union attend {0} arguments basés sur des tuples</value>
  </data>
  <data name="tastDuplicateTypeDefinitionInAssembly" xml:space="preserve">
    <value>Deux définitions de type nommées '{0}' sont présentes dans l'espace de noms '{1}' dans deux parties de cet assembly</value>
  </data>
  <data name="tcInvalidModuleName" xml:space="preserve">
    <value>Nom de module non valide</value>
  </data>
  <data name="considerUpcastOperator" xml:space="preserve">
    <value>La conversion de {0} en {1} est un cast sécurisé d'un type dérivé en l'une de ses classes de base au moment de la compilation, et non un cast d'une classe de base en une classe dérivée. Utilisez l'opérateur :&gt; (upcast) à la place de l'opérateur :?&gt; (downcast).</value>
  </data>
  <data name="forPositionalSpecifiersNotPermitted" xml:space="preserve">
    <value>Les spécificateurs de position ne sont pas autorisés dans les chaînes de format</value>
  </data>
  <data name="tcCustomOperationMayNotBeOverloaded" xml:space="preserve">
    <value>L'opération personnalisée '{0}' fait référence à une méthode surchargée. Les implémentations d'opérations personnalisées ne peuvent pas être surchargées.</value>
  </data>
  <data name="parsUseBindingsIllegalInModules" xml:space="preserve">
    <value>Les liaisons 'use' ne sont pas autorisées dans les modules et sont considérées comme des liaisons 'let'</value>
  </data>
  <data name="optsCodepage" xml:space="preserve">
    <value>Spécifier la page de codes utilisée pour lire les fichiers sources</value>
  </data>
  <data name="elDeprecatedOperator" xml:space="preserve">
    <value>Le traitement de cet opérateur est désormais géré directement par le compilateur F# et il est impossible de redéfinir sa signification</value>
  </data>
  <data name="keywordDescriptionDynamicCast" xml:space="preserve">
    <value>Convertit un type en type inférieur dans la hiérarchie.</value>
  </data>
  <data name="buildCouldNotReadVersionInfoFromMscorlib" xml:space="preserve">
    <value>Impossible de lire la version à partir de mscorlib.dll</value>
  </data>
  <data name="etProviderErrorWithContext" xml:space="preserve">
    <value>Le fournisseur de type '{0}' a signalé une erreur dans le contexte du type fourni '{1}', membre '{2}'. Erreur : {3}</value>
  </data>
  <data name="etErrorApplyingStaticArgumentsToType" xml:space="preserve">
    <value>Une erreur s'est produite lors de l'application des arguments statiques à un type fourni</value>
  </data>
  <data name="optsHelpBannerInputFiles" xml:space="preserve">
    <value>- FICHIERS D'ENTRÉE -</value>
  </data>
  <data name="parsIntegerForLoopRequiresSimpleIdentifier" xml:space="preserve">
    <value>Un entier d'une boucle doit utiliser un identificateur simple</value>
  </data>
  <data name="lexOutsideEightBitSignedHex" xml:space="preserve">
    <value>Ce nombre se trouve en dehors de la plage autorisée pour les entiers signés 8 bits hexadécimaux</value>
  </data>
  <data name="patternMatchGuardIsNotBool" xml:space="preserve">
    <value>Une protection de critères spéciaux doit être de type 'bool', mais cette expression 'when' est de type '{0}'.</value>
  </data>
  <data name="parsEmptyTypeDefinition" xml:space="preserve">
    <value>Une définition de type requiert un ou plusieurs membres ou d'autres déclarations. Si vous envisagez de définir une classe, un struct ou une interface vide, utilisez 'type ... = class end', 'interface end' ou 'struct end'.</value>
  </data>
  <data name="csGenericConstructRequiresReferenceSemantics" xml:space="preserve">
    <value>Une construction générique requiert que le type '{0}' ait une sémantique de référence, mais ce n'est pas le cas, car il s'agit par exemple d'un struct</value>
  </data>
  <data name="ValueNotContainedMutabilityNamesDiffer" xml:space="preserve">
    <value>Le module '{0}' contient\n    {1}    \nmais sa signature spécifie\n    {2}    \nLes noms sont différents</value>
  </data>
  <data name="chkNoByrefInTypeAbbrev" xml:space="preserve">
    <value>L'abréviation de type contient des types byref. Cela n'est pas autorisé en F#.</value>
  </data>
  <data name="ilwriteErrorCreatingMdb" xml:space="preserve">
    <value>Impossible de générer les informations de débogage de MDB. Le chargement du type 'MonoSymbolWriter' depuis l'assembly 'Mono.CompilerServices.SymbolWriter.dll' a échoué.</value>
  </data>
  <data name="ilwriteErrorCreatingPdb" xml:space="preserve">
    <value>Erreur inattendue lors de la création du fichier des informations de débogage '{0}'</value>
  </data>
  <data name="tcExpectedUnitOfMeasureMarkWithAttribute" xml:space="preserve">
    <value>Paramètre d'unité de mesure attendu à la place d'un paramètre de type. Les paramètres d'unité de mesure explicites doivent être marqués avec l'attribut [&lt;Measure&gt;].</value>
  </data>
  <data name="tcUnableToParseFormatString" xml:space="preserve">
    <value>Impossible d'analyser la chaîne de format '{0}'</value>
  </data>
  <data name="tastUnexpectedDecodeOfAutoOpenAttribute" xml:space="preserve">
    <value>Décodage inattendu de AutoOpenAttribute</value>
  </data>
  <data name="crefQuotationsCantCallTraitMembers" xml:space="preserve">
    <value>Les quotations ne peuvent pas contenir d'expressions qui appellent des contraintes de membres ou utilisent des opérateurs qui sont implicitement résolus en appel de contrainte membre</value>
  </data>
  <data name="noEqualSignAfterModule" xml:space="preserve">
    <value>Les fichiers situés dans les bibliothèques ou les applications contenant plusieurs fichiers doivent commencer par une déclaration d'espace de noms ou de module. Quand vous utilisez une déclaration de module au début d'un fichier, le signe '=' n'est pas autorisé. S'il s'agit d'un module de niveau supérieur, supprimez le signe = pour résoudre l'erreur.</value>
  </data>
  <data name="tcFieldAppearsTwiceInRecord" xml:space="preserve">
    <value>Le champ '{0}' apparaît à deux reprises dans cette expression ou ce modèle d'enregistrement</value>
  </data>
  <data name="etProvidedTypeHasUnexpectedName" xml:space="preserve">
    <value>Un type fourni nommé '{0}' était attendu, mais 'Name' a la valeur '{1}' pour le type fourni</value>
  </data>
  <data name="etProvidedTypeHasUnexpectedPath" xml:space="preserve">
    <value>Un type fourni utilisant le chemin '{0}' était attendu, mais le type fourni utilise le chemin '{1}'</value>
  </data>
  <data name="tcCustomAttributeArgumentMismatch" xml:space="preserve">
    <value>Le nombre d'arguments d'un attribut personnalisé ne correspond pas au nombre attendu d'arguments du constructeur d'attribut</value>
  </data>
  <data name="chkMemberUsedInInvalidWay" xml:space="preserve">
    <value>Le membre '{0}' est utilisé de manière incorrecte. Une utilisation de '{1}' a été déduite avant sa définition au niveau ou à proximité de '{2}'. Il s'agit d'une référence anticipée non valide.</value>
  </data>
  <data name="etEventNoRemove" xml:space="preserve">
    <value>L'événement '{0}' sur le type fourni '{1}' n'a pas de valeur de GetRemoveMethod()</value>
  </data>
  <data name="ilSignRsaKeyExpected" xml:space="preserve">
    <value>Clé RSA attendue</value>
  </data>
  <data name="tcFSharpCoreRequiresExplicit" xml:space="preserve">
    <value>Tous les types enregistrement, union et struct dans FSharp.Core.dll doivent être étiquetés explicitement avec 'StructuralComparison' ou 'NoComparison'</value>
  </data>
  <data name="nrUnionTypeNeedsQualifiedAccess" xml:space="preserve">
    <value>Le type union du cas d'union '{0}' a été défini avec RequireQualifiedAccessAttribute. Incluez le nom du type union ('{1}') dans le nom que vous utilisez.</value>
  </data>
  <data name="tastActivePatternsLimitedToSeven" xml:space="preserve">
    <value>Les modèles actifs ne peuvent pas retourner plus de 7 possibilités</value>
  </data>
  <data name="undefinedNameValueOfConstructor" xml:space="preserve">
    <value>La valeur ou le constructeur '{0}' n'est pas défini.</value>
  </data>
  <data name="tcInheritConstructionCallNotPartOfImplicitSequence" xml:space="preserve">
    <value>Cette déclaration 'inherit' a des arguments, mais ne figure pas dans un type avec un constructeur principal. Ajoutez des arguments à votre définition de type, par exemple 'type X(args) = …'.</value>
  </data>
  <data name="tcTypesAreAlwaysSealedDU" xml:space="preserve">
    <value>Les types union discriminés sont toujours sealed</value>
  </data>
  <data name="ilUnexpectedGetSetAnnotation" xml:space="preserve">
    <value>Annotation GetSet inattendue pour une propriété</value>
  </data>
  <data name="tcInvalidEnumerationLiteral" xml:space="preserve">
    <value>Valeur non valide pour un littéral d'énumération</value>
  </data>
  <data name="nrInvalidModuleExprType" xml:space="preserve">
    <value>Module/expression/type non valide</value>
  </data>
  <data name="nicePrintOtherOverloadsN" xml:space="preserve">
    <value>+ {0} surcharges</value>
  </data>
  <data name="nicePrintOtherOverloads1" xml:space="preserve">
    <value>+ 1 surcharge</value>
  </data>
  <data name="csExpectTypeWithOperatorButGivenTuple" xml:space="preserve">
    <value>Un type prenant en charge l'opérateur '{0}' est attendu, mais un type tuple a été reçu</value>
  </data>
  <data name="fscReferenceOnCommandLine" xml:space="preserve">
    <value>L'assembly '{0}' est répertorié sur la ligne de commande. Les assemblys doivent être référencés à l'aide d'un indicateur de ligne de commande, tel que '-r'.</value>
  </data>
  <data name="etProvidedTypeWithNullOrEmptyName" xml:space="preserve">
    <value>Le '{0}' d'un type fourni était Null ou vide.</value>
  </data>
  <data name="chkDuplicateMethodInheritedType" xml:space="preserve">
    <value>Méthode dupliquée. La méthode abstract '{0}' a le même nom et la même signature qu'une méthode abstract d'un type hérité.</value>
  </data>
  <data name="typeInfoFromNext" xml:space="preserve">
    <value>également de {0}</value>
  </data>
  <data name="tcRuntimeSuppliedMethodCannotBeUsedInUserCode" xml:space="preserve">
    <value>La méthode Array '{0}' est fournie par le runtime et ne peut pas être utilisée directement dans le code. Pour les opérations comportant des éléments Array, envisagez d'utiliser la famille de fonctions GetArray/SetArray du module LanguagePrimitives.IntrinsicFunctions.</value>
  </data>
  <data name="parsIgnoreAttributesOnModuleAbbreviationAlwaysPrivate" xml:space="preserve">
    <value>L'attribut d'accessibilité '{0}' n'est pas autorisé pour l'abréviation du module. Les abréviations de module sont toujours privées.</value>
  </data>
  <data name="tcGeneratedTypesShouldBeInternalOrPrivate" xml:space="preserve">
    <value>Les types fournis générés par cette utilisation d'un fournisseur de type ne peuvent pas être utilisés à partir d'autres assemblys F# et doivent être marqués comme internes ou privés. Envisagez d'utiliser 'type internal TypeName = ...' ou 'type private TypeName = ...'.</value>
  </data>
  <data name="addIndexerDot" xml:space="preserve">
    <value>Ajoutez un . pour l'accès à l'indexeur.</value>
  </data>
  <data name="tcDllImportNotAllowed" xml:space="preserve">
    <value>Les liaisons DLLImport doivent être des membres statiques dans une classe ou des définitions de fonction dans un module</value>
  </data>
  <data name="tcInferredGenericTypeGivesRiseToInconsistency" xml:space="preserve">
    <value>La fonction ou le membre '{0}' est utilisé d'une manière qui nécessite d'autres annotations de type au niveau de sa définition pour garantir la cohérence des types déduits. La signature déduite est '{1}'.</value>
  </data>
  <data name="tcDefaultImplementationAlreadyExists" xml:space="preserve">
    <value>Cette méthode a déjà une implémentation par défaut</value>
  </data>
  <data name="ValueNotContainedMutabilityInstanceButStatic" xml:space="preserve">
    <value>Le module '{0}' contient\n    {1}    \nmais sa signature spécifie\n    {2}    \nLa représentation compilée de cette méthode est celle d'un membre d'instance, mais la signature indique que sa représentation compilée est celle d'un membre statique</value>
  </data>
  <data name="lexInvalidByteLiteral" xml:space="preserve">
    <value>Littéral d'octet non valide</value>
  </data>
</root>