<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Parser.TOKEN.BAR.BAR" xml:space="preserve">
    <value>символ "||"</value>
  </data>
  <data name="NONTERM.Category.ImplementationFile" xml:space="preserve">
    <value> в файле реализации</value>
  </data>
  <data name="NonUniqueInferredAbstractSlot1" xml:space="preserve">
    <value>Элемент "{0}" не соответствует с уникальным абстрактным слотом, основанным только на имени и числе аргументов</value>
  </data>
  <data name="NonUniqueInferredAbstractSlot2" xml:space="preserve">
    <value>. Несколько реализованных интерфейсов имеют элемент с этим именем и числом аргументов</value>
  </data>
  <data name="NonUniqueInferredAbstractSlot3" xml:space="preserve">
    <value>. Рекомендуется явно реализовать интерфейсы "{0}" и "{1}".</value>
  </data>
  <data name="NonUniqueInferredAbstractSlot4" xml:space="preserve">
    <value>. Для указания соответствующего переопределения могут потребоваться дополнительные аннотации типа. Данное предупреждение можно отключить, используя #nowarn "70" или --nowarn 70.</value>
  </data>
  <data name="Parser.TOKEN.LEX.FAILURE" xml:space="preserve">
    <value>лексическая ошибка</value>
  </data>
  <data name="Parser.TOKEN.LPAREN.STAR.RPAREN" xml:space="preserve">
    <value>символ "(*)"</value>
  </data>
  <data name="NONTERM.anonLambdaExpr" xml:space="preserve">
    <value> в лямбда-выражении</value>
  </data>
  <data name="Parser.TOKEN.HIGH.PRECEDENCE.PAREN.APP" xml:space="preserve">
    <value>символ "("</value>
  </data>
  <data name="Parser.TOKEN.CONSTRUCTOR" xml:space="preserve">
    <value>ключевое слово "constructor"</value>
  </data>
  <data name="NONTERM.attributeList" xml:space="preserve">
    <value> в списке атрибутов</value>
  </data>
  <data name="ValNotMutable" xml:space="preserve">
    <value>Это значение не является изменяемым. Рекомендуется использовать ключевое слово с возможностью изменения, например "let mutable {0} = expression".</value>
  </data>
  <data name="ReservedKeyword" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="Parser.TOKEN.PREFIX.OP" xml:space="preserve">
    <value>префиксный оператор</value>
  </data>
  <data name="UpcastUnnecessary" xml:space="preserve">
    <value>Нет необходимости в данном повышении - типы идентичны</value>
  </data>
  <data name="UnitTypeExpectedWithEquality" xml:space="preserve">
    <value>Результат этого выражения равенства неявно удаляется. Рекомендуем использовать let, чтобы привязать результат к имени, например "let result = expression".</value>
  </data>
  <data name="VarBoundTwice" xml:space="preserve">
    <value>"{0}" в данном шаблоне привязан дважды</value>
  </data>
  <data name="UpperCaseIdentifierInPattern" xml:space="preserve">
    <value>Идентификаторы переменных в верхнем регистре обычно не должны использоваться в шаблонах, и могут указывать на неправильно написанное имя шаблона.</value>
  </data>
  <data name="NONTERM.unionCaseRepr" xml:space="preserve">
    <value> в объявлении ветви различаемого объединения</value>
  </data>
  <data name="Parser.TOKEN.TO" xml:space="preserve">
    <value>ключевое слово "to"</value>
  </data>
  <data name="Parser.TOKEN.IF" xml:space="preserve">
    <value>ключевое слово "if"</value>
  </data>
  <data name="Parser.TOKEN.IN" xml:space="preserve">
    <value>ключевое слово "in"</value>
  </data>
  <data name="Parser.TOKEN.AS" xml:space="preserve">
    <value>ключевое слово "as"</value>
  </data>
  <data name="Parser.TOKEN.OR" xml:space="preserve">
    <value>ключевое слово "or"</value>
  </data>
  <data name="Parser.TOKEN.OF" xml:space="preserve">
    <value>ключевое слово "of"</value>
  </data>
  <data name="Parser.TOKEN.DO" xml:space="preserve">
    <value>ключевое слово "do"</value>
  </data>
  <data name="UnitTypeExpected" xml:space="preserve">
    <value>Результат этого выражения неявно игнорируется. Рассмотрите использование здесь "ignore", чтобы отбросить это значение явным образом, например "expr |&gt; ignore", или же "let", чтобы привязать результат к имени, например "let result = expr".</value>
  </data>
  <data name="Parser.TOKEN.INTERFACE" xml:space="preserve">
    <value>ключевое слово "interface"</value>
  </data>
  <data name="NONTERM.fileModuleSpec" xml:space="preserve">
    <value> в сигнатуре модуля или пространства имен</value>
  </data>
  <data name="HashIncludeNotAllowedInNonScript" xml:space="preserve">
    <value>Директивы #I могут встречаться только в файлах скриптов F# (расширения .fsx или .fsscript). Нужно либо переместить данный код в файл скрипта, либо добавить для данной ссылки параметр компилятора "-I", либо ограничить директиву с помощью "#if INTERACTIVE"/"#endif".</value>
  </data>
  <data name="Parser.TOKEN.CONSTRAINT" xml:space="preserve">
    <value>ключевое слово "constraint"</value>
  </data>
  <data name="MSBuildReferenceResolutionError" xml:space="preserve">
    <value>{0} (Код={1})</value>
  </data>
  <data name="NONTERM.classDefnMember" xml:space="preserve">
    <value> в определении элемента</value>
  </data>
  <data name="Parser.TOKEN.FINALLY" xml:space="preserve">
    <value>ключевое слово "finally"</value>
  </data>
  <data name="NONTERM.exconCore" xml:space="preserve">
    <value> в определении исключения</value>
  </data>
  <data name="TokenName1TokenName2TokenName3" xml:space="preserve">
    <value>. Требуется {0}, {1}, {2} или другая лексема.</value>
  </data>
  <data name="Parser.TOKEN.COLON.QMARK" xml:space="preserve">
    <value>символ ":?"</value>
  </data>
  <data name="InterfaceNotRevealed" xml:space="preserve">
    <value>Тип реализует интерфейс "{0}", но это не показывается сигнатурой. Следует указать список в сигнатуре, так как интерфейс можно будет найти через динамические приведения и (или) отражение типов.</value>
  </data>
  <data name="Parser.TOKEN.PUBLIC" xml:space="preserve">
    <value>ключевое слово "public"</value>
  </data>
  <data name="Parser.TOKEN.COLON.COLON" xml:space="preserve">
    <value>символ "::"</value>
  </data>
  <data name="SeeAlso" xml:space="preserve">
    <value>. См. также {0}.</value>
  </data>
  <data name="Parser.TOKEN.LINE.COMMENT" xml:space="preserve">
    <value>строчный комментарий</value>
  </data>
  <data name="VirtualAugmentationOnNullValuedType" xml:space="preserve">
    <value>Содержащийся тип может использовать для своего случая нулевого объединения "null". Вызов абстрактного или виртуального элемента, или же реализации интерфейса на нулевом значении приведет к исключению. При необходимости добавьте в нулевой конструктор значение-заполнитель, чтобы избежать использования "null" в качестве представления для данного типа.</value>
  </data>
  <data name="Parser.TOKEN.UPCAST" xml:space="preserve">
    <value>ключевое слово "upcast"</value>
  </data>
  <data name="Parser.TOKEN.OVERRIDE" xml:space="preserve">
    <value>ключевое слово "override"</value>
  </data>
  <data name="MatchIncomplete1" xml:space="preserve">
    <value>Незавершенный шаблон соответствует данному выражению.</value>
  </data>
  <data name="MatchIncomplete2" xml:space="preserve">
    <value> К примеру, значение "{0}" может указывать на случай, не покрытый шаблоном(ами).</value>
  </data>
  <data name="MatchIncomplete3" xml:space="preserve">
    <value> К примеру, значение "{0}" может указывать на случай, не покрытый шаблоном(ами). Однако, правило шаблона с конструкцией "when" может совпасть с этим значением.</value>
  </data>
  <data name="MatchIncomplete4" xml:space="preserve">
    <value> Элементы без соответствий будут проигнорированы.</value>
  </data>
  <data name="BadEventTransformation" xml:space="preserve">
    <value>Определение к компиляции в качестве события .NET не имеет требуемой формы. Только элементы свойств могут компилироваться как события .NET.</value>
  </data>
  <data name="Parser.TOKEN.INFIX.AT.HAT.OP" xml:space="preserve">
    <value>инфиксный оператор</value>
  </data>
  <data name="NONTERM.ifExprCases" xml:space="preserve">
    <value> в выражении if/then/else</value>
  </data>
  <data name="Parser.TOKEN.STRING" xml:space="preserve">
    <value>строковый литерал</value>
  </data>
  <data name="Parser.TOKEN.STRUCT" xml:space="preserve">
    <value>ключевое слово "struct"</value>
  </data>
  <data name="Parser.TOKEN.STATIC" xml:space="preserve">
    <value>ключевое слово "static"</value>
  </data>
  <data name="Parser.TOKEN.RBRACK" xml:space="preserve">
    <value>символ "]"</value>
  </data>
  <data name="Parser.TOKEN.RBRACE" xml:space="preserve">
    <value>символ "}"</value>
  </data>
  <data name="Parser.TOKEN.RARROW" xml:space="preserve">
    <value>символ "-&gt;"</value>
  </data>
  <data name="Parser.TOKEN.RPAREN" xml:space="preserve">
    <value>символ ")"</value>
  </data>
  <data name="Parser.TOKEN.RQUOTE" xml:space="preserve">
    <value>конец цитирования</value>
  </data>
  <data name="UnresolvedReferenceNoRange" xml:space="preserve">
    <value>Ссылка на требуемую сборку отсутствует. Необходимо добавить ссылку на сборку "{0}".</value>
  </data>
  <data name="IntfImplInExtrinsicAugmentation" xml:space="preserve">
    <value>Реализации интерфейсов должны быть даны при первичном объявлении типа.</value>
  </data>
  <data name="Parser.TOKEN.INLINE" xml:space="preserve">
    <value>ключевое слово "inline"</value>
  </data>
  <data name="LetRecCheckedAtRuntime" xml:space="preserve">
    <value>Эта и другие рекурсивные ссылки на определяемый объект будут проверены на правильность инициализации во время выполнения посредством использования отложенной ссылки. Это происходит потому, что вы определяете один или несколько рекурсивных объектов, а не рекурсивных функций. Данное предупреждение можно отменить, используя #nowarn "40" или --nowarn 40.</value>
  </data>
  <data name="Parser.TOKEN.COLON.QMARK.GREATER" xml:space="preserve">
    <value>символ ":?&gt;"</value>
  </data>
  <data name="PossibleOverload" xml:space="preserve">
    <value>Возможная перегрузка: "{0}". {1}.</value>
  </data>
  <data name="FieldNotMutable" xml:space="preserve">
    <value>Это поле не является изменяемым</value>
  </data>
  <data name="Parser.TOKEN.MEMBER" xml:space="preserve">
    <value>ключевое слово "member"</value>
  </data>
  <data name="Parser.TOKEN.MODULE" xml:space="preserve">
    <value>ключевое слово "module"</value>
  </data>
  <data name="NONTERM.valSpfn" xml:space="preserve">
    <value> в сигнатуре значения</value>
  </data>
  <data name="Parser.TOKEN.LPAREN" xml:space="preserve">
    <value>символ "("</value>
  </data>
  <data name="Parser.TOKEN.LQUOTE" xml:space="preserve">
    <value>начало цитирования</value>
  </data>
  <data name="Parser.TOKEN.INFIX.COMPARE.OP" xml:space="preserve">
    <value>инфиксный оператор</value>
  </data>
  <data name="Parser.TOKEN.LARROW" xml:space="preserve">
    <value>символ "&lt;-"</value>
  </data>
  <data name="Parser.TOKEN.DOWNCAST" xml:space="preserve">
    <value>ключевое слово "downcast"</value>
  </data>
  <data name="Parser.TOKEN.LBRACE" xml:space="preserve">
    <value>символ "{"</value>
  </data>
  <data name="Parser.TOKEN.LBRACK" xml:space="preserve">
    <value>символ "["</value>
  </data>
  <data name="ValNotLocal" xml:space="preserve">
    <value>Это значение не является локальным</value>
  </data>
  <data name="IndeterminateRuntimeCoercion" xml:space="preserve">
    <value>Данное приведение или проверка типа во время выполнения от типа\n    {0}    \n к \n    {1}    \nвключает неопределенный тип, основанный на информации до данной точки программы. Проверки типов во время выполнения не разрешены для некоторых типов. Необходимы дополнительные примечания типа.</value>
  </data>
  <data name="Parser.TOKEN.BAR.RBRACK" xml:space="preserve">
    <value>символ "|]"</value>
  </data>
  <data name="ConstraintSolverMissingConstraint" xml:space="preserve">
    <value>В параметре типа отсутствует ограничение "{0}"</value>
  </data>
  <data name="FixKeyword" xml:space="preserve">
    <value>ключевое слово </value>
  </data>
  <data name="NONTERM.Category.Pattern" xml:space="preserve">
    <value> в шаблоне</value>
  </data>
  <data name="Parser.TOKEN.ASSERT" xml:space="preserve">
    <value>ключевое слово "assert"</value>
  </data>
  <data name="NONTERM.typeArgsActual" xml:space="preserve">
    <value> в аргументах типа</value>
  </data>
  <data name="UnitTypeExpectedWithPossibleAssignment" xml:space="preserve">
    <value>Результат этого выражения равенства неявно удаляется. Рекомендуем использовать let, чтобы привязать результат к имени, например "let result = expression". Если вы собирались изменять значение, пометьте его как mutable и используйте оператор "&lt;-", например "{0} &lt;- expression".</value>
  </data>
  <data name="Parser.TOKEN.ORESET" xml:space="preserve">
    <value>конец входных данных</value>
  </data>
  <data name="TyconBadArgs" xml:space="preserve">
    <value>Для типа "{0}" потребуется {1} аргументов типа, получено {2}</value>
  </data>
  <data name="Parser.TOKEN.ODUMMY" xml:space="preserve">
    <value>внутренняя лексема-заполнитель</value>
  </data>
  <data name="ErrorFromApplyingDefault1" xml:space="preserve">
    <value>Несоответствие ограничений типов при применении типа по умолчанию "{0}" в качестве переменной определения типа. </value>
  </data>
  <data name="ErrorFromApplyingDefault2" xml:space="preserve">
    <value> Попробуйте добавить дополнительные ограничения типа</value>
  </data>
  <data name="Parser.TOKEN.DELEGATE" xml:space="preserve">
    <value>ключевое слово "delegate"</value>
  </data>
  <data name="Parser.TOKEN.INFIX.STAR.DIV.MOD.OP" xml:space="preserve">
    <value>инфиксный оператор</value>
  </data>
  <data name="Parser.TOKEN.EXTERN" xml:space="preserve">
    <value>ключевое слово "extern"</value>
  </data>
  <data name="Parser.TOKEN.EQUALS" xml:space="preserve">
    <value>символ "="</value>
  </data>
  <data name="Parser.TOKEN.DOT.DOT" xml:space="preserve">
    <value>символ ".."</value>
  </data>
  <data name="Parser.TOKEN.DOWNTO" xml:space="preserve">
    <value>ключевое слово "downto"</value>
  </data>
  <data name="Parser.TOKEN.DOLLAR" xml:space="preserve">
    <value>символ "$"</value>
  </data>
  <data name="InvalidRuntimeCoercion" xml:space="preserve">
    <value>Недопустимое приведение или проверка типа во время выполнения от типа {0} к {1}\n{2}</value>
  </data>
  <data name="ErrorFromAddingTypeEquation2" xml:space="preserve">
    <value>Несоответствие типов. Требуется \n    "{0}"    \n, но получен\n    "{1}"    {2}\n</value>
  </data>
  <data name="ErrorFromAddingTypeEquation1" xml:space="preserve">
    <value>В данном выражении требовалось наличие типа\n    "{1}"    \n, но получен тип\n    "{0}"    {2}</value>
  </data>
  <data name="Parser.TOKEN.BINDER" xml:space="preserve">
    <value>ключевое слово binder</value>
  </data>
  <data name="NONTERM.interaction" xml:space="preserve">
    <value> в взаимодействии</value>
  </data>
  <data name="Parser.TOKEN.OBLOCKBEGIN" xml:space="preserve">
    <value>начало структурированной конструкции</value>
  </data>
  <data name="Parser.TOKEN.INFIX.STAR.STAR.OP" xml:space="preserve">
    <value>инфиксный оператор</value>
  </data>
  <data name="IntfImplInIntrinsicAugmentation" xml:space="preserve">
    <value>Реализации интерфейсов в приращениях теперь являются не рекомендуемыми к использованию. Реализации интерфейсов должны быть даны при первичном объявлении типа.</value>
  </data>
  <data name="TypeTestUnnecessary" xml:space="preserve">
    <value>Данная проверка типа или понижение будет всегда сохраняться</value>
  </data>
  <data name="OverrideDoesntOverride2" xml:space="preserve">
    <value>Элемент "{0}" не имеет корректного типа для переопределения какого-либо данного абстрактного метода</value>
  </data>
  <data name="OverrideDoesntOverride3" xml:space="preserve">
    <value> Необходимая сигнатура: {0}.</value>
  </data>
  <data name="OverrideDoesntOverride1" xml:space="preserve">
    <value>Элемент "{0}" не имеет корректного типа для переопределения какого-либо данного виртуального метода</value>
  </data>
  <data name="OverrideDoesntOverride4" xml:space="preserve">
    <value>Член "{0}" специализирован с помощью "unit", но "unit" нельзя использовать в качестве типа возвращаемого значения абстрактного метода, параметризованного по типу возвращаемого значения.</value>
  </data>
  <data name="NONTERM.hashDirective" xml:space="preserve">
    <value> в директиве</value>
  </data>
  <data name="Parser.TOKEN.GLOBAL" xml:space="preserve">
    <value>ключевое слово "global"</value>
  </data>
  <data name="NONTERM.classMemberSpfn" xml:space="preserve">
    <value> в сигнатуре элемента</value>
  </data>
  <data name="Parser.TOKEN.ADJACENT.PREFIX.OP" xml:space="preserve">
    <value>префиксный оператор</value>
  </data>
  <data name="Parser.TOKEN.OFUNCTION" xml:space="preserve">
    <value>ключевое слово "function"</value>
  </data>
  <data name="NONTERM.hardwhiteLetBindings" xml:space="preserve">
    <value> в привязке</value>
  </data>
  <data name="TokenName1" xml:space="preserve">
    <value>. Требуется {0} или другая лексема.</value>
  </data>
  <data name="Parser.TOKEN.OINTERFACE.MEMBER" xml:space="preserve">
    <value>ключевое слово "interface"</value>
  </data>
  <data name="Parser.TOKEN.SEMICOLON.SEMICOLON" xml:space="preserve">
    <value>символ ";;"</value>
  </data>
  <data name="FixReplace" xml:space="preserve">
    <value> (из-за синтаксиса с учетом отступов)</value>
  </data>
  <data name="LetRecEvaluatedOutOfOrder" xml:space="preserve">
    <value>Из-за этой короткой ссылки привязки могут выполняться с нарушением порядка.</value>
  </data>
  <data name="FixSymbol" xml:space="preserve">
    <value>символ </value>
  </data>
  <data name="Parser.TOKEN.DECIMAL" xml:space="preserve">
    <value>десятичный литерал</value>
  </data>
  <data name="Obsolete1" xml:space="preserve">
    <value>Такая конструкция не рекомендуется к использованию</value>
  </data>
  <data name="Obsolete2" xml:space="preserve">
    <value>. {0}</value>
  </data>
  <data name="Parser.TOKEN.DEFAULT" xml:space="preserve">
    <value>ключевое слово "default"</value>
  </data>
  <data name="NONTERM.recdExpr" xml:space="preserve">
    <value> в выражении записи</value>
  </data>
  <data name="IndeterminateType" xml:space="preserve">
    <value>Поиск объекта неопределенного типа, основанного на информации до данной точки программы. Возможно, перед данной точкой программы потребуется аннотация типа, с целью ограничения типа объекта. Возможно, это позволит разрешить поиск.</value>
  </data>
  <data name="DeprecatedThreadStaticBindingWarning" xml:space="preserve">
    <value>Привязки статического потока и статического контекста "let" не рекомендуются к использованию. Вместо них используется объявление формы "static val mutable &lt;ident&gt; : &lt;type&gt;" в классе. Добавьте атрибут "DefaultValue", чтобы показать, что значение инициализируется как значение по умолчанию в каждом новом потоке.</value>
  </data>
  <data name="TargetInvocationExceptionWrapper" xml:space="preserve">
    <value>внутренняя ошибка: {0}</value>
  </data>
  <data name="NONTERM.typeConstraint" xml:space="preserve">
    <value> в ограничении типа</value>
  </data>
  <data name="Parser.TOKEN.FUNKY.OPERATOR.NAME" xml:space="preserve">
    <value>имя оператора</value>
  </data>
  <data name="UnresolvedPathReferenceNoRange" xml:space="preserve">
    <value>Тип, на который есть ссылка через "{0}", определен в сборке, ссылка на которую отсутствует. Необходимо добавить ссылку на сборку "{1}".</value>
  </data>
  <data name="Experimental" xml:space="preserve">
    <value>{0}. Данное предупреждение можно отключить, используя --nowarn 57 или #nowarn "57".</value>
  </data>
  <data name="Failure4" xml:space="preserve">
    <value>внутренняя ошибка: {0}</value>
  </data>
  <data name="Failure1" xml:space="preserve">
    <value>ошибка синтаксического анализа</value>
  </data>
  <data name="Failure3" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="Failure2" xml:space="preserve">
    <value>ошибка синтаксического анализа: непредвиденный конец файла</value>
  </data>
  <data name="HashLoadedScriptConsideredSource" xml:space="preserve">
    <value>Загруженные файлы могут являться только исходными файлами F# (расширение .fs). Данный файл скрипта F# (.fsx или .fsscript) будет рассмотрен, как исходный файл F#</value>
  </data>
  <data name="ConstraintSolverInfiniteTypes" xml:space="preserve">
    <value>Невозможно объединить типы "{0}" и "{1}".</value>
  </data>
  <data name="NameClash2" xml:space="preserve">
    <value>{0} "{1}" не удается определить, так как имя "{2}" конфликтует с {3} "{4}" в данном типе или модуле</value>
  </data>
  <data name="NameClash1" xml:space="preserve">
    <value>Повторяющееся определение {0} "{1}"</value>
  </data>
  <data name="NONTERM.openDecl" xml:space="preserve">
    <value> в объявлении open</value>
  </data>
  <data name="LetRecUnsound1" xml:space="preserve">
    <value>Значение "{0}" будет оценено как часть его собственного определения</value>
  </data>
  <data name="LetRecUnsound2" xml:space="preserve">
    <value>Это значение впоследствии будет оценено как часть его собственного определения. Может потребоваться сделать значение неактивным или функцией. Значение "{0}"{1}.</value>
  </data>
  <data name="Parser.TOKEN.KEYWORD_STRING" xml:space="preserve">
    <value>сформированный компилятором литерал</value>
  </data>
  <data name="MissingFields" xml:space="preserve">
    <value>Для следующих полей требуются значения: {0}</value>
  </data>
  <data name="Parser.TOKEN.INACTIVECODE" xml:space="preserve">
    <value>неактивный код</value>
  </data>
  <data name="ConstraintSolverTypesNotInSubsumptionRelation" xml:space="preserve">
    <value>Тип "{0}" несовместим с типом "{1}"{2}</value>
  </data>
  <data name="Parser.TOKEN.ABSTRACT" xml:space="preserve">
    <value>ключевое слово "abstract"</value>
  </data>
  <data name="Parser.TOKEN.NAMESPACE" xml:space="preserve">
    <value>ключевое слово "namespace"</value>
  </data>
  <data name="Parser.TOKEN.OBLOCKEND" xml:space="preserve">
    <value>неполный структурированный конструктор в текущей точке или перед ней</value>
  </data>
  <data name="UnitTypeExpectedWithPossiblePropertySetter" xml:space="preserve">
    <value>Результат этого выражения равенства неявно удаляется. Рекомендуем использовать let, чтобы привязать результат к имени, например "let result = expression". Если вы собирались присваивать значение свойству, используйте оператор "&lt;-", например "{0}.{1} &lt;- expression".</value>
  </data>
  <data name="TokenName1TokenName2" xml:space="preserve">
    <value>. Требуется {0}, {1} или другая лексема.</value>
  </data>
  <data name="Parser.TOKEN.QMARK.QMARK" xml:space="preserve">
    <value>символ "??"</value>
  </data>
  <data name="NotUpperCaseConstructor" xml:space="preserve">
    <value>Дискриминированные случаи объединения и метки исключений должны являться идентификаторами верхнего регистра</value>
  </data>
  <data name="UnionPatternsBindDifferentNames" xml:space="preserve">
    <value>Две стороны данного шаблона "or" связывают различные наборы переменных</value>
  </data>
  <data name="LoadedSourceNotFoundIgnoring" xml:space="preserve">
    <value>Не удалось загрузить файл "{0}", так как он не существует или недоступен</value>
  </data>
  <data name="FunctionValueUnexpected" xml:space="preserve">
    <value>Данное выражение является значением функции, напр. в нем отсутствуют аргументы. Его тип - {0}.</value>
  </data>
  <data name="Parser.TOKEN.HIGH.PRECEDENCE.BRACK.APP" xml:space="preserve">
    <value>символ "["</value>
  </data>
  <data name="Parser.TOKEN.MUTABLE" xml:space="preserve">
    <value>ключевое слово "mutable"</value>
  </data>
  <data name="NONTERM.Category.Definition" xml:space="preserve">
    <value> в определении</value>
  </data>
  <data name="Parser.TOKEN.GREATER.BAR.RBRACK" xml:space="preserve">
    <value>символ "&gt;|]"</value>
  </data>
  <data name="IndentationProblem" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="Parser.TOKEN.WHITESPACE" xml:space="preserve">
    <value>пустое пространство</value>
  </data>
  <data name="Parser.TOKEN.PRIVATE" xml:space="preserve">
    <value>ключевое слово "private"</value>
  </data>
  <data name="HashReferenceNotAllowedInNonScript" xml:space="preserve">
    <value>Директивы #r могут встречаться только в файлах сценариев F# (файлы с расширениями .fsx или .fsscript). Переместите этот код в файл сценария или замените эту ссылку параметром компилятора "-r". Если эта директива выполняется в качестве пользовательских входных данных, вы можете заключить ее в блок "#if INTERACTIVE"/"#endif".</value>
  </data>
  <data name="Parser.TOKEN.STRING.TEXT" xml:space="preserve">
    <value>строковый текст</value>
  </data>
  <data name="Parser.TOKEN.INT32.DOT.DOT" xml:space="preserve">
    <value>целое..</value>
  </data>
  <data name="NONTERM.fieldDecl" xml:space="preserve">
    <value> в объявлении поля</value>
  </data>
  <data name="Recursion" xml:space="preserve">
    <value>Использование функции "{0}" не совпадает с типом, логически выводимым где-то еще. Логически выводимым типом функции является \n    {1}.    \nТипом требуемой в данный момент использования функцией является \n    {2}    {3}\nДанная ошибка может происходить из-за ограничений, связанных с базовой рекурсией внутри коллекции "let rec", или внутри группы классов. Рекомендуется предоставить сигнатуру полного типа для целей рекурсивных вызовов, включая аннотации типов для типов возвращаемых значений и аргумента.</value>
  </data>
  <data name="CoercionTargetSealed" xml:space="preserve">
    <value>Тип "{0}" не имеет каких-либо корректных подтипов и не должен использоваться в качестве цели статического преобразования</value>
  </data>
  <data name="NONTERM.beginEndExpr" xml:space="preserve">
    <value> в выражении begin/end</value>
  </data>
  <data name="Parser.TOKEN.LBRACE.LESS" xml:space="preserve">
    <value>символ "{&lt;"</value>
  </data>
  <data name="Parser.TOKEN.COLON.EQUALS" xml:space="preserve">
    <value>символ ":="</value>
  </data>
  <data name="Parser.TOKEN.INHERIT" xml:space="preserve">
    <value>ключевое слово "inherit"</value>
  </data>
  <data name="Parser.TOKEN.TRY" xml:space="preserve">
    <value>ключевое слово "try"</value>
  </data>
  <data name="Parser.TOKEN.SIG" xml:space="preserve">
    <value>ключевое слово "sig"</value>
  </data>
  <data name="Parser.TOKEN.REC" xml:space="preserve">
    <value>ключевое слово "rec"</value>
  </data>
  <data name="Parser.TOKEN.INT" xml:space="preserve">
    <value>целочисленный литерал</value>
  </data>
  <data name="Parser.TOKEN.VAL" xml:space="preserve">
    <value>ключевое слово "val"</value>
  </data>
  <data name="Parser.TOKEN.ASR" xml:space="preserve">
    <value>ключевое слово "asr"</value>
  </data>
  <data name="Parser.TOKEN.AND" xml:space="preserve">
    <value>ключевое слово "and"</value>
  </data>
  <data name="Parser.TOKEN.AMP" xml:space="preserve">
    <value>символ "&amp;"</value>
  </data>
  <data name="Parser.TOKEN.ODO" xml:space="preserve">
    <value>ключевое слово "do"</value>
  </data>
  <data name="Parser.TOKEN.NEW" xml:space="preserve">
    <value>ключевое слово "new"</value>
  </data>
  <data name="Parser.TOKEN.END" xml:space="preserve">
    <value>ключевое слово "end"</value>
  </data>
  <data name="Parser.TOKEN.EOF" xml:space="preserve">
    <value>конец входных данных</value>
  </data>
  <data name="Parser.TOKEN.DOT" xml:space="preserve">
    <value>символ "."</value>
  </data>
  <data name="Parser.TOKEN.BAR" xml:space="preserve">
    <value>символ "|"</value>
  </data>
  <data name="Parser.TOKEN.FUN" xml:space="preserve">
    <value>ключевое слово "fun"</value>
  </data>
  <data name="Parser.TOKEN.FOR" xml:space="preserve">
    <value>ключевое слово "for"</value>
  </data>
  <data name="NonRigidTypar1" xml:space="preserve">
    <value>Данная конструкция служит причиной того, что код становится менее базовым, чем указано в аннотации его типа. Переменная типа, подразумеваемая использованием "#", "_" или другой аннотации типа в "{0}" или рядом, была ограничена до типа "{1}".</value>
  </data>
  <data name="NonRigidTypar3" xml:space="preserve">
    <value>Данная конструкция служит причиной того, что код становится менее базовым, чем указано в аннотациях типа. Переменная типа "{0}" была ограничена до типа "{1}".</value>
  </data>
  <data name="NonRigidTypar2" xml:space="preserve">
    <value>Данная конструкция служит причиной того, что код становится менее базовым, чем указано в аннотациях типа. Переменная единицы измерения "{0}" была ограничена до измерения "{1}".</value>
  </data>
  <data name="Parser.TOKEN.COMMENT" xml:space="preserve">
    <value>комментарий</value>
  </data>
  <data name="OverrideInIntrinsicAugmentation" xml:space="preserve">
    <value>Реализации переопределений в приращениях теперь не рекомендуются к использованию. Реализации переопределений должны быть даны при первичном объявлении типа.</value>
  </data>
  <data name="Parser.TOKEN.PLUS.MINUS.OP" xml:space="preserve">
    <value>инфиксный оператор</value>
  </data>
  <data name="RecursiveUseCheckedAtRuntime" xml:space="preserve">
    <value>Это рекурсивное использование будет проверено на правильность инициализации во время выполнения. Данное предупреждение обычно безвредно; его можно отменить, используя #nowarn "21" или --nowarn 21.</value>
  </data>
  <data name="OverrideInExtrinsicAugmentation" xml:space="preserve">
    <value>Реализации переопределений должны быть даны при первичном объявлении типа.</value>
  </data>
  <data name="NonVirtualAugmentationOnNullValuedType" xml:space="preserve">
    <value>Содержащийся тип может использовать для своего случая нулевого объединения "null". Данный элемент будет скомпилирован, как статический.</value>
  </data>
  <data name="ErrorsFromAddingSubsumptionConstraint" xml:space="preserve">
    <value>Несоответствие ограничений типов. Тип \n    "{0}"    \nнесовместим с типом\n    "{1}"    {2}\n</value>
  </data>
  <data name="FileNameNotResolved" xml:space="preserve">
    <value>Не удается найти файл "{0}" в любом из\n {1}</value>
  </data>
  <data name="Parser.TOKEN.HIGH.PRECEDENCE.TYAPP" xml:space="preserve">
    <value>приложение типа</value>
  </data>
  <data name="HashDirectiveNotAllowedInNonScript" xml:space="preserve">
    <value>Данная директива может использоваться только в файлах скриптов F# (расширения .fsx или .fsscript). Нужно либо удалить директиву, либо переместить данный код в файл скрипта, либо ограничить директиву с помощью "#if INTERACTIVE"/"#endif".</value>
  </data>
  <data name="ConstraintSolverTypesNotInEqualityRelation2" xml:space="preserve">
    <value>Тип "{0}" не совпадает с типом "{1}"</value>
  </data>
  <data name="ConstraintSolverTypesNotInEqualityRelation1" xml:space="preserve">
    <value>Единица измерения "{0}" не совпадает с единицей измерения "{1}"</value>
  </data>
  <data name="Parser.TOKEN.INTERNAL" xml:space="preserve">
    <value>ключевое слово "internal"</value>
  </data>
  <data name="Parser.TOKEN.LBRACK.LESS" xml:space="preserve">
    <value>символ "[&lt;"</value>
  </data>
  <data name="Parser.TOKEN.GREATER" xml:space="preserve">
    <value>символ "&gt;"</value>
  </data>
  <data name="LibraryUseOnly" xml:space="preserve">
    <value>Такая конструкция не рекомендуется к использованию: она используется только в библиотеке F#</value>
  </data>
  <data name="ValueRestriction2" xml:space="preserve">
    <value>Ограничение значения. Значение "{0}" имеет универсальный тип\n    {1}    \nЛибо сделайте "{2}" функцией с явными аргументами, либо (если универсальный тип не требуется) добавьте аннотацию типа.</value>
  </data>
  <data name="ValueRestriction3" xml:space="preserve">
    <value>Ограничение значения. Данный выведенный элемент должен иметь универсальный тип\n    {0}    \nМетоды чтения и записи свойств и конструкторов не могут быть более универсальными, чем вмещающий тип.  Добавьте аннотацию типа, чтобы точно обозначить затрагиваемые типы.</value>
  </data>
  <data name="ValueRestriction1" xml:space="preserve">
    <value>Ограничение значения. Значение "{0}" имеет универсальный тип\n    {1}    \nЛибо сделайте аргументы для "{2}" явными либо (если универсальный тип не требуется) добавьте аннотацию типа.</value>
  </data>
  <data name="ValueRestriction4" xml:space="preserve">
    <value>Ограничение значения. Выведенное значение "{0}" должно иметь универсальный тип\n    {1}    \nЛибо сделайте аргументы для "{2}" явными, либо (если универсальный тип не требуется) добавьте аннотацию типа.</value>
  </data>
  <data name="ValueRestriction5" xml:space="preserve">
    <value>Ограничение значения. Выведенное значение "{0}" должно иметь универсальный тип\n    {1}    \nЛибо определите "{2}" как простой член данных, либо сделайте его функцией с явными аргументами, либо (если универсальный тип не требуется) добавьте аннотацию типа.</value>
  </data>
  <data name="NONTERM.patternClauses" xml:space="preserve">
    <value> в сопоставлении шаблона</value>
  </data>
  <data name="UnexpectedEndOfInput" xml:space="preserve">
    <value>Непредвиденный конец входных данных</value>
  </data>
  <data name="NONTERM.tyconDefn" xml:space="preserve">
    <value> в определении типа</value>
  </data>
  <data name="NONTERM.tyconSpfn" xml:space="preserve">
    <value> в сигнатуре типа</value>
  </data>
  <data name="NONTERM.Category.SignatureFile" xml:space="preserve">
    <value> в файле сигнатуры</value>
  </data>
  <data name="NONTERM.quoteExpr" xml:space="preserve">
    <value> в литерале цитирования</value>
  </data>
  <data name="HashLoadedSourceHasIssues1" xml:space="preserve">
    <value>Одно или несколько предупреждений в загруженном файле.\n</value>
  </data>
  <data name="HashLoadedSourceHasIssues2" xml:space="preserve">
    <value>Одна или несколько ошибок в загруженном файле.\n</value>
  </data>
  <data name="BakedInMemberConstraintName" xml:space="preserve">
    <value>Ограничения элементов с именем "{0}" получают особый статус в компиляторе F#, так как некоторые типы .NET неявно приращиваются к этим элементам. Результатом могут послужить сбои во время выполнения при попытке вызова ограничения элемента из собственного кода.</value>
  </data>
  <data name="NONTERM.localBinding" xml:space="preserve">
    <value> в привязке</value>
  </data>
  <data name="Duplicate2" xml:space="preserve">
    <value>Повторяющееся определение {0} "{1}"</value>
  </data>
  <data name="Duplicate1" xml:space="preserve">
    <value>Два элемента с именем "{0}" имеют одну и ту же сигнатуру</value>
  </data>
  <data name="Parser.TOKEN.INSTANCE" xml:space="preserve">
    <value>ключевое слово "instance"</value>
  </data>
  <data name="UseOfAddressOfOperator" xml:space="preserve">
    <value>Использование собственных указателей может повлечь за собой непроверяемый код .NET IL</value>
  </data>
  <data name="RuntimeCoercionSourceSealed2" xml:space="preserve">
    <value>Тип "{0}" не имеет подходящих подтипов и не может использоваться как источник проверки или приведения типов во время выполнения.</value>
  </data>
  <data name="RuntimeCoercionSourceSealed1" xml:space="preserve">
    <value>Тип "{0}" не может быть использован, как источник типового теста или преобразование во время выполнения</value>
  </data>
  <data name="Parser.TOKEN.ODO.BANG" xml:space="preserve">
    <value>ключевое слово "do!"</value>
  </data>
  <data name="Parser.TOKEN.UNDERSCORE" xml:space="preserve">
    <value>символ "_"</value>
  </data>
  <data name="ParameterlessStructCtor" xml:space="preserve">
    <value>Конструкторы неявных объектов для структур должны принимать по меньшей мере один аргумент</value>
  </data>
  <data name="Parser.TOKEN.PERCENT.OP" xml:space="preserve">
    <value>символ "{0}</value>
  </data>
  <data name="Parser.TOKEN.RESERVED" xml:space="preserve">
    <value>зарезервированное ключевое слово</value>
  </data>
  <data name="Parser.TOKEN.SPLICE.SYMBOL" xml:space="preserve">
    <value>символ "splice"</value>
  </data>
  <data name="SelfRefObjCtor1" xml:space="preserve">
    <value>Рекурсивные ссылки на определяемый объект будут проверены на правильность инициализации во время выполнения посредством использования отложенной ссылки. Попробуйте разместить рекурсивные ссылки в элементах или в завершающем выражении в форме "&lt;ctor-expr&gt; then &lt;expr&gt;".</value>
  </data>
  <data name="SelfRefObjCtor2" xml:space="preserve">
    <value>Рекурсивные ссылки на определяемый объект будут проверены на правильность инициализации во время выполнения посредством использования отложенной ссылки. Попробуйте разместить рекурсивные ссылки в операторах "do" после последнего "let" с привязкой к последовательности конструкторов.</value>
  </data>
  <data name="Parser.TOKEN.COLON.GREATER" xml:space="preserve">
    <value>символ ":&gt;"</value>
  </data>
  <data name="UnionCaseWrongArguments" xml:space="preserve">
    <value>Данный конструктор применен к {0} аргументам; требуется {1}</value>
  </data>
  <data name="Parser.TOKEN.FUNCTION" xml:space="preserve">
    <value>ключевое слово "function"</value>
  </data>
  <data name="Deprecated" xml:space="preserve">
    <value>Такая конструкция не рекомендуется к использованию: {0}</value>
  </data>
  <data name="Parser.TOKEN.HASH.ENDIF" xml:space="preserve">
    <value>директива</value>
  </data>
  <data name="TypeIsImplicitlyAbstract" xml:space="preserve">
    <value>Данный тип является абстрактным, так как для некоторых абстрактных элементов не сделано реализации. Если это произошло намеренно, следует добавить к типу атрибут "[&lt;AbstractClass&gt;]".</value>
  </data>
  <data name="UndefinedName2" xml:space="preserve">
    <value> Конструкция с данным именем была найдена в FSharp.PowerPack.dll; она содержит некоторые модели и типы, на которые есть неявные ссылки в некоторых предыдущих версиях F#. Возможно, потребуется добавить явную ссылку на данный DLL, чтобы скомпилировать этот код.</value>
  </data>
  <data name="Unexpected" xml:space="preserve">
    <value>Недопустимый {0}</value>
  </data>
  <data name="Parser.TOKEN.YIELD.BANG" xml:space="preserve">
    <value>yield!</value>
  </data>
  <data name="Parser.TOKEN.YIELD" xml:space="preserve">
    <value>yield</value>
  </data>
  <data name="Parser.TOKEN.QMARK" xml:space="preserve">
    <value>символ "?"</value>
  </data>
  <data name="Parser.TOKEN.QUOTE" xml:space="preserve">
    <value>символ кавычки</value>
  </data>
  <data name="StaticCoercionShouldUseBox" xml:space="preserve">
    <value>Приведение от типа-значения \n    {0}    \nк типу \n    {1}    \nвызовет упаковку. Рекомендуется вместо этого использовать "box"</value>
  </data>
  <data name="Parser.TOKEN.IDENT" xml:space="preserve">
    <value>идентификатор</value>
  </data>
  <data name="Parser.TOKEN.WHILE" xml:space="preserve">
    <value>ключевое слово "while"</value>
  </data>
  <data name="Parser.TOKEN.MATCH" xml:space="preserve">
    <value>ключевое слово "match"</value>
  </data>
  <data name="Parser.TOKEN.MINUS" xml:space="preserve">
    <value>символ "-"</value>
  </data>
  <data name="Parser.TOKEN.OWITH" xml:space="preserve">
    <value>ключевое слово "with"</value>
  </data>
  <data name="Parser.TOKEN.OTHEN" xml:space="preserve">
    <value>ключевое слово "then"</value>
  </data>
  <data name="Parser.TOKEN.OELSE" xml:space="preserve">
    <value>ключевое слово "else"</value>
  </data>
  <data name="Parser.TOKEN.COLON" xml:space="preserve">
    <value>символ ":"</value>
  </data>
  <data name="Parser.TOKEN.COMMA" xml:space="preserve">
    <value>символ ","</value>
  </data>
  <data name="Parser.TOKEN.CONST" xml:space="preserve">
    <value>ключевое слово const</value>
  </data>
  <data name="Parser.TOKEN.CLASS" xml:space="preserve">
    <value>ключевое слово "class"</value>
  </data>
  <data name="Parser.TOKEN.BEGIN" xml:space="preserve">
    <value>ключевое слово "begin"</value>
  </data>
  <data name="Parser.TOKEN.FLOAT" xml:space="preserve">
    <value>литерал с плавающей точкой</value>
  </data>
  <data name="Parser.TOKEN.FIXED" xml:space="preserve">
    <value>ключевое слово "fixed"</value>
  </data>
  <data name="Parser.TOKEN.FALSE" xml:space="preserve">
    <value>ключевое слово "false"</value>
  </data>
  <data name="BlockEndSentence" xml:space="preserve">
    <value>Неполный структурированный конструктор в текущей точке или перед ней</value>
  </data>
  <data name="RequiredButNotSpecified" xml:space="preserve">
    <value>Для модуля "{0}" требуется {1} "{2}"</value>
  </data>
  <data name="NONTERM.cPrototype" xml:space="preserve">
    <value> в объявлении extern</value>
  </data>
  <data name="NONTERM.Category.Type" xml:space="preserve">
    <value> в типе</value>
  </data>
  <data name="NONTERM.Category.Expr" xml:space="preserve">
    <value> в выражении</value>
  </data>
  <data name="NONTERM.attrUnionCaseDecl" xml:space="preserve">
    <value> в ветви объединения</value>
  </data>
  <data name="Parser.TOKEN.BYTEARRAY" xml:space="preserve">
    <value>литерал массива байтов</value>
  </data>
  <data name="LetRecUnsoundInner" xml:space="preserve">
    <value> вычислит "{0}"</value>
  </data>
  <data name="RuleNeverMatched" xml:space="preserve">
    <value>Данное правило никогда не будет сопоставлено</value>
  </data>
  <data name="ValueNotContained" xml:space="preserve">
    <value>Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \n{3}.</value>
  </data>
  <data name="PossibleBestOverload" xml:space="preserve">
    <value>\n\nВозможная наилучшая перегрузка: '{0}'.</value>
  </data>
  <data name="Parser.TOKEN.LBRACK.BAR" xml:space="preserve">
    <value>символ "[|"</value>
  </data>
  <data name="ConstraintSolverTupleDiffLengths" xml:space="preserve">
    <value>Кортежи имеют различающиеся длины {0} и {1}</value>
  </data>
  <data name="Parser.TOKEN.TYPE" xml:space="preserve">
    <value>ключевое слово "type"</value>
  </data>
  <data name="Parser.TOKEN.TRUE" xml:space="preserve">
    <value>ключевое слово "true"</value>
  </data>
  <data name="Parser.TOKEN.STAR" xml:space="preserve">
    <value>символ "*"</value>
  </data>
  <data name="Parser.TOKEN.HASH" xml:space="preserve">
    <value>символ #</value>
  </data>
  <data name="Parser.TOKEN.WHEN" xml:space="preserve">
    <value>ключевое слово "when"</value>
  </data>
  <data name="Parser.TOKEN.WITH" xml:space="preserve">
    <value>ключевое слово "with"</value>
  </data>
  <data name="Parser.TOKEN.VOID" xml:space="preserve">
    <value>ключевое слово "void"</value>
  </data>
  <data name="Parser.TOKEN.LESS" xml:space="preserve">
    <value>символ "&lt;"</value>
  </data>
  <data name="Parser.TOKEN.LAZY" xml:space="preserve">
    <value>ключевое слово "lazy"</value>
  </data>
  <data name="Parser.TOKEN.OPEN" xml:space="preserve">
    <value>ключевое слово "open"</value>
  </data>
  <data name="Parser.TOKEN.OFUN" xml:space="preserve">
    <value>ключевое слово "fun"</value>
  </data>
  <data name="Parser.TOKEN.OLET" xml:space="preserve">
    <value>ключевое слово "let" или "use"</value>
  </data>
  <data name="Parser.TOKEN.NULL" xml:space="preserve">
    <value>ключевое слово "null"</value>
  </data>
  <data name="Parser.TOKEN.ELIF" xml:space="preserve">
    <value>ключевое слово "elif"</value>
  </data>
  <data name="Parser.TOKEN.DONE" xml:space="preserve">
    <value>ключевое слово "done"</value>
  </data>
  <data name="Parser.TOKEN.CHAR" xml:space="preserve">
    <value>символьный литерал</value>
  </data>
  <data name="Parser.TOKEN.BASE" xml:space="preserve">
    <value>ключевое слово "base"</value>
  </data>
  <data name="AssemblyNotResolved" xml:space="preserve">
    <value>Ссылка на сборку "{0}" не была найдена либо является недопустимой</value>
  </data>
  <data name="RecoverableParseError" xml:space="preserve">
    <value>синтаксическая ошибка</value>
  </data>
  <data name="FieldsFromDifferentTypes" xml:space="preserve">
    <value>Поля "{0}" и "{1}" принадлежат различным типам</value>
  </data>
  <data name="DefensiveCopyWarning" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="NONTERM.typeNameInfo" xml:space="preserve">
    <value> в имени типа</value>
  </data>
  <data name="Parser.TOKEN.AMP.AMP" xml:space="preserve">
    <value>символ "&amp;&amp;"</value>
  </data>
  <data name="InvalidInternalsVisibleToAssemblyName1" xml:space="preserve">
    <value>Недопустимое имя сборки "{0}" из атрибута InternalsVisibleTo в {1}</value>
  </data>
  <data name="InvalidInternalsVisibleToAssemblyName2" xml:space="preserve">
    <value>Недопустимое имя сборки "{0}" из атрибута InternalsVisibleTo (имя файла сборки недоступно)</value>
  </data>
  <data name="FunctionExpected" xml:space="preserve">
    <value>Эта функция принимает слишком много аргументов либо используется в контексте, где функции не допускаются</value>
  </data>
  <data name="UnitTypeExpectedWithPossibleAssignmentToMutable" xml:space="preserve">
    <value>Результат этого выражения равенства неявно удаляется. Рекомендуем использовать let, чтобы привязать результат к имени, например "let result = expression". Если вы собирались изменять значение, используйте оператор "&lt;-", например "{0} &lt;- expression".</value>
  </data>
  <data name="IndeterminateStaticCoercion" xml:space="preserve">
    <value>Статическое приведение от типа \n    {0}    \nк \n    {1}    \n включает неопределенный тип, основанный на информации до данной точки программы. Статическое приведение не разрешено для некоторых типов. Необходимы дополнительные примечания типа.</value>
  </data>
  <data name="PossibleUnverifiableCode" xml:space="preserve">
    <value>Использование данной конструкции может повлечь за собой создание непроверяемого кода .NET IL. Данное предупреждение можно отключить, используя --nowarn 9 или #nowarn "9".</value>
  </data>
  <data name="FullAbstraction" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="Parser.TOKEN.INFIX.AMP.OP" xml:space="preserve">
    <value>инфиксный оператор</value>
  </data>
  <data name="NONTERM.defnBindings" xml:space="preserve">
    <value> в определениях</value>
  </data>
  <data name="Parser.TOKEN.SEMICOLON" xml:space="preserve">
    <value>символ ";"</value>
  </data>
  <data name="Parser.TOKEN.INFIX.BAR.OP" xml:space="preserve">
    <value>инфиксный оператор</value>
  </data>
  <data name="NONTERM.objectImplementationMembers" xml:space="preserve">
    <value> в выражении объекта</value>
  </data>
  <data name="Parser.TOKEN.GREATER.RBRACE" xml:space="preserve">
    <value>символ "&gt;}"</value>
  </data>
  <data name="Parser.TOKEN.GREATER.RBRACK" xml:space="preserve">
    <value>символ "&gt;]"</value>
  </data>
  <data name="Parser.TOKEN.EXCEPTION" xml:space="preserve">
    <value>ключевое слово "exception"</value>
  </data>
</root>